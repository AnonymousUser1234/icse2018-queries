zookeeper-3.4.5
ZOOKEEPER-1861
https://issues.apache.org/jira/browse/ZOOKEEPER-1861
ConcurrentHashMap isn't used properly in QuorumCnxManager queueSendMap is a ConcurrentHashMap. At line 210: if (!queueSendMap.containsKey(sid)) { queueSendMap.put(sid, new ArrayBlockingQueue<ByteBuffer>( SEND_CAPACITY)); By the time control enters if block, there may be another concurrent put with same sid to the ConcurrentHashMap. putIfAbsent() should be used. Similar issue occurs at line 307 as well.
isn't used properly in  By the time control enters if block, there may be another concurrent put with same sid to the should be used. Similar issue occurs at line 307 as well.
******
src.java.main.org.apache.zookeeper.server.quorum.QuorumCnxManager.QuorumCnxManager.initiateConnection(Socket, Long), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumCnxManager.QuorumCnxManager.receiveConnection(Socket), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumCnxManager.QuorumCnxManager.toSend(Long, ByteBuffer), true
#####
zookeeper-3.4.5
ZOOKEEPER-1860
https://issues.apache.org/jira/browse/ZOOKEEPER-1860
Async versions of reconfig don't actually throw KeeperException nor InterruptedException This was caught by Camille Fournier, the async versions of reconfig in the Java client don't actually throw KeeperException nor InterruptedException. Since this is unreleased code (i.e.: for 3.5.0) I don't think there are issues with changing the API (that is, considering what exceptions are thrown part of the API).
Async versions of reconfig don't actually throw This was caught by Camille Fournier, the async versions of reconfig in the Java client don't actually throw Since this is unreleased code (i.e.: for 3.5.0) I don't think there are issues with changing the API (that is, considering what exceptions are thrown part of the API).
******
src.java.main.org.apache.zookeeper.ZooKeeper.ZooKeeper.reconfig(String, String, String, long, DataCallback, Object), false, method_signature
src.java.main.org.apache.zookeeper.ZooKeeper.ZooKeeper.reconfig(List<String>, List<String>, List<String>, long, DataCallback, Object), false, method_signature
#####
zookeeper-3.4.5
ZOOKEEPER-1815
https://issues.apache.org/jira/browse/ZOOKEEPER-1815
Tolerate incorrectly set system hostname in tests A bunch of tests will fail with UnknownHostException errors when the hostname is incorrectly set on the system that you are running tests on.
Tolerate incorrectly set system hostname in tests A bunch of tests will fail with errors when the hostname is incorrectly set on the system that you are running tests on.
******
src.java.test.org.apache.zookeeper.test.FLETest.FLETest.testJoinInconsistentEnsemble(), false, test_method
src.java.test.org.apache.zookeeper.test.NIOConnectionFactoryFdLeakTest.NIOConnectionFactoryFdLeakTest.testFileDescriptorLeak(), false, test_method
src.java.test.org.apache.zookeeper.test.FLENewEpochTest.FLENewEpochTest.testLENewEpoch(), false, test_method
src.java.test.org.apache.zookeeper.ClientReconnectTest.ClientReconnectTest.testClientReconnect(), false, test_method
src.java.test.org.apache.zookeeper.test.FLELostMessageTest.FLELostMessageTest.testLostMessage(), false, test_method
src.java.test.org.apache.zookeeper.test.FLERestartTest.FLERestartTest.testLERestart(), false, test_method
src.java.test.org.apache.zookeeper.test.JMXEnv.JMXEnv.setUp(), false, test_method
src.java.test.org.apache.zookeeper.test.FLEBackwardElectionRoundTest.FLEBackwardElectionRoundTest.testBackwardElectionRound(), false, test_method
src.java.test.org.apache.zookeeper.server.quorum.Zab1_0Test.Zab1_0Test.getSocketPair(), false, test_method
src.java.test.org.apache.zookeeper.server.quorum.Zab1_0Test.Zab1_0Test.testFollowerConversation(FollowerConversation), false, test_method
src.java.test.org.apache.zookeeper.server.quorum.Zab1_0Test.Zab1_0Test.testObserverConversation(ObserverConversation), false, test_method
src.java.test.org.apache.zookeeper.server.quorum.Zab1_0Test.Zab1_0Test.createQuorumPeer(File), true
src.java.test.org.apache.zookeeper.test.CnxManagerTest.CnxManagerTest.setUp(), false, test_method
src.java.test.org.apache.zookeeper.test.FLEPredicateTest.FLEPredicateTest.testPredicate(), false, test_method
#####
zookeeper-3.4.5
ZOOKEEPER-1783
https://issues.apache.org/jira/browse/ZOOKEEPER-1783
Distinguish initial configuration from first established configuration We need a way to distinguish an initial config of a server and an initial config of a running ensemble (before any reconfigs happen). Currently both have version 0. The version of a config increases with each reconfiguration, so the problem is just with the initial config.
Distinguish initial configuration from first established configuration We need a way to distinguish an initial config of a server and an initial config of a running ensemble (before any reconfigs happen). Currently both have version 0. The version of a config increases with each reconfiguration, so the problem is just with the initial config.
******
src.java.test.org.apache.zookeeper.test.ReconfigTest.ReconfigTest.setUp(), false, test_method
src.java.test.org.apache.zookeeper.test.ReconfigTest.ReconfigTest.tearDown(), true
src.java.test.org.apache.zookeeper.test.ReconfigTest.ReconfigTest.testInitialConfigHasPositiveVersion(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.run(), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.setQuorumVerifier(QuorumVerifier, boolean), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.processReconfig(QuorumVerifier, Long, Long, boolean), true
src.java.main.org.apache.zookeeper.server.quorum.Leader.Leader.lead(), true
src.java.test.org.apache.zookeeper.server.quorum.ReconfigRecoveryTest.ReconfigRecoveryTest.testNextConfigCompletion(), false, test_method
src.java.test.org.apache.zookeeper.server.quorum.ReconfigRecoveryTest.ReconfigRecoveryTest.testCurrentServersAreObserversInNextConfig(), false, test_method
src.java.test.org.apache.zookeeper.server.quorum.ReconfigRecoveryTest.ReconfigRecoveryTest.testNextConfigUnreachable(), false, test_method
src.java.test.org.apache.zookeeper.server.quorum.ReconfigRecoveryTest.ReconfigRecoveryTest.testNextConfigAlreadyActive(), false, test_method
src.java.test.org.apache.zookeeper.server.quorum.Zab1_0Test.Zab1_0Test.converseWithFollower(InputArchive, OutputArchive, Follower), false, test_method
src.java.test.org.apache.zookeeper.server.quorum.Zab1_0Test.Zab1_0Test.prepareLeader(File, QuorumPeer), true
src.java.main.org.apache.zookeeper.server.quorum.FastLeaderElection.FastLeaderElection.run(), true
#####
zookeeper-3.4.5
ZOOKEEPER-1778
https://issues.apache.org/jira/browse/ZOOKEEPER-1778
Use static final Logger objects Logger is not declared as 'private static final' in few classes
Use static final Logger objects Logger is not declared as 'private static final' in few classes
******
src.java.main.org.apache.zookeeper.server.ZooTrace.ZooTrace.setTextTraceLevel(long), false, refactoring
#####
zookeeper-3.4.5
ZOOKEEPER-1769
https://issues.apache.org/jira/browse/ZOOKEEPER-1769
ZooInspector can't display node data/metadata/ACLs There seem to be a few bugs in the trunk that prevent ZooInspector to load the node viewers ( the 3 tabs in the main windows when you select a ZK node in the tree don't show up any more ). Apparently it has been introduced 2 years ago after a refactoring about icons and another about partially fixing a typo ("veiwer" -> "viewer"). Note: the bug is only in trunk, 3.4 is fine.
can't display node  There seem to be a few bugs in the trunk that prevent to load the node viewers ( the 3 tabs in the main windows when you select a ZK node in the tree don't show up any more ). Apparently it has been introduced 2 years ago after a refactoring about icons and another about partially fixing a typo ("veiwer" -> "viewer"). Note: the bug is only in trunk, 3.4 is fine.
******
src.contrib.zooinspector.src.java.org.apache.zookeeper.inspector.ZooInspector.ZooInspector.main(String[]), true
src.contrib.zooinspector.src.java.org.apache.zookeeper.inspector.gui.nodeviewer.NodeViewerData.NodeViewerData.NodeViewerData(IconResource), true
#####
zookeeper-3.4.5
ZOOKEEPER-1766
https://issues.apache.org/jira/browse/ZOOKEEPER-1766
Consistent log severity level guards and statements A log statement should be guarded by its matching severity level. A log statement like if (LOG.isTraceEnabled()) { LOG.info("Session closing: 0x" + Long.toHexString(sessionId)); doesn't make much sense because the log message is only printed out when TRACE-level is enabled. This inconsistency was possibly introduced when developers demoted the original log statement from INFO but forgot to change its corresponding log severity level.
Consistent log severity level guards and statements A log statement should be guarded by its matching severity level. A log statement like doesn't make much sense because the log message is only printed out when TRACE-level is enabled. This inconsistency was possibly introduced when developers demoted the original log statement from INFO but forgot to change its corresponding log severity level.
******
src.java.main.org.apache.zookeeper.server.SessionTrackerImpl.SessionTrackerImpl.setSessionClosing(long), true
src.java.systest.org.apache.zookeeper.test.system.QuorumPeerInstance.QuorumPeerInstance.configure(String), false, test_method
#####
zookeeper-3.4.5
ZOOKEEPER-1759
https://issues.apache.org/jira/browse/ZOOKEEPER-1759
Adding ability to allow READ operations for authenticated users,  versus keeping ACLs wide open for READ Today when using SASLAuthenticationProvider to authenticate Zookeeper Clients access to the data based on ACLS set on znodes there is no other choice but to set READ ACLs to be "world", "anyone" with the way how public boolean matches(String id,String aclExpr) is currently implemented. It means that any unauthenticated user can read the data when application needs to make sure that not only creator of a znode can read the content. Proposal is to introduce new property: "zookeeper.readUser" that if incoming id matches to the value of that property it will be allowed to proceed in "match" method. So creator of a znode instead of ACL acl1 = new ACL(Perms.ADMIN | Perms.CREATE | Perms.WRITE | Perms.DELETE, Ids.AUTH_IDS); ACL acl2 = new ACL(Perms.READ, Ids.ANYONE_ID_UNSAFE); will need to do ACL acl1 = new ACL(Perms.ADMIN | Perms.CREATE | Perms.WRITE | Perms.DELETE, Ids.AUTH_IDS); ACL acl2 = new ACL(Perms.READ, new Id("sasl", "anyone")); Assuming that value of "zookeeper.readUser" property was "anyone". This way at least READ access on corresponding znode has to be authenticated.
Adding ability to allow READ operations for authenticated users, versus keeping ACLs wide open for READ Today when using to authenticate Zookeeper Clients access to the data based on ACLS set on znodes there is no other choice but to set READ ACLs to be "world", "anyone" with the way how is currently implemented. It means that any unauthenticated user can read the data when application needs to make sure that not only creator of a znode can read the content. Proposal is to introduce new property:  that if incoming id matches to the value of that property it will be allowed to proceed in "match" method. So creator of a znode instead of will need to do Assuming that value of property was "anyone". This way at least READ access on corresponding znode has to be authenticated.
******
src.java.main.org.apache.zookeeper.server.auth.SASLAuthenticationProvider.SASLAuthenticationProvider.matches(String, String), true
src.java.test.org.apache.zookeeper.test.SaslAuthDesignatedClientTest.SaslAuthDesignatedClientTest.testReadAccessUser(), false, new_method
#####
zookeeper-3.4.5
ZOOKEEPER-1718
https://issues.apache.org/jira/browse/ZOOKEEPER-1718
Support JLine 2 not fixed
Support JLine 2 not fixed
******
src.java.main.org.apache.zookeeper.JLineZNodeCompletor.JLineZNodeCompletor.JLineZNodeCompletor(ZooKeeper), false, method_signature
src.java.main.org.apache.zookeeper.ZooKeeperMain.ZooKeeperMain.run(), false, refactoring
#####
zookeeper-3.4.5
ZOOKEEPER-1700
https://issues.apache.org/jira/browse/ZOOKEEPER-1700
FLETest consistently failing - setLastSeenQuorumVerifier seems to be hanging I'm consistently seeing a failure on my laptop when running the FLETest "testJoin" test. What seems to be happening is that the call to setLastSeenQuorumVerifier is hanging. See the following log from the test, notice 17:35:57 for the period in question. Note that I turned on debug logging and added a few log messages around the call to setLastSeenQuorumVerifier (you can see the code enter but never leave) Note: I've applied ZOOKEEPER-1324 to trunk code and then run this test but that doesn't seem to help. Also note that this test is passing consistently when run against branch-3.4. 2013-05-07 17:35:57,859 [myid:] - INFO [QuorumPeer[myid=0]/0:0:0:0:0:0:0:0:11221:Follower@65] - FOLLOWING - LEADER ELECTION TOOK - 16 2013-05-07 17:35:57,859 [myid:] - INFO [QuorumPeer[myid=1]/0:0:0:0:0:0:0:0:11224:Leader@436] - LEADING - LEADER ELECTION TOOK - 17 2013-05-07 17:35:57,863 [myid:] - INFO [QuorumPeer[myid=1]/0:0:0:0:0:0:0:0:11224:FileTxnSnapLog@270] - Snapshotting: 0x0 to /home/phunt/dev/zookeeper-trunk/build/test/tmp/test3690487600947307322.junit.dir/version-2/snapshot.0 2013-05-07 17:35:57,873 [myid:] - INFO [LearnerHandler-/127.0.0.1:34262:LearnerHandler@269] - Follower sid: 0 : info : 0.0.0.0:11222:11223:participant;0.0.0.0:11221 2013-05-07 17:35:57,878 [myid:] - INFO [LearnerHandler-/127.0.0.1:34262:LearnerHandler@328] - Synchronizing with Follower sid: 0 maxCommittedLog=0x0 minCommittedLog=0x0 peerLastZxid=0x0 2013-05-07 17:35:57,878 [myid:] - DEBUG [LearnerHandler-/127.0.0.1:34262:LearnerHandler@395] - committedLog is empty but leader and follower are in sync, zxid=0x0 2013-05-07 17:35:57,878 [myid:] - INFO [LearnerHandler-/127.0.0.1:34262:LearnerHandler@404] - Sending DIFF 2013-05-07 17:35:57,879 [myid:] - DEBUG [LearnerHandler-/127.0.0.1:34262:LearnerHandler@411] - Sending NEWLEADER message to 0 2013-05-07 17:35:57,880 [myid:] - INFO [QuorumPeer[myid=0]/0:0:0:0:0:0:0:0:11221:Learner@331] - Getting a diff from the leader 0x0 2013-05-07 17:35:57,885 [myid:] - INFO [QuorumPeer[myid=0]/0:0:0:0:0:0:0:0:11221:Learner@457] - Learner received NEWLEADER message 2013-05-07 17:35:57,885 [myid:] - INFO [QuorumPeer[myid=0]/0:0:0:0:0:0:0:0:11221:Learner@460] - NEWLEADER calling configfromstring 2013-05-07 17:35:57,885 [myid:] - INFO [QuorumPeer[myid=0]/0:0:0:0:0:0:0:0:11221:Learner@462] - NEWLEADER setting quorum verifier 2013-05-07 17:35:57,886 [myid:] - WARN [QuorumPeer[myid=0]/0:0:0:0:0:0:0:0:11221:QuorumPeer@1218] - setLastSeenQuorumVerifier called with stale config 0. Current version: 0 2013-05-07 17:36:01,880 [myid:] - INFO [QuorumPeer[myid=1]/0:0:0:0:0:0:0:0:11224:Leader@585] - Shutting down 2013-05-07 17:36:01,881 [myid:] - INFO [QuorumPeer[myid=1]/0:0:0:0:0:0:0:0:11224:Leader@591] - Shutdown called java.lang.Exception: shutdown Leader! reason: Waiting for a quorum of followers, only synced with sids: [ [1] ] at org.apache.zookeeper.server.quorum.Leader.shutdown(Leader.java:591) at org.apache.zookeeper.server.quorum.Leader.lead(Leader.java:487) at org.apache.zookeeper.server.quorum.QuorumPeer.run(QuorumPeer.java:949) 2013-05-07 17:36:01,881 [myid:] - INFO [QuorumPeer[myid=1]/0:0:0:0:0:0:0:0:11224:ZooKeeperServer@398] - shutting down 2013-05-07 17:36:01,881 [myid:] - INFO [LearnerCnxAcceptor-0.0.0.0/0.0.0.0:11225:Leader$LearnerCnxAcceptor@398] - exception while shutting down acceptor: java.net.SocketException: Socket closed 2013-05-07 17:36:01,882 [myid:] - WARN [QuorumPeer[myid=1]/0:0:0:0:0:0:0:0:11224:QuorumPeer@979] - PeerState set to LOOKING 2013-05-07 17:36:01,882 [myid:] - INFO [QuorumPeer[myid=1]/0:0:0:0:0:0:0:0:11224:QuorumPeer@863] - LOOKING 2013-05-07 17:36:01,883 [myid:] - DEBUG [QuorumPeer[myid=1]/0:0:0:0:0:0:0:0:11224:QuorumPeer@792] - Initializing leader election protocol...
consistently failing - seems to be hanging I'm consistently seeing a failure on my laptop when running the test. What seems to be happening is that the call to is hanging. See the following log from the test, notice 17:35:57 for the period in question. Note that I turned on debug logging and added a few log messages around the call to (you can see the code enter but never leave) Note: I've applied ZOOKEEPER-1324 to trunk code and then run this test but that doesn't seem to help. Also note that this test is passing consistently when run against branch-3.4.
******
src.java.test.org.apache.zookeeper.test.FLETest.FLETest.run(), false, test_method
src.java.test.org.apache.zookeeper.test.FLETest.FLETest.runElection(int), true
src.java.test.org.apache.zookeeper.test.FLETest.FLETest.testJoin(), false, test_method
#####
zookeeper-3.4.5
ZOOKEEPER-1691
https://issues.apache.org/jira/browse/ZOOKEEPER-1691
Add a flag to disable standalone mode Currently you cannot use dynamic reconfiguration to bootstrap zookeeper cluster because the server goes into standalone mode when there is only one server in the cluster. --Michi
Add a flag to disable standalone mode Currently you cannot use dynamic reconfiguration to bootstrap zookeeper cluster because the server goes into standalone mode when there is only one server in the cluster. --Michi
******
src.java.test.org.apache.zookeeper.test.ReconfigTest.ReconfigTest.reconfig(ZooKeeper, List<String>, List<String>, List<String>, long), false, test_method
src.java.test.org.apache.zookeeper.test.StandaloneTest.StandaloneTest.testStandaloneQuorum(), false, test_method
src.java.main.org.apache.zookeeper.server.quorum.FollowerZooKeeperServer.FollowerZooKeeperServer.getGlobalOutstandingLimit(), true
src.java.main.org.apache.zookeeper.server.quorum.LeaderZooKeeperServer.LeaderZooKeeperServer.getGlobalOutstandingLimit(), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.QuorumPeerConfig.configFromString(String), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.QuorumPeerConfig.parse(String), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.QuorumPeerConfig.parseProperties(Properties), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.QuorumPeerConfig.createQuorumVerifier(Properties, boolean), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.QuorumPeerConfig.parseDynamicConfig(Properties, int, boolean), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.QuorumPeerConfig.checkValidity(), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.QuorumPeerConfig.isDistributed(), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.QuorumPeerConfig.isStandaloneEnabled(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.QuorumPeerConfig.setStandaloneEnabled(boolean), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.StandaloneDisabledTest.StandaloneDisabledTest.startSingleServerTest(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.StandaloneDisabledTest.StandaloneDisabledTest.setUpData(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.StandaloneDisabledTest.StandaloneDisabledTest.shutDownData(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.StandaloneDisabledTest.StandaloneDisabledTest.buildServerStrings(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.StandaloneDisabledTest.StandaloneDisabledTest.startServer(int, String), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.StandaloneDisabledTest.StandaloneDisabledTest.shutDownServer(int), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.StandaloneDisabledTest.StandaloneDisabledTest.startFollowers(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.StandaloneDisabledTest.StandaloneDisabledTest.startObservers(ArrayList<String>), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.StandaloneDisabledTest.StandaloneDisabledTest.testReconfig(int, boolean, ArrayList<String>), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.StandaloneDisabledTest.StandaloneDisabledTest.startObserver(), false, new_method
src.java.main.org.apache.zookeeper.cli.ReconfigCommand.ReconfigCommand.parse(String[]), true
src.java.test.org.apache.zookeeper.server.quorum.QuorumPeerTestBase.QuorumPeerTestBase.isQuorumPeerRunning(), false, new_method
src.java.main.org.apache.zookeeper.server.PrepRequestProcessor.PrepRequestProcessor.pRequest2Txn(int, long, Request, Record, boolean), true
#####
zookeeper-3.4.5
ZOOKEEPER-1664
https://issues.apache.org/jira/browse/ZOOKEEPER-1664
Kerberos auth doesn't work with native platform GSS integration Java on Linux/Solaris can be set up to use the native (via C library) GSS implementation. This is configured by setting the system property sun.security.jgss.native=true When using this feature, ZooKeeper Sasl/JGSS authentication doesn't work. The reason is explained in http://docs.oracle.com/javase/6/docs/technotes/guides/security/jgss/jgss-features.html """ [when using native GSS...] In addition, when performing operations as a particular Subject, e.g. Subject.doAs(...) or Subject.doAsPrivileged(...), the to-be-used GSSCredential should be added to Subject's private credential set. Otherwise, the GSS operations will fail since no credential is found. """
Kerberos auth doesn't work with native platform GSS integration Java on Linux/Solaris can be set up to use the native (via C library) GSS implementation. This is configured by setting the system property When using this feature, ZooKeeper authentication doesn't work. The reason is explained in http://docs.oracle.com/javase/6/docs/technotes/guides/security/jgss/jgss-features.html """ [when using native GSS...] In addition, when performing operations as a particular Subject, the to-be-used should be added to Subject's private credential set. Otherwise, the GSS operations will fail since no credential is found. """
******
src.java.main.org.apache.zookeeper.server.ZooKeeperSaslServer.ZooKeeperSaslServer.createSaslServer(Login), true
src.java.main.org.apache.zookeeper.client.ZooKeeperSaslClient.ZooKeeperSaslClient.createSaslClient(String, String), true
#####
zookeeper-3.4.5
ZOOKEEPER-1628
https://issues.apache.org/jira/browse/ZOOKEEPER-1628
Documented list of allowable characters in ZK doc not in line with code The documented set of allowable characters in ZooKeeper node names in the Programmer's Guide is not entirely in line with the code. The range of non-printable ASCII characters in the doc ends too early (i.e. 0x19 instead of 0x1F). The range checking code in PathUtils also includes off-by-one errors, so that characters that are on the border of being unallowable are actually allowed by the code.
Documented list of allowable characters in ZK doc not in line with code The documented set of allowable characters in ZooKeeper node names in the Programmer's Guide is not entirely in line with the code. The range of non-printable ASCII characters in the doc ends too early (i.e. 0x19 instead of 0x1F). The range checking code in also includes off-by-one errors, so that characters that are on the border of being unallowable are actually allowed by the code.
******
src.java.test.org.apache.zookeeper.common.PathUtilsTest.PathUtilsTest.testValidatePath_ValidPath(), false, new_method
src.java.test.org.apache.zookeeper.common.PathUtilsTest.PathUtilsTest.testValidatePath_Null(), false, new_method
src.java.test.org.apache.zookeeper.common.PathUtilsTest.PathUtilsTest.testValidatePath_EmptyString(), false, new_method
src.java.test.org.apache.zookeeper.common.PathUtilsTest.PathUtilsTest.testValidatePath_NotAbsolutePath(), false, new_method
src.java.test.org.apache.zookeeper.common.PathUtilsTest.PathUtilsTest.testValidatePath_EndsWithSlash(), false, new_method
src.java.test.org.apache.zookeeper.common.PathUtilsTest.PathUtilsTest.testValidatePath_ContainsNullCharacter(), false, new_method
src.java.test.org.apache.zookeeper.common.PathUtilsTest.PathUtilsTest.testValidatePath_DoubleSlash(), false, new_method
src.java.test.org.apache.zookeeper.common.PathUtilsTest.PathUtilsTest.testValidatePath_SinglePeriod(), false, new_method
src.java.test.org.apache.zookeeper.common.PathUtilsTest.PathUtilsTest.testValidatePath_DoublePeriod(), false, new_method
src.java.test.org.apache.zookeeper.common.PathUtilsTest.PathUtilsTest.testValidatePath_NameContainingPeriod(), false, new_method
src.java.test.org.apache.zookeeper.common.PathUtilsTest.PathUtilsTest.testValidatePath_0x01(), false, new_method
src.java.test.org.apache.zookeeper.common.PathUtilsTest.PathUtilsTest.testValidatePath_0x1F(), false, new_method
src.java.test.org.apache.zookeeper.common.PathUtilsTest.PathUtilsTest.testValidatePath_0x20(), false, new_method
src.java.test.org.apache.zookeeper.common.PathUtilsTest.PathUtilsTest.testValidatePath_0x7e(), false, new_method
src.java.test.org.apache.zookeeper.common.PathUtilsTest.PathUtilsTest.testValidatePath_0x7f(), false, new_method
src.java.test.org.apache.zookeeper.common.PathUtilsTest.PathUtilsTest.testValidatePath_0x9f(), false, new_method
src.java.test.org.apache.zookeeper.common.PathUtilsTest.PathUtilsTest.testValidatePath_ud800(), false, new_method
src.java.test.org.apache.zookeeper.common.PathUtilsTest.PathUtilsTest.testValidatePath_uf8ff(), false, new_method
src.java.test.org.apache.zookeeper.common.PathUtilsTest.PathUtilsTest.testValidatePath_HighestAllowableChar(), false, new_method
src.java.test.org.apache.zookeeper.common.PathUtilsTest.PathUtilsTest.testValidatePath_SupplementaryChar(), false, new_method
src.java.main.org.apache.zookeeper.common.PathUtils.PathUtils.validatePath(String), true
#####
zookeeper-3.4.5
ZOOKEEPER-1620
https://issues.apache.org/jira/browse/ZOOKEEPER-1620
NIOServerCnxnFactory (new code introduced in ZK-1504) opens selectors but never closes them New code (committed in ZK-1504) opens selectors but doesn't close them. Specifically AbstractSelectThread in its constructor does this.selector = Selector.open(); But possibly also elsewhere. Tests fail for me with the following message: java.io.IOException: Too many open files at sun.nio.ch.EPollArrayWrapper.epollCreate(Native Method) at sun.nio.ch.EPollArrayWrapper.<init>(EPollArrayWrapper.java:69) at sun.nio.ch.EPollSelectorImpl.<init>(EPollSelectorImpl.java:52) at sun.nio.ch.EPollSelectorProvider.openSelector(EPollSelectorProvider.java:18) at java.nio.channels.Selector.open(Selector.java:209) at org.apache.zookeeper.server.NIOServerCnxnFactory$AbstractSelectThread.<init>(NIOServerCnxnFactory.java:128) at org.apache.zookeeper.server.NIOServerCnxnFactory$AcceptThread.<init>(NIOServerCnxnFactory.java:177) at org.apache.zookeeper.server.NIOServerCnxnFactory.configure(NIOServerCnxnFactory.java:663) at org.apache.zookeeper.server.ServerCnxnFactory.createFactory(ServerCnxnFactory.java:127) at org.apache.zookeeper.server.quorum.QuorumPeer.<init>(QuorumPeer.java:709) at org.apache.zookeeper.test.QuorumBase.startServers(QuorumBase.java:177) at org.apache.zookeeper.test.QuorumBase.setUp(QuorumBase.java:113) at org.apache.zookeeper.test.QuorumBase.setUp(QuorumBase.java:71) at org.apache.zookeeper.test.ReconfigTest.setUp(ReconfigTest.java:56)
(new code introduced in ZK-1504) opens selectors but never closes them New code (committed in ZK-1504) opens selectors but doesn't close them. Specifically in its constructor does this But possibly also elsewhere. Tests fail for me with the following message:
******
src.java.main.org.apache.zookeeper.server.NIOServerCnxnFactory.NIOServerCnxnFactory.closeSelector(), true
src.java.main.org.apache.zookeeper.server.NIOServerCnxnFactory.NIOServerCnxnFactory.run(), true
src.java.test.org.apache.zookeeper.test.NIOConnectionFactoryFdLeakTest.NIOConnectionFactoryFdLeakTest.testFileDescriptorLeak(), false, new_method
#####
zookeeper-3.4.5
ZOOKEEPER-1619
https://issues.apache.org/jira/browse/ZOOKEEPER-1619
Allow spaces in URL Currently, spaces are not allowed in the url. This format will work. 10.10.1.1:2181,10.10.1.2:2181/usergrid This format will not (notice the spaces around the comma) 10.10.1.1:2181 , 10.10.1.2:2181/usergrid Please add a trim to both the port and the hostname parsing.
Allow spaces in URL Currently, spaces are not allowed in the url. This format will work. This format will not (notice the spaces around the comma)Please add a trim to both the port and the hostname parsing.
******
src.java.main.org.apache.zookeeper.common.StringUtils.StringUtils.split(String, String), false, new_method
src.java.test.org.apache.zookeeper.test.StringUtilTest.StringUtilTest.testStrings(), false, new_method
src.java.main.org.apache.zookeeper.client.ConnectStringParser.ConnectStringParser.ConnectStringParser(String), true
#####
zookeeper-3.4.5
ZOOKEEPER-1602
https://issues.apache.org/jira/browse/ZOOKEEPER-1602
a change to QuorumPeerConfig's API broke compatibility with HBase The following patch broke an API that's in use by HBase. Otherwise current trunk compiles fine when used by hbase: ZOOKEEPER-1411. Consolidate membership management, distinguish between static and dynamic configuration parameters (Alex Shraer via breed) Considering it a blocker even though it's not really a "public" API. If possible we should add back "getServers" method on QuorumPeerConfig to reduce friction for the hbase team.
a change to API broke compatibility with HBase The following patch broke an API that's in use by HBase. Otherwise current trunk compiles fine when used by hbase: ZOOKEEPER-1411. Consolidate membership management, distinguish between static and dynamic configuration parameters (Alex Shraer via breed) Considering it a blocker even though it's not really a "public" API. If possible we should add back method on to reduce friction for the hbase team.
******
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.QuorumPeerConfig.getServers(), false, new_method
#####
zookeeper-3.4.5
ZOOKEEPER-1572
https://issues.apache.org/jira/browse/ZOOKEEPER-1572
Add an async interface for multi request Currently there is no async interface for multi request in ZooKeeper java client.
Add an async interface for multi request Currently there is no async interface for multi request in ZooKeeper java client.
******
src.java.test.org.apache.zookeeper.test.MultiTransactionTest.MultiTransactionTest.MultiTransactionTest(boolean), false, new_method
src.java.test.org.apache.zookeeper.test.MultiTransactionTest.MultiTransactionTest.configs(), false, new_method
src.java.test.org.apache.zookeeper.test.MultiTransactionTest.MultiTransactionTest.multi(ZooKeeper, Iterable<Op>), false, new_method
src.java.test.org.apache.zookeeper.test.MultiTransactionTest.MultiTransactionTest.commit(Transaction), false, new_method
src.java.test.org.apache.zookeeper.test.MultiTransactionTest.MultiTransactionTest.testChRootCreateDelete(), false, test_method
src.java.test.org.apache.zookeeper.test.MultiTransactionTest.MultiTransactionTest.testChRootSetData(), false, test_method
src.java.test.org.apache.zookeeper.test.MultiTransactionTest.MultiTransactionTest.testChRootCheck(), false, test_method
src.java.test.org.apache.zookeeper.test.MultiTransactionTest.MultiTransactionTest.testChRootTransaction(), false, test_method
src.java.test.org.apache.zookeeper.test.MultiTransactionTest.MultiTransactionTest.createNameSpace(), true
src.java.test.org.apache.zookeeper.test.MultiTransactionTest.MultiTransactionTest.testCreate(), false, test_method
src.java.test.org.apache.zookeeper.test.MultiTransactionTest.MultiTransactionTest.testCreateDelete(), false, test_method
src.java.test.org.apache.zookeeper.test.MultiTransactionTest.MultiTransactionTest.testInvalidVersion(), false, test_method
src.java.test.org.apache.zookeeper.test.MultiTransactionTest.MultiTransactionTest.testNestedCreate(), false, test_method
src.java.test.org.apache.zookeeper.test.MultiTransactionTest.MultiTransactionTest.testSetData(), false, test_method
src.java.test.org.apache.zookeeper.test.MultiTransactionTest.MultiTransactionTest.testUpdateConflict(), false, test_method
src.java.test.org.apache.zookeeper.test.MultiTransactionTest.MultiTransactionTest.testDeleteUpdateConflict(), false, test_method
src.java.test.org.apache.zookeeper.test.MultiTransactionTest.MultiTransactionTest.testGetResults(), false, test_method
src.java.test.org.apache.zookeeper.test.MultiTransactionTest.MultiTransactionTest.opEquals(OpResult, OpResult, OpResult), true
src.java.test.org.apache.zookeeper.test.MultiTransactionTest.MultiTransactionTest.testWatchesTriggered(), false, test_method
src.java.test.org.apache.zookeeper.test.MultiTransactionTest.MultiTransactionTest.testNoWatchesTriggeredForFailedMultiRequest(), false, test_method
src.java.test.org.apache.zookeeper.test.MultiTransactionTest.MultiTransactionTest.testTransactionBuilder(), false, test_method
src.java.main.org.apache.zookeeper.ClientCnxn.ClientCnxn.processEvent(Object), true
src.java.main.org.apache.zookeeper.Transaction.Transaction.commit(MultiCallback, Object), false, new_method
src.java.main.org.apache.zookeeper.ZooKeeper.ZooKeeper.multi(Iterable<Op>), true
src.java.main.org.apache.zookeeper.ZooKeeper.ZooKeeper.multiInternal(MultiTransactionRecord, MultiCallback, Object), false, new_method
#####
zookeeper-3.4.5
ZOOKEEPER-1505
https://issues.apache.org/jira/browse/ZOOKEEPER-1505
Multi-thread CommitProcessor CommitProcessor has a single thread that both pulls requests off its queues and runs all downstream processors. This is noticeably inefficient for read-intensive workloads, which could be run concurrently. The trick is handling write transactions. I propose multi-threading this code according to the following two constraints each session must see its requests responded to in order all committed transactions must be handled in zxid order, across all sessions I believe these cover the only constraints we need to honor. In particular, I believe we can relax the following: it does not matter if the read request in one session happens before or after the write request in another session With these constraints, I propose the following threads 1 primary queue servicing/work dispatching thread 0-N assignable worker threads, where a given session is always assigned to the same worker thread By assigning sessions always to the same worker thread (using a simple sessionId mod number of worker threads), we guarantee the first constraint-- requests we push onto the thread queue are processed in order. The way we guarantee the second constraint is we only allow a single commit transaction to be in flight at a time--the queue servicing thread blocks while a commit transaction is in flight, and when the transaction completes it clears the flag. On a 32 core machine running Linux 2.6.38, achieved best performance with 32 worker threads for a 56% +/- 5% improvement in throughput (this improvement was measured on top of that for ZOOKEEPER-1504, not in isolation). New classes introduced in this patch are: WorkerService (also in ZOOKEEPER-1504): ExecutorService wrapper that makes worker threads daemon threads and names then in an easily debuggable manner. Supports assignable threads (as used here) and non-assignable threads (as used by NIOServerCnxnFactory).
Multi-thread has a single thread that both pulls requests off its queues and runs all downstream processors. This is noticeably inefficient for read-intensive workloads, which could be run concurrently. The trick is handling write transactions. I propose multi-threading this code according to the following two constraints each session must see its requests responded to in order all committed transactions must be handled in order, across all sessions I believe these cover the only constraints we need to honor. In particular, I believe we can relax the following: it does not matter if the read request in one session happens before or after the write request in another session With these constraints, I propose the following threads 1 primary queue servicing/work dispatching thread 0-N assignable worker threads, where a given session is always assigned to the same worker thread By assigning sessions always to the same worker thread (using a simple sessionId mod number of worker threads), we guarantee the first constraint-- requests we push onto the thread queue are processed in order. The way we guarantee the second constraint is we only allow a single commit transaction to be in flight at a time--the queue servicing thread blocks while a commit transaction is in flight, and when the transaction completes it clears the flag. On a 32 core machine running Linux 2.6.38, achieved best performance with 32 worker threads for a 56% +/- 5% improvement in throughput (this improvement was measured on top of that for ZOOKEEPER-1504, not in isolation). New classes introduced in this patch are: (also in ZOOKEEPER-1504):  wrapper that makes worker threads daemon threads and names then in an easily debuggable manner. Supports assignable threads (as used here) and non-assignable threads (as used by.
******
src.java.test.org.apache.zookeeper.server.quorum.CommitProcessorTest.CommitProcessorTest.setUp(int, int), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.CommitProcessorTest.CommitProcessorTest.tearDown(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.CommitProcessorTest.CommitProcessorTest.TestClientThread(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.CommitProcessorTest.CommitProcessorTest.sendWriteRequest(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.CommitProcessorTest.CommitProcessorTest.sendReadRequest(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.CommitProcessorTest.CommitProcessorTest.run(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.CommitProcessorTest.CommitProcessorTest.testNoCommitWorkers(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.CommitProcessorTest.CommitProcessorTest.testOneCommitWorker(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.CommitProcessorTest.CommitProcessorTest.testManyCommitWorkers(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.CommitProcessorTest.CommitProcessorTest.checkProcessedRequest(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.CommitProcessorTest.CommitProcessorTest.failTest(String), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.CommitProcessorTest.CommitProcessorTest.TestZooKeeperServer(File, File, int), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.CommitProcessorTest.CommitProcessorTest.getSessionTracker(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.CommitProcessorTest.CommitProcessorTest.setupRequestProcessors(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.CommitProcessorTest.CommitProcessorTest.MockProposalRequestProcessor(CommitProcessor), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.CommitProcessorTest.CommitProcessorTest.processRequest(Request), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.CommitProcessorTest.CommitProcessorTest.shutdown(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.CommitProcessorTest.CommitProcessorTest.ValidateProcessor(RequestProcessor), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.CommitProcessorTest.CommitProcessorTest.setCommitProcessor(CommitProcessor), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.CommitProcessorTest.CommitProcessorTest.processRequest(Request), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.CommitProcessorTest.CommitProcessorTest.validateWriteRequestVariant(Request), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.CommitProcessorTest.CommitProcessorTest.validateReadRequestVariant(Request), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.CommitProcessorTest.CommitProcessorTest.validateRequest(Request), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.Leader.Leader.processRequest(Request), true
src.java.main.org.apache.zookeeper.server.FinalRequestProcessor.FinalRequestProcessor.processRequest(Request), true
src.java.main.org.apache.zookeeper.server.quorum.CommitProcessor.CommitProcessor.isProcessingRequest(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.CommitProcessor.CommitProcessor.isWaitingForCommit(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.CommitProcessor.CommitProcessor.isProcessingCommit(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.CommitProcessor.CommitProcessor.needCommit(Request), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.CommitProcessor.CommitProcessor.run(), true
src.java.main.org.apache.zookeeper.server.quorum.CommitProcessor.CommitProcessor.commit(Request), true
src.java.main.org.apache.zookeeper.server.quorum.CommitProcessor.CommitProcessor.processRequest(Request), true
src.java.main.org.apache.zookeeper.server.quorum.CommitProcessor.CommitProcessor.shutdown(), true
src.java.main.org.apache.zookeeper.server.quorum.CommitProcessor.CommitProcessor.halt(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.CommitProcessor.CommitProcessor.wakeup(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.CommitProcessor.CommitProcessor.doWork(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.CommitProcessor.CommitProcessor.cleanup(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.CommitProcessor.CommitProcessor.sendToNextProcessor(Request), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.CommitProcessor.CommitProcessor.start(), false, new_method
src.java.main.org.apache.zookeeper.server.WorkerService.WorkerService.WorkerService(String, int, boolean), false, new_method
src.java.main.org.apache.zookeeper.server.WorkerService.WorkerService.doWork(), false, new_method
src.java.main.org.apache.zookeeper.server.WorkerService.WorkerService.cleanup(), false, new_method
src.java.main.org.apache.zookeeper.server.WorkerService.WorkerService.schedule(WorkRequest), false, new_method
src.java.main.org.apache.zookeeper.server.WorkerService.WorkerService.schedule(WorkRequest, long), false, new_method
src.java.main.org.apache.zookeeper.server.WorkerService.WorkerService.run(), false, new_method
src.java.main.org.apache.zookeeper.server.WorkerService.WorkerService.DaemonThreadFactory(String), false, new_method
src.java.main.org.apache.zookeeper.server.WorkerService.WorkerService.ScheduledWorkRequest(WorkRequest), false, new_method
src.java.main.org.apache.zookeeper.server.WorkerService.WorkerService.DaemonThreadFactory(String, int), false, new_method
src.java.main.org.apache.zookeeper.server.WorkerService.WorkerService.newThread(Runnable), false, new_method
src.java.main.org.apache.zookeeper.server.WorkerService.WorkerService.start(), false, new_method
src.java.main.org.apache.zookeeper.server.WorkerService.WorkerService.stop(), false, new_method
src.java.main.org.apache.zookeeper.server.WorkerService.WorkerService.join(long), false, new_method
#####
zookeeper-3.4.5
ZOOKEEPER-1499
https://issues.apache.org/jira/browse/ZOOKEEPER-1499
clientPort config changes not backwards-compatible With the new reconfig logic, clientPort=2181 in the zoo.cfg file no longer gets read, and clients can't connect without adding ;2181 to the end of their server lines.
config changes not backwards-compatible With the new reconfig logic, =2181 in the file no longer gets read, and clients can't connect without adding ;2181 to the end of their server lines.
******
src.java.test.org.apache.zookeeper.test.ReconfigTest.ReconfigTest.testUnspecifiedClientAddress(), false, new_method
src.java.test.org.apache.zookeeper.test.ReconfigTest.ReconfigTest.testQuorumSystemChange(), false, test_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.QuorumServer(long, String), true
#####
zookeeper-3.4.5
ZOOKEEPER-1413
https://issues.apache.org/jira/browse/ZOOKEEPER-1413
Use on-disk transaction log for learner sync up Motivation: The learner syncs up with leader by retrieving committed log from the leader. Currently, the leader only keeps 500 entries of recently committed log in memory. If the learner falls behind more than 500 updates, the leader will send the entire snapshot to the learner. With the size of the snapshot for some of our Zookeeper deployments (~10G), it is prohibitively expensive to send the entire snapshot over network. Additionally, our Zookeeper may serve more than 4K updates per seconds. As a result, a network hiccups for less than a second will cause the learner to use snapshot transfer. Design: Instead of looking only at committed log in memory, the leader will also look at transaction log on disk. The amount of transaction log kept on disk is configurable and the current default is 100k. This will allow Zookeeper to tolerate longer temporal network failure before initiating the snapshot transfer. Implementation: We plan to add interface to the persistence layer will can be use to retrieve proposals from on-disk transaction log. These proposals can then be used to send to the learner using existing protocol.
Use on-disk transaction log for learner sync up Motivation: The learner syncs up with leader by retrieving committed log from the leader. Currently, the leader only keeps 500 entries of recently committed log in memory. If the learner falls behind more than 500 updates, the leader will send the entire snapshot to the learner. With the size of the snapshot for some of our Zookeeper deployments (~10G), it is prohibitively expensive to send the entire snapshot over network. Additionally, our Zookeeper may serve more than 4K updates per seconds. As a result, a network hiccups for less than a second will cause the learner to use snapshot transfer. Design: Instead of looking only at committed log in memory, the leader will also look at transaction log on disk. The amount of transaction log kept on disk is configurable and the current default is 100k. This will allow Zookeeper to tolerate longer temporal network failure before initiating the snapshot transfer. Implementation: We plan to add interface to the persistence layer will can be use to retrieve proposals from on-disk transaction log. These proposals can then be used to send to the learner using existing protocol.
******
src.java.main.org.apache.zookeeper.server.persistence.FileTxnSnapLog.FileTxnSnapLog.readTxnLog(long), false, new_method
src.java.main.org.apache.zookeeper.server.persistence.FileTxnSnapLog.FileTxnSnapLog.readTxnLog(long, boolean), false, new_method
src.java.main.org.apache.zookeeper.server.persistence.FileTxnLog.FileTxnLog.read(long), true
src.java.main.org.apache.zookeeper.server.persistence.FileTxnLog.FileTxnLog.read(long, boolean), false, new_method
src.java.main.org.apache.zookeeper.server.persistence.FileTxnLog.FileTxnLog.FileTxnIterator(File, long), true
src.java.main.org.apache.zookeeper.server.persistence.FileTxnLog.FileTxnLog.init(), true
src.java.main.org.apache.zookeeper.server.persistence.FileTxnLog.FileTxnLog.getStorageSize(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.LearnerHandlerTest.LearnerHandlerTest.MockLearnerHandler(Socket, Leader), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.LearnerHandlerTest.LearnerHandlerTest.startSendingPackets(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.LearnerHandlerTest.LearnerHandlerTest.MockZKDatabase(FileTxnSnapLog), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.LearnerHandlerTest.LearnerHandlerTest.getDataTreeLastProcessedZxid(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.LearnerHandlerTest.LearnerHandlerTest.getmaxCommittedLog(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.LearnerHandlerTest.LearnerHandlerTest.getminCommittedLog(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.LearnerHandlerTest.LearnerHandlerTest.getCommittedLog(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.LearnerHandlerTest.LearnerHandlerTest.getLogLock(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.LearnerHandlerTest.LearnerHandlerTest.getProposalsFromTxnLog(long, long), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.LearnerHandlerTest.LearnerHandlerTest.calculateTxnLogSizeLimit(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.LearnerHandlerTest.LearnerHandlerTest.setUp(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.LearnerHandlerTest.LearnerHandlerTest.createProposal(long), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.LearnerHandlerTest.LearnerHandlerTest.queuedPacketMatches(long[]), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.LearnerHandlerTest.LearnerHandlerTest.reset(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.LearnerHandlerTest.LearnerHandlerTest.assertOpType(int, long, long), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.LearnerHandlerTest.LearnerHandlerTest.assertZxidEquals(long, long), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.LearnerHandlerTest.LearnerHandlerTest.testEmptyCommittedLog(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.LearnerHandlerTest.LearnerHandlerTest.testCommittedLog(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.LearnerHandlerTest.LearnerHandlerTest.testTxnLog(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.LearnerHandlerTest.LearnerHandlerTest.testTxnLogOnly(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.LearnerHandlerTest.LearnerHandlerTest.getZxid(long, long), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.LearnerHandlerTest.LearnerHandlerTest.testTxnLogWithNegativeZxid(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.LearnerHandlerTest.LearnerHandlerTest.testNewEpochZxid(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.LearnerHandlerTest.LearnerHandlerTest.testNewEpochZxidWithTxnlogOnly(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.LearnerHandlerTest.LearnerHandlerTest.testDuplicatedTxn(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.LearnerHandlerTest.LearnerHandlerTest.testCrossEpochTrunc(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.LearnerHandler.LearnerHandler.run(), true
src.java.main.org.apache.zookeeper.server.quorum.LearnerHandler.LearnerHandler.startSendingPackets(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.LearnerHandler.LearnerHandler.syncFollower(long, ZKDatabase, Leader), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.LearnerHandler.LearnerHandler.queueCommittedProposals(Iterator<Proposal>, long, Long, Long), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.LearnerHandler.LearnerHandler.queueOpPacket(int, long), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.LearnerHandler.LearnerHandler.getQueuedPackets(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.LearnerHandler.LearnerHandler.setFirstPacket(boolean), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.LearnerHandler.LearnerHandler.ping(), true
src.java.test.org.apache.zookeeper.test.FollowerResyncConcurrencyTest.FollowerResyncConcurrencyTest.setUp(), false, new_method
src.java.test.org.apache.zookeeper.test.FollowerResyncConcurrencyTest.FollowerResyncConcurrencyTest.tearDown(), false, new_method
src.java.test.org.apache.zookeeper.test.FollowerResyncConcurrencyTest.FollowerResyncConcurrencyTest.testResyncByTxnlogThenDiffAfterFollowerCrashes(), false, new_method
src.java.test.org.apache.zookeeper.test.FollowerResyncConcurrencyTest.FollowerResyncConcurrencyTest.followerResyncCrashTest(boolean), false, new_method
src.java.test.org.apache.zookeeper.test.FollowerResyncConcurrencyTest.FollowerResyncConcurrencyTest.waitForPendingRequests(int), false, new_method
src.java.test.org.apache.zookeeper.test.FollowerResyncConcurrencyTest.FollowerResyncConcurrencyTest.waitForSync(QuorumUtil, int, int), false, new_method
src.java.test.org.apache.zookeeper.test.FollowerResyncConcurrencyTest.FollowerResyncConcurrencyTest.verifyState(QuorumUtil, int, Leader), true
src.java.test.org.apache.zookeeper.test.FollowerResyncConcurrencyTest.FollowerResyncConcurrencyTest.testResyncByDiffAfterFollowerCrashes(), false, test_method
src.java.test.org.apache.zookeeper.test.FollowerResyncConcurrencyTest.FollowerResyncConcurrencyTest.testResyncBySnapThenDiffAfterFollowerCrashes(), false, test_method
src.java.test.org.apache.zookeeper.test.FollowerResyncConcurrencyTest.FollowerResyncConcurrencyTest.testFollowerSendsLastZxid(), false, test_method
src.java.test.org.apache.zookeeper.test.FollowerResyncConcurrencyTest.FollowerResyncConcurrencyTest.testFollowerWatcherResync(), false, test_method
src.java.main.org.apache.zookeeper.server.TxnLogProposalIterator.TxnLogProposalIterator.hasNext(), false, new_method
src.java.main.org.apache.zookeeper.server.TxnLogProposalIterator.TxnLogProposalIterator.next(), false, new_method
src.java.main.org.apache.zookeeper.server.TxnLogProposalIterator.TxnLogProposalIterator.remove(), false, new_method
src.java.main.org.apache.zookeeper.server.TxnLogProposalIterator.TxnLogProposalIterator.TxnLogProposalIterator(), false, new_method
src.java.main.org.apache.zookeeper.server.TxnLogProposalIterator.TxnLogProposalIterator.TxnLogProposalIterator(TxnIterator), false, new_method
src.java.main.org.apache.zookeeper.server.ZKDatabase.ZKDatabase.getSnapshotSizeFactor(), false, new_method
src.java.main.org.apache.zookeeper.server.ZKDatabase.ZKDatabase.calculateTxnLogSizeLimit(), false, new_method
src.java.main.org.apache.zookeeper.server.ZKDatabase.ZKDatabase.getProposalsFromTxnLog(long, long), false, new_method
src.java.main.org.apache.zookeeper.server.ZKDatabase.ZKDatabase.setSnapshotSizeFactor(double), false, new_method
src.java.test.org.apache.zookeeper.test.GetProposalFromTxnTest.GetProposalFromTxnTest.testGetProposalFromTxn(), false, new_method
src.java.test.org.apache.zookeeper.test.GetProposalFromTxnTest.GetProposalFromTxnTest.process(WatchedEvent), false, new_method
src.java.test.org.apache.zookeeper.test.LoadFromLogTest.LoadFromLogTest.testLoad(), false, test_method
src.java.test.org.apache.zookeeper.test.LoadFromLogTest.LoadFromLogTest.testLoadFailure(), false, new_method
#####
zookeeper-3.4.5
ZOOKEEPER-1411
https://issues.apache.org/jira/browse/ZOOKEEPER-1411
Consolidate membership management, distinguish between static and dynamic configuration parameters Currently every server has a different static configuration file. This patch distinguishes between dynamic parameters, which are now in a separate "dynamic configuration file", and static parameters which are in the usual file. The config file points to the dynamic config file by specifying "dynamicConfigFile=...". In the first stage (this patch), all cluster membership definitions are in the dynamic config file, but in the future additional parameters may be moved to the dynamic file. Backward compatibility makes sure that you can still use a single config file if you'd like. Only when the config is changed (once ZK-107 is in) a dynamic file is automatically created and the necessary parameters are moved to it. This patch also moves all membership parsing and management into the QuorumVerifier classes, and removes QuorumPeer.quorumPeers. The cluster membership is contained in QuorumPeer.quorumVerifier. QuorumVerifier was expanded and now has methods such as getAllMembers(), getVotingMembers(), getObservingMembers().
Consolidate membership management, distinguish between static and dynamic configuration parameters Currently every server has a different static configuration file. This patch distinguishes between dynamic parameters, which are now in a separate "dynamic configuration file", and static parameters which are in the usual file. The config file points to the dynamic config file by specifying In the first stage (this patch), all cluster membership definitions are in the dynamic config file, but in the future additional parameters may be moved to the dynamic file. Backward compatibility makes sure that you can still use a single config file if you'd like. Only when the config is changed (once ZK-107 is in) a dynamic file is automatically created and the necessary parameters are moved to it. This patch also moves all membership parsing and management into the QuorumVerifier classes, and removes QuorumPeer.quorumPeers. The cluster membership is contained in was expanded and now has methods such as
******
src.java.test.org.apache.zookeeper.test.FLETest.FLETest.runElection(int), false, test_method
src.java.test.org.apache.zookeeper.test.FLETest.FLETest.testJoin(), false, test_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.QuorumPeerConfig.parse(String), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.QuorumPeerConfig.parseProperties(Properties), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.QuorumPeerConfig.getServers(), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.QuorumPeerConfig.isDistributed(), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.QuorumPeerConfig.writeDynamicConfig(String, String, boolean, QuorumVerifier), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.QuorumPeerConfig.deleteFile(String), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.QuorumPeerConfig.createQuorumVerifier(Properties, boolean), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.QuorumPeerConfig.parseDynamicConfig(Properties, int), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.QuorumPeerConfig.getDynamicConfigFilename(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.QuorumPeerConfig.getConfigFilename(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.QuorumPeerConfig.getConfigBackwardCompatibility(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumCnxManager.QuorumCnxManager.connectOne(long), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumCnxManager.QuorumCnxManager.run(), true
src.java.test.org.apache.zookeeper.test.QuorumBase.QuorumBase.setUp(boolean), false, test_method
src.java.test.org.apache.zookeeper.test.QuorumBase.QuorumBase.startServers(boolean), true
src.java.test.org.apache.zookeeper.test.QuorumBase.QuorumBase.setupServer(int), true
src.java.main.org.apache.zookeeper.server.quorum.flexible.QuorumMaj.QuorumMaj.hashCode(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.flexible.QuorumMaj.QuorumMaj.equals(Object), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.flexible.QuorumMaj.QuorumMaj.toByteArray(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.flexible.QuorumMaj.QuorumMaj.getAllMembers(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.flexible.QuorumMaj.QuorumMaj.getVotingMembers(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.flexible.QuorumMaj.QuorumMaj.getObservingMembers(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.flexible.QuorumMaj.QuorumMaj.getVersion(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.flexible.QuorumMaj.QuorumMaj.QuorumMaj(int), true
src.java.main.org.apache.zookeeper.server.quorum.flexible.QuorumMaj.QuorumMaj.containsQuorum(HashSet<Long>), true
src.java.main.org.apache.zookeeper.server.quorum.flexible.QuorumMaj.QuorumMaj.containsQuorum(HashSet<Long>), true
src.java.test.org.apache.zookeeper.server.util.DynamicConfigBCTest.DynamicConfigBCTest.dynamicConfigBackwardCompatibilityTest(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.Leader.Leader.lead(), true
src.java.test.org.apache.zookeeper.test.CnxManagerTest.CnxManagerTest.setUp(), false, test_method
src.java.test.org.apache.zookeeper.test.CnxManagerTest.CnxManagerTest.testCnxManagerTimeout(), false, test_method
src.java.main.org.apache.zookeeper.server.quorum.FastLeaderElection.FastLeaderElection.termPredicate(HashMap<Long, Vote>, Vote), true
src.java.main.org.apache.zookeeper.server.quorum.FastLeaderElection.FastLeaderElection.getInitId(), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.QuorumServer(long, InetSocketAddress, InetSocketAddress, InetSocketAddress), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.setType(String), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.QuorumServer(long, String), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.QuorumServer(long, InetSocketAddress, InetSocketAddress, InetSocketAddress, LearnerType), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.toString(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.hashCode(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.checkAddressesEqual(InetSocketAddress, InetSocketAddress), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.equals(Object), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.setDynamicConfigFilename(String), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.getDynamicConfigFilename(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.setConfigFileName(String), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.setConfigBackwardCompatibility(boolean), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.getConfigBackwardCompatibility(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.setQuorumAddress(InetSocketAddress), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.getElectionAddress(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.setElectionAddress(InetSocketAddress), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.getClientAddress(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.setClientAddress(InetSocketAddress), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.configFromString(String), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.setQuorumPeers(Map<Long, QuorumServer>), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.setQuorumVerifier(QuorumVerifier), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.getQuorumVerifier(), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.getQuorumAddress(), false, method_signature
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.QuorumServer(long, InetSocketAddress, InetSocketAddress), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.QuorumServer(long, InetSocketAddress), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.QuorumServer(long, InetSocketAddress, InetSocketAddress, LearnerType), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.setLearnerType(LearnerType), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.QuorumPeer(Map<Long, QuorumServer>, File, File, int, long, int, int, int, ServerCnxnFactory), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.QuorumPeer(Map<Long, QuorumServer>, File, File, int, long, int, int, int, ServerCnxnFactory, QuorumVerifier), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.QuorumPeer(Map<Long, QuorumServer>, File, File, int, int, long, int, int, int), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.QuorumPeer(Map<Long, QuorumServer>, File, File, int, int, long, int, int, int, QuorumVerifier), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.getView(), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.viewContains(Long), true
src.java.main.org.apache.zookeeper.server.quorum.flexible.QuorumHierarchical.QuorumHierarchical.QuorumHierarchical(String), true
src.java.main.org.apache.zookeeper.server.quorum.flexible.QuorumHierarchical.QuorumHierarchical.QuorumHierarchical(Properties), true
src.java.main.org.apache.zookeeper.server.quorum.flexible.QuorumHierarchical.QuorumHierarchical.QuorumHierarchical(int, HashMap<Long, Long>, HashMap<Long, Long>), true
src.java.main.org.apache.zookeeper.server.quorum.flexible.QuorumHierarchical.QuorumHierarchical.parse(Properties), true
src.java.main.org.apache.zookeeper.server.quorum.flexible.QuorumHierarchical.QuorumHierarchical.containsQuorum(HashSet<Long>), true
src.java.main.org.apache.zookeeper.server.quorum.flexible.QuorumHierarchical.QuorumHierarchical.getVotingMembers(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.flexible.QuorumHierarchical.QuorumHierarchical.hashCode(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.flexible.QuorumHierarchical.QuorumHierarchical.equals(Object), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.flexible.QuorumHierarchical.QuorumHierarchical.getAllMembers(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.flexible.QuorumHierarchical.QuorumHierarchical.toByteArray(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.flexible.QuorumHierarchical.QuorumHierarchical.getObservingMembers(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.flexible.QuorumHierarchical.QuorumHierarchical.getVersion(), false, new_method
src.java.test.org.apache.zookeeper.test.HierarchicalQuorumTest.HierarchicalQuorumTest.setUp(), false, test_method
src.java.test.org.apache.zookeeper.test.HierarchicalQuorumTest.HierarchicalQuorumTest.startServers(boolean), true
src.java.main.org.apache.zookeeper.server.quorum.LearnerHandler.LearnerHandler.run(), true
src.java.test.org.apache.zookeeper.test.LENonTerminateTest.LENonTerminateTest.MockQuorumPeer(Map<Long, QuorumServer>, File, File, int, int, long, int, int, int), false, test_method
src.java.test.org.apache.zookeeper.test.FLEZeroWeightTest.FLEZeroWeightTest.testZeroWeightQuorum(), false, test_method
src.java.test.org.apache.zookeeper.test.QuorumUtil.QuorumUtil.QuorumUtil(int), false, test_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerMain.QuorumPeerMain.initializeAndRun(String[]), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerMain.QuorumPeerMain.runFromConfig(QuorumPeerConfig), true
src.java.test.org.apache.zookeeper.server.quorum.QuorumPeerTestBase.QuorumPeerTestBase.MainThread(int, int, String), false, test_method
src.java.test.org.apache.zookeeper.test.StandaloneTest.StandaloneTest.testStandaloneQuorum(), false, test_method
src.java.test.org.apache.zookeeper.server.quorum.QuorumPeerMainTest.QuorumPeerMainTest.testQuorum(), false, test_method
src.java.test.org.apache.zookeeper.server.quorum.QuorumPeerMainTest.QuorumPeerMainTest.testEarlyLeaderAbandonment(), false, test_method
src.java.test.org.apache.zookeeper.server.quorum.QuorumPeerMainTest.QuorumPeerMainTest.LaunchServers(int), true
src.java.test.org.apache.zookeeper.server.quorum.QuorumPeerMainTest.QuorumPeerMainTest.testBadPeerAddressInQuorum(), false, test_method
src.java.test.org.apache.zookeeper.server.quorum.QuorumPeerMainTest.QuorumPeerMainTest.testInconsistentPeerType(), false, test_method
src.java.test.org.apache.zookeeper.server.quorum.QuorumPeerMainTest.QuorumPeerMainTest.testBadPackets(), false, test_method
src.java.test.org.apache.zookeeper.server.quorum.QuorumPeerMainTest.QuorumPeerMainTest.testQuorumDefaults(), false, test_method
src.java.test.org.apache.zookeeper.server.quorum.QuorumPeerMainTest.QuorumPeerMainTest.testQuorumPeerExitTime(), false, test_method
src.java.test.org.apache.zookeeper.test.ObserverTest.ObserverTest.testObserver(), false, test_method
src.java.test.org.apache.zookeeper.test.ObserverTest.ObserverTest.testObserverOnly(), false, test_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumZooKeeperServer.QuorumZooKeeperServer.dumpConf(PrintWriter), true
src.java.test.org.apache.zookeeper.server.quorum.Zab1_0Test.Zab1_0Test.createQuorumPeer(File), false, test_method
#####
zookeeper-3.4.5
ZOOKEEPER-1147
https://issues.apache.org/jira/browse/ZOOKEEPER-1147
Add support for local sessions This improvement is in the bucket of making ZooKeeper work at a large scale. We are planning on having about a 1 million clients connect to a ZooKeeper ensemble through a set of 50-100 observers. Majority of these clients are read only - ie they do not do any updates or create ephemeral nodes. In ZooKeeper today, the client creates a session and the session creation is handled like any other update. In the above use case, the session create/drop workload can easily overwhelm an ensemble. The following is a proposal for a "local session", to support a larger number of connections. 1. The idea is to introduce a new type of session - "local" session. A "local" session doesn't have a full functionality of a normal session. 2. Local sessions cannot create ephemeral nodes. 3. Once a local session is lost, you cannot re-establish it using the session-id/password. The session and its watches are gone for good. 4. When a local session connects, the session info is only maintained on the zookeeper server (in this case, an observer) that it is connected to. The leader is not aware of the creation of such a session and there is no state written to disk. 5. The pings and expiration is handled by the server that the session is connected to. With the above changes, we can make ZooKeeper scale to a much larger number of clients without making the core ensemble a bottleneck. In terms of API, there are two options that are being considered 1. Let the client specify at the connect time which kind of session do they want. 2. All sessions connect as local sessions and automatically get promoted to global sessions when they do an operation that requires a global session (e.g. creating an ephemeral node) Chubby took the approach of lazily promoting all sessions to global, but I don't think that would work in our case, where we want to keep sessions which never create ephemeral nodes as always local. Option 2 would make it more broadly usable but option 1 would be easier to implement. We are thinking of implementing option 1 as the first cut. There would be a client flag, IsLocalSession (much like the current readOnly flag) that would be used to determine whether to create a local session or a global session.
Add support for local sessions This improvement is in the bucket of making ZooKeeper work at a large scale. We are planning on having about a 1 million clients connect to a ZooKeeper ensemble through a set of 50-100 observers. Majority of these clients are read only - ie they do not do any updates or create ephemeral nodes. In ZooKeeper today, the client creates a session and the session creation is handled like any other update. In the above use case, the session create/drop workload can easily overwhelm an ensemble. The following is a proposal for a "local session", to support a larger number of connections. 1. The idea is to introduce a new type of session - "local" session. A "local" session doesn't have a full functionality of a normal session. 2. Local sessions cannot create ephemeral nodes. 3. Once a local session is lost, you cannot re-establish it using the session-id/password. The session and its watches are gone for good. 4. When a local session connects, the session info is only maintained on the zookeeper server (in this case, an observer) that it is connected to. The leader is not aware of the creation of such a session and there is no state written to disk. 5. The pings and expiration is handled by the server that the session is connected to. With the above changes, we can make ZooKeeper scale to a much larger number of clients without making the core ensemble a bottleneck. In terms of API, there are two options that are being considered 1. Let the client specify at the connect time which kind of session do they want. 2. All sessions connect as local sessions and automatically get promoted to global sessions when they do an operation that requires a global session (e.g. creating an ephemeral node) Chubby took the approach of lazily promoting all sessions to global, but I don't think that would work in our case, where we want to keep sessions which never create ephemeral nodes as always local. Option 2 would make it more broadly usable but option 1 would be easier to implement. We are thinking of implementing option 1 as the first cut. There would be a client flag, (much like the current readOnly flag) that would be used to determine whether to create a local session or a global session.
******
src.java.test.org.apache.zookeeper.server.PrepRequestProcessorTest.PrepRequestProcessorTest.void(long, int), false, test_method
src.java.test.org.apache.zookeeper.server.PrepRequestProcessorTest.PrepRequestProcessorTest.addGlobalSession(long, int), false, new_method
src.java.test.org.apache.zookeeper.server.PrepRequestProcessorTest.PrepRequestProcessorTest.upgradeSession(long), false, new_method
src.java.test.org.apache.zookeeper.server.PrepRequestProcessorTest.PrepRequestProcessorTest.isTrackingSession(long), false, new_method
src.java.test.org.apache.zookeeper.server.PrepRequestProcessorTest.PrepRequestProcessorTest.checkGlobalSession(long, Object), false, new_method
src.java.test.org.apache.zookeeper.test.LocalSessionsOnlyTest.LocalSessionsOnlyTest.setUp(), false, new_method
src.java.test.org.apache.zookeeper.test.LocalSessionsOnlyTest.LocalSessionsOnlyTest.tearDown(), false, new_method
src.java.test.org.apache.zookeeper.test.LocalSessionsOnlyTest.LocalSessionsOnlyTest.testLocalSessionsOnFollower(), false, new_method
src.java.test.org.apache.zookeeper.test.LocalSessionsOnlyTest.LocalSessionsOnlyTest.testLocalSessionsOnLeader(), false, new_method
src.java.test.org.apache.zookeeper.test.LocalSessionsOnlyTest.LocalSessionsOnlyTest.testLocalSessions(boolean), false, new_method
src.java.test.org.apache.zookeeper.test.SessionTrackerCheckTest.SessionTrackerCheckTest.Expirer(long), false, new_method
src.java.test.org.apache.zookeeper.test.SessionTrackerCheckTest.SessionTrackerCheckTest.expire(Session), false, new_method
src.java.test.org.apache.zookeeper.test.SessionTrackerCheckTest.SessionTrackerCheckTest.getServerId(), false, new_method
src.java.test.org.apache.zookeeper.test.SessionTrackerCheckTest.SessionTrackerCheckTest.setUp(), false, new_method
src.java.test.org.apache.zookeeper.test.SessionTrackerCheckTest.SessionTrackerCheckTest.tearDown(), false, new_method
src.java.test.org.apache.zookeeper.test.SessionTrackerCheckTest.SessionTrackerCheckTest.testLearnerSessionTracker(), false, new_method
src.java.test.org.apache.zookeeper.test.SessionTrackerCheckTest.SessionTrackerCheckTest.testLeaderSessionTracker(), false, new_method
src.java.test.org.apache.zookeeper.test.SessionUpgradeTest.SessionUpgradeTest.setUp(), false, new_method
src.java.test.org.apache.zookeeper.test.SessionUpgradeTest.SessionUpgradeTest.tearDown(), false, new_method
src.java.test.org.apache.zookeeper.test.SessionUpgradeTest.SessionUpgradeTest.testLocalSessionsWithoutEphemeralOnFollower(), false, new_method
src.java.test.org.apache.zookeeper.test.SessionUpgradeTest.SessionUpgradeTest.testLocalSessionsWithoutEphemeralOnLeader(), false, new_method
src.java.test.org.apache.zookeeper.test.SessionUpgradeTest.SessionUpgradeTest.testLocalSessionsWithoutEphemeral(boolean), false, new_method
src.java.test.org.apache.zookeeper.test.QuorumTest.QuorumTest.testFollowersStartAfterLeader(), false, test_method
src.java.test.org.apache.zookeeper.test.QuorumBase.QuorumBase.startServers(boolean), false, test_method
src.java.test.org.apache.zookeeper.test.QuorumBase.QuorumBase.getLeaderIndex(), false, new_method
src.java.test.org.apache.zookeeper.test.QuorumBase.QuorumBase.getPeerList(), false, new_method
src.java.test.org.apache.zookeeper.test.QuorumBase.QuorumBase.shutdown(QuorumPeer), true
src.java.test.org.apache.zookeeper.test.ReadOnlyModeTest.ReadOnlyModeTest.testReadOnlyClient(), false, test_method
src.java.test.org.apache.zookeeper.test.ReadOnlyModeTest.ReadOnlyModeTest.testConnectionEvents(), false, test_method
src.java.test.org.apache.zookeeper.test.LeaderSessionTrackerTest.LeaderSessionTrackerTest.setUp(), false, new_method
src.java.test.org.apache.zookeeper.test.LeaderSessionTrackerTest.LeaderSessionTrackerTest.tearDown(), false, new_method
src.java.test.org.apache.zookeeper.test.LeaderSessionTrackerTest.LeaderSessionTrackerTest.testExpiredSessionWithLocalSession(), false, new_method
src.java.test.org.apache.zookeeper.test.LeaderSessionTrackerTest.LeaderSessionTrackerTest.testExpiredSessionWithoutLocalSession(), false, new_method
src.java.test.org.apache.zookeeper.test.LeaderSessionTrackerTest.LeaderSessionTrackerTest.testCreateEphemeral(boolean), false, new_method
src.java.test.org.apache.zookeeper.test.LeaderSessionTrackerTest.LeaderSessionTrackerTest.testCreatePersistent(), false, new_method
src.java.test.org.apache.zookeeper.test.LeaderSessionTrackerTest.LeaderSessionTrackerTest.process(WatchedEvent), false, new_method
src.java.test.org.apache.zookeeper.test.LocalSessionRequestTest.LocalSessionRequestTest.setUp(), false, new_method
src.java.test.org.apache.zookeeper.test.LocalSessionRequestTest.LocalSessionRequestTest.tearDown(), false, new_method
src.java.test.org.apache.zookeeper.test.LocalSessionRequestTest.LocalSessionRequestTest.testLocalSessionsOnFollower(), false, new_method
src.java.test.org.apache.zookeeper.test.LocalSessionRequestTest.LocalSessionRequestTest.testLocalSessionsOnLeader(), false, new_method
src.java.test.org.apache.zookeeper.test.LocalSessionRequestTest.LocalSessionRequestTest.validateRequestLog(long, int), false, new_method
src.java.test.org.apache.zookeeper.test.LocalSessionRequestTest.LocalSessionRequestTest.testOpenCloseSession(boolean), false, new_method
src.java.test.org.apache.zookeeper.test.DuplicateLocalSessionUpgradeTest.DuplicateLocalSessionUpgradeTest.setUp(), false, new_method
src.java.test.org.apache.zookeeper.test.DuplicateLocalSessionUpgradeTest.DuplicateLocalSessionUpgradeTest.tearDown(), false, new_method
src.java.test.org.apache.zookeeper.test.DuplicateLocalSessionUpgradeTest.DuplicateLocalSessionUpgradeTest.testLocalSessionUpgradeOnFollower(), false, new_method
src.java.test.org.apache.zookeeper.test.DuplicateLocalSessionUpgradeTest.DuplicateLocalSessionUpgradeTest.testLocalSessionUpgradeOnLeader(), false, new_method
src.java.test.org.apache.zookeeper.test.DuplicateLocalSessionUpgradeTest.DuplicateLocalSessionUpgradeTest.testLocalSessionUpgrade(boolean), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.QuorumPeerMainTest.QuorumPeerMainTest.testEarlyLeaderAbandonment(), false, test_method
src.java.test.org.apache.zookeeper.server.quorum.QuorumPeerMainTest.QuorumPeerMainTest.waitForOne(ZooKeeper, States), true
src.java.test.org.apache.zookeeper.server.quorum.QuorumPeerMainTest.QuorumPeerMainTest.waitForAll(ZooKeeper[], States), true
src.java.test.org.apache.zookeeper.test.QuorumUtil.QuorumUtil.enableLocalSession(boolean), false, new_method
src.java.test.org.apache.zookeeper.test.QuorumUtil.QuorumUtil.getConnectString(QuorumPeer), false, new_method
src.java.test.org.apache.zookeeper.test.QuorumUtil.QuorumUtil.getLeaderQuorumPeer(), false, new_method
src.java.test.org.apache.zookeeper.test.QuorumUtil.QuorumUtil.getFollowerQuorumPeers(), false, new_method
src.java.test.org.apache.zookeeper.test.QuorumUtil.QuorumUtil.start(int), true
src.java.test.org.apache.zookeeper.test.QuorumUtil.QuorumUtil.startThenShutdown(int), true
src.java.main.org.apache.zookeeper.server.PrepRequestProcessor.PrepRequestProcessor.pRequest2Txn(int, long, Request, Record, boolean), true
src.java.main.org.apache.zookeeper.server.PrepRequestProcessor.PrepRequestProcessor.pRequest(Request), true
src.java.main.org.apache.zookeeper.server.PrepRequestProcessor.PrepRequestProcessor.validateCreateRequest(CreateMode, Request), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.FollowerRequestProcessor.FollowerRequestProcessor.run(), true
src.java.main.org.apache.zookeeper.server.quorum.FollowerRequestProcessor.FollowerRequestProcessor.processRequest(Request), true
src.java.main.org.apache.zookeeper.server.quorum.Learner.Learner.ping(QuorumPacket), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.QuorumPeerConfig.parseProperties(Properties), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.QuorumPeerConfig.areLocalSessionsEnabled(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.QuorumPeerConfig.isLocalSessionsUpgradingEnabled(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.LeaderRequestProcessor.LeaderRequestProcessor.LeaderRequestProcessor(LeaderZooKeeperServer, RequestProcessor), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.LeaderRequestProcessor.LeaderRequestProcessor.processRequest(Request), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.LeaderRequestProcessor.LeaderRequestProcessor.shutdown(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.LocalSessionTracker.LocalSessionTracker.LocalSessionTracker(SessionExpirer, ConcurrentMap<Long, Integer>, int, long), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.LocalSessionTracker.LocalSessionTracker.isLocalSession(long), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.LocalSessionTracker.LocalSessionTracker.isGlobalSession(long), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.LocalSessionTracker.LocalSessionTracker.addGlobalSession(long, int), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.ReadOnlyZooKeeperServer.ReadOnlyZooKeeperServer.ReadOnlyZooKeeperServer(FileTxnSnapLog, QuorumPeer, ZKDatabase), true
src.java.main.org.apache.zookeeper.server.quorum.ReadOnlyZooKeeperServer.ReadOnlyZooKeeperServer.dumpConf(PrintWriter), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.LeaderZooKeeperServer.LeaderZooKeeperServer.setupRequestProcessors(), true
src.java.main.org.apache.zookeeper.server.quorum.LeaderZooKeeperServer.LeaderZooKeeperServer.createSessionTracker(), true
src.java.main.org.apache.zookeeper.server.quorum.LeaderZooKeeperServer.LeaderZooKeeperServer.startSessionTracker(), true
src.java.main.org.apache.zookeeper.server.quorum.LeaderZooKeeperServer.LeaderZooKeeperServer.checkIfValidGlobalSession(long, int), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.LeaderZooKeeperServer.LeaderZooKeeperServer.submitLearnerRequest(Request), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.LearnerZooKeeperServer.LearnerZooKeeperServer.getTouchSnapshot(), true
src.java.main.org.apache.zookeeper.server.quorum.LearnerZooKeeperServer.LearnerZooKeeperServer.createSessionTracker(), true
src.java.main.org.apache.zookeeper.server.quorum.LearnerZooKeeperServer.LearnerZooKeeperServer.startSessionTracker(), true
src.java.main.org.apache.zookeeper.server.quorum.LearnerZooKeeperServer.LearnerZooKeeperServer.revalidateSession(ServerCnxn, long, int), true
src.java.main.org.apache.zookeeper.server.Request.Request.isLocalSession(), false, new_method
src.java.main.org.apache.zookeeper.server.Request.Request.setLocalSession(boolean), false, new_method
src.java.main.org.apache.zookeeper.server.Request.Request.isValid(int), true
src.java.main.org.apache.zookeeper.server.Request.Request.isQuorum(int), true
src.java.main.org.apache.zookeeper.KeeperException.KeeperException.create(Code), true
src.java.main.org.apache.zookeeper.KeeperException.KeeperException.getCodeMessage(Code), true
src.java.main.org.apache.zookeeper.KeeperException.KeeperException.UnknownSessionException(), false, new_method
src.java.main.org.apache.zookeeper.KeeperException.KeeperException.EphemeralOnLocalSessionException(), false, new_method
src.java.main.org.apache.zookeeper.server.ZooKeeperServer.ZooKeeperServer.getSessionTracker(), false, new_method
src.java.main.org.apache.zookeeper.server.ZooKeeperServer.ZooKeeperServer.close(long), true
src.java.main.org.apache.zookeeper.server.ZooKeeperServer.ZooKeeperServer.createSession(ServerCnxn, byte[], int), true
src.java.main.org.apache.zookeeper.server.ZooKeeperServer.ZooKeeperServer.reopenSession(ServerCnxn, long, byte[], int), false, refactoring
src.java.main.org.apache.zookeeper.server.ZooKeeperServer.ZooKeeperServer.submitRequest(ServerCnxn, long, int, int, ByteBuffer, List<Id>), true
src.java.main.org.apache.zookeeper.server.ZooKeeperServer.ZooKeeperServer.processPacket(ServerCnxn, ByteBuffer), true
src.java.main.org.apache.zookeeper.server.ZooKeeperServer.ZooKeeperServer.processTxn(TxnHeader, Record), true
src.java.main.org.apache.zookeeper.server.ZooKeeperServer.ZooKeeperServer.processTxn(Request), false, new_method
src.java.main.org.apache.zookeeper.server.ZooKeeperServer.ZooKeeperServer.processTxn(Request, TxnHeader, Record), false, refactoring
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.areLocalSessionsEnabled(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.enableLocalSessions(boolean), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.isLocalSessionsUpgradingEnabled(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.enableLocalSessionsUpgrading(boolean), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.setMaxSessionTimeout(int), false, comments
src.java.main.org.apache.zookeeper.server.quorum.UpgradeableSessionTracker.UpgradeableSessionTracker.start(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.UpgradeableSessionTracker.UpgradeableSessionTracker.createLocalSessionTracker(SessionExpirer, int, long), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.UpgradeableSessionTracker.UpgradeableSessionTracker.isTrackingSession(long), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.UpgradeableSessionTracker.UpgradeableSessionTracker.isLocalSession(long), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.UpgradeableSessionTracker.UpgradeableSessionTracker.upgradeSession(long), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.UpgradeableSessionTracker.UpgradeableSessionTracker.checkGlobalSession(long, Object), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.LeaderSessionTracker.LeaderSessionTracker.LeaderSessionTracker(SessionExpirer, ConcurrentMap<Long, Integer>, int, long, boolean), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.LeaderSessionTracker.LeaderSessionTracker.removeSession(long), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.LeaderSessionTracker.LeaderSessionTracker.start(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.LeaderSessionTracker.LeaderSessionTracker.shutdown(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.LeaderSessionTracker.LeaderSessionTracker.isGlobalSession(long), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.LeaderSessionTracker.LeaderSessionTracker.addGlobalSession(long, int), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.LeaderSessionTracker.LeaderSessionTracker.addSession(long, int), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.LeaderSessionTracker.LeaderSessionTracker.touchSession(long, int), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.LeaderSessionTracker.LeaderSessionTracker.createSession(int), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.LeaderSessionTracker.LeaderSessionTracker.getServerIdFromSessionId(long), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.LeaderSessionTracker.LeaderSessionTracker.checkSession(long, Object), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.LeaderSessionTracker.LeaderSessionTracker.checkGlobalSession(long, Object), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.LeaderSessionTracker.LeaderSessionTracker.setOwner(long, Object), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.LeaderSessionTracker.LeaderSessionTracker.dumpSessions(PrintWriter), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.LeaderSessionTracker.LeaderSessionTracker.setSessionClosing(long), false, new_method
src.java.main.org.apache.zookeeper.server.FinalRequestProcessor.FinalRequestProcessor.processRequest(Request), true
src.java.main.org.apache.zookeeper.server.quorum.CommitProcessor.CommitProcessor.needCommit(Request), true
src.java.main.org.apache.zookeeper.server.quorum.LearnerHandler.LearnerHandler.run(), true
src.java.main.org.apache.zookeeper.server.TraceFormatter.TraceFormatter.op2String(int), false, access_modifier
src.java.main.org.apache.zookeeper.server.quorum.ObserverRequestProcessor.ObserverRequestProcessor.run(), true
src.java.main.org.apache.zookeeper.server.quorum.ObserverRequestProcessor.ObserverRequestProcessor.processRequest(Request), true
src.java.main.org.apache.zookeeper.cli.CreateCommand.CreateCommand.exec(), true
src.java.main.org.apache.zookeeper.server.SessionTrackerImpl.SessionTrackerImpl.initializeNextSession(long), false, comments
src.java.main.org.apache.zookeeper.server.SessionTrackerImpl.SessionTrackerImpl.SessionTrackerImpl(SessionExpirer, ConcurrentHashMap<Long, Integer>, int, long), true
src.java.main.org.apache.zookeeper.server.SessionTrackerImpl.SessionTrackerImpl.getSessionTimeout(long), false, new_method
src.java.main.org.apache.zookeeper.server.SessionTrackerImpl.SessionTrackerImpl.isTrackingSession(long), false, new_method
src.java.main.org.apache.zookeeper.server.SessionTrackerImpl.SessionTrackerImpl.addGlobalSession(long, int), false, new_method
src.java.main.org.apache.zookeeper.server.SessionTrackerImpl.SessionTrackerImpl.checkGlobalSession(long, Object), false, new_method
src.java.main.org.apache.zookeeper.server.SessionTrackerImpl.SessionTrackerImpl.checkSession(long, Object), true
src.java.main.org.apache.zookeeper.server.SessionTrackerImpl.SessionTrackerImpl.addSession(long, int), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerMain.QuorumPeerMain.runFromConfig(QuorumPeerConfig), true
src.java.main.org.apache.zookeeper.server.quorum.LearnerSessionTracker.LearnerSessionTracker.LearnerSessionTracker(SessionExpirer, ConcurrentHashMap<Long, Integer>, long), true
src.java.main.org.apache.zookeeper.server.quorum.LearnerSessionTracker.LearnerSessionTracker.removeSession(long), true
src.java.main.org.apache.zookeeper.server.quorum.LearnerSessionTracker.LearnerSessionTracker.addSession(long, int), true
src.java.main.org.apache.zookeeper.server.quorum.LearnerSessionTracker.LearnerSessionTracker.touchSession(long, int), true
src.java.main.org.apache.zookeeper.server.quorum.LearnerSessionTracker.LearnerSessionTracker.snapshot(), true
src.java.main.org.apache.zookeeper.server.quorum.LearnerSessionTracker.LearnerSessionTracker.createSession(int), true
src.java.main.org.apache.zookeeper.server.quorum.LearnerSessionTracker.LearnerSessionTracker.checkSession(long, Object), true
src.java.main.org.apache.zookeeper.server.quorum.LearnerSessionTracker.LearnerSessionTracker.setOwner(long, Object), true
src.java.main.org.apache.zookeeper.server.quorum.LearnerSessionTracker.LearnerSessionTracker.dumpSessions(PrintWriter), true
src.java.main.org.apache.zookeeper.server.quorum.LearnerSessionTracker.LearnerSessionTracker.addGlobalSession(long, int), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.LearnerSessionTracker.LearnerSessionTracker.addSession(long, int), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumZooKeeperServer.QuorumZooKeeperServer.startSessionTracker(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumZooKeeperServer.QuorumZooKeeperServer.checkUpgradeSession(Request), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumZooKeeperServer.QuorumZooKeeperServer.makeUpgradeRequest(long), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumZooKeeperServer.QuorumZooKeeperServer.upgrade(long), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumZooKeeperServer.QuorumZooKeeperServer.setLocalSessionFlag(Request), false, new_method
#####
zookeeper-3.4.5
ZOOKEEPER-876
https://issues.apache.org/jira/browse/ZOOKEEPER-876
Unnecessary snapshot transfers between new leader and followers When starting a new leadership, unnecessary snapshot transfers happen between new leader and followers. This is so because of multiple small bugs. 1) the comparison of zxids is done based on a new proposal, instead of the last logged zxid. (LearnerHandler.java ~ 297) 2) if follower is one zxid behind, the check of the interval of committed logs excludes the follower. (LearnerHandler.java ~ 277) 3) the bug reported in ZOOKEEPER-874 (commitLogs are empty after recover).
Unnecessary snapshot transfers between new leader and followers When starting a new leadership, unnecessary snapshot transfers happen between new leader and followers. This is so because of multiple small bugs. 1) the comparison of zxids is done based on a new proposal, instead of the last logged zxid.  2) if follower is one zxid behind, the check of the interval of committed logs excludes the follower. 3) the bug reported in ZOOKEEPER-874 ( are empty after recover).
******
#####
zookeeper-3.4.5
ZOOKEEPER-442
https://issues.apache.org/jira/browse/ZOOKEEPER-442
need a way to remove watches that are no longer of interest currently the only way a watch cleared is to trigger it. we need a way to enumerate the outstanding watch objects, find watch events the objects are watching for, and remove interests in an event.
need a way to remove watches that are no longer of interest currently the only way a watch cleared is to trigger it. we need a way to enumerate the outstanding watch objects, find watch events the objects are watching for, and remove interests in an event.
******
#####
zookeeper-3.4.5
ZOOKEEPER-1873
https://issues.apache.org/jira/browse/ZOOKEEPER-1873
Unnecessarily InstanceNotFoundException is coming when unregister failed jmxbeans MBeanRegistry#register is keeping the beans which are failed to complete the registration. During unregistration time, these failed beans will results in following exception. [junit] 2014-01-29 08:34:56,667 [myid:] - WARN [main:MBeanRegistry@134] - Error during unregister [junit] javax.management.InstanceNotFoundException: org.apache.ZooKeeperService:name0=StandaloneServer_port-1 [junit] at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.getMBean(DefaultMBeanServerInterceptor.java:1095) [junit] at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.exclusiveUnregisterMBean(DefaultMBeanServerInterceptor.java:427) [junit] at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.unregisterMBean(DefaultMBeanServerInterceptor.java:415) [junit] at com.sun.jmx.mbeanserver.JmxMBeanServer.unregisterMBean(JmxMBeanServer.java:536) [junit] at org.apache.zookeeper.jmx.MBeanRegistry.unregister(MBeanRegistry.java:115)
Unnecessarily  is coming when unregister failed is keeping the beans which are failed to complete the registration. During unregistration time, these failed beans will results in following exception.
******
src.java.main.org.apache.zookeeper.jmx.MBeanRegistry.MBeanRegistry.register(ZKMBeanInfo, ZKMBeanInfo), true
#####
zookeeper-3.4.5
ZOOKEEPER-1867
https://issues.apache.org/jira/browse/ZOOKEEPER-1867
Bug in ZkDatabaseCorruptionTest If I'm reading the test case testCorruption right, it seems to depend on server 5 being elected, but if it is not the case, then it fails waiting for a server to be up.
Bug in If I'm reading the test case right, it seems to depend on server 5 being elected, but if it is not the case, then it fails waiting for a server to be up.
******
src.java.test.org.apache.zookeeper.test.ZkDatabaseCorruptionTest.ZkDatabaseCorruptionTest.testCorruption(), false, test_method
#####
zookeeper-3.4.5
ZOOKEEPER-1858
https://issues.apache.org/jira/browse/ZOOKEEPER-1858
JMX checks - potential race conditions while stopping and starting server I've noticed one potential case, where previously created zkclient session immediately reconnected and publishing those beans while starting back the zkserver and affecting zk#startup jmx checks. Say, before stopping the server, there is a zk client session 0x143576544c50000 exists. While starting back the server, there could be possibility of seeing the client sessions in jmx. Following is one such case. Please see below logs which has taken from build https://builds.apache.org/job/ZooKeeper-trunk-WinVS2008_java/642/ [junit] 2014-01-03 09:18:12,809 [myid:] - INFO [main-SendThread(127.0.0.1:11222):ClientCnxn$SendThread@1228] - Session establishment complete on server 127.0.0.1/127.0.0.1:11222, sessionid = 0x143576544c50000, negotiated timeout = 30000 [junit] 2014-01-03 09:18:12,809 [myid:] - INFO [NIOServerCxn.Factory:0.0.0.0/0.0.0.0:11222:ZooKeeperServer@617] - Established session 0x143576544c50000 with negotiated timeout 30000 for client /127.0.0.1:55377 [junit] 2014-01-03 09:18:12,391 [myid:] - INFO [main:JMXEnv@135] - ensureOnly:[] [junit] 2014-01-03 09:18:12,395 [myid:] - INFO [main:ClientBase@438] - STARTING server [junit] 2014-01-03 09:18:12,395 [myid:] - INFO [main:ClientBase@359] - CREATING server instance 127.0.0.1:11222 [junit] 2014-01-03 09:18:12,395 [myid:] - INFO [main:NIOServerCnxnFactory@94] - binding to port 0.0.0.0/0.0.0.0:11222 [junit] 2014-01-03 09:18:12,395 [myid:] - INFO [main:ClientBase@334] - STARTING server instance 127.0.0.1:11222 [junit] 2014-01-03 09:18:19,030 [myid:] - INFO [main:JMXEnv@142] - unexpected:org.apache.ZooKeeperService:name0=StandaloneServer_port-1,name1=Connections,name2=127.0.0.1,name3=0x143576544c50000 [junit] 2014-01-03 09:18:19,030 [myid:] - INFO [main:JMXEnv@142] - unexpected:org.apache.ZooKeeperService:name0=StandaloneServer_port-1 [junit] 2014-01-03 09:18:19,030 [myid:] - INFO [main:JUnit4ZKTestRunner$LoggedInvokeMethod@62] - TEST METHOD FAILED testDefaultWatcherAutoResetWithChroot [junit] junit.framework.AssertionFailedError: expected:<0> but was:<2> [junit] at junit.framework.Assert.fail(Assert.java:47) [junit] at junit.framework.Assert.failNotEquals(Assert.java:283) [junit] at junit.framework.Assert.assertEquals(Assert.java:64) [junit] at junit.framework.Assert.assertEquals(Assert.java:195) [junit] at junit.framework.Assert.assertEquals(Assert.java:201) [junit] at org.apache.zookeeper.test.JMXEnv.ensureOnly(JMXEnv.java:144) [junit] at org.apache.zookeeper.test.ClientBase.startServer(ClientBase.java:443) [junit] at org.apache.zookeeper.test.DisconnectedWatcherTest.testDefaultWatcherAutoResetWithChroot(DisconnectedWatcherTest.java:123) [junit] at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
JMX checks - potential race conditions while stopping and starting server I've noticed one potential case, where previously created zkclient session immediately reconnected and publishing those beans while starting back the zkserver and affecting zk#startup jmx checks. Say, before stopping the server, there is a zk client session exists. While starting back the server, there could be possibility of seeing the client sessions in jmx. Following is one such case. Please see below logs which has taken from build https://builds.apache.org/job/ZooKeeper-trunk-WinVS2008_java/642/
******
src.java.test.org.apache.zookeeper.test.ClientBase.ClientBase.TestableZooKeeper(CountdownWatcher, String, int), false, test_method
src.java.test.org.apache.zookeeper.test.ClientBase.ClientBase.startServer(), true
src.java.test.org.apache.zookeeper.test.ClientBase.ClientBase.verifyUnexpectedBeans(Set<ObjectName>), false, new_method
src.java.test.org.apache.zookeeper.test.ClientBase.ClientBase.getHexSessionId(long), false, new_method
src.java.test.org.apache.zookeeper.test.FourLetterWordsTest.FourLetterWordsTest.testFourLetterWords(), false, test_method
src.java.test.org.apache.zookeeper.test.FourLetterWordsQuorumTest.FourLetterWordsQuorumTest.testFourLetterWords(), false, test_method
src.java.test.org.apache.zookeeper.test.JMXEnv.JMXEnv.ensureParent(String...), false, new_method
src.java.test.org.apache.zookeeper.test.JMXEnv.JMXEnv.compare(String, String), false, new_method
#####
zookeeper-3.4.5
ZOOKEEPER-1852
https://issues.apache.org/jira/browse/ZOOKEEPER-1852
ServerCnxnFactory instance is not properly cleanedup ClientBase#createNewServerInstance() - Say the startup of the server fails, this will not initialize 'serverFactory' and will be null. When the flow comes to teardown/shutdown, it will bypass stopping of this server instance due to the following check. This will affect other test case verifications like, jmx check 'JMXEnv#ensureOnly'. ClientBase#shutdownServerInstance static void shutdownServerInstance(ServerCnxnFactory factory, String hostPort) { if (factory != null) { //...shutdown logic }
instance is not properly cleanedup  - Say the startup of the server fails, this will not initialize and will be null. When the flow comes to teardown/shutdown, it will bypass stopping of this server instance due to the following check. This will affect other test case verifications like, jmx check
******
src.java.test.org.apache.zookeeper.test.ClientBase.ClientBase.createNewServerInstance(File, ServerCnxnFactory, String, int), false, test_method
src.java.test.org.apache.zookeeper.test.ClientBase.ClientBase.createNewServerInstance(ServerCnxnFactory, String, int), false, new_method
src.java.test.org.apache.zookeeper.test.ClientBase.ClientBase.shutdownServerInstance(ServerCnxnFactory, String), true
src.java.test.org.apache.zookeeper.test.ClientBase.ClientBase.startServer(), true
src.java.test.org.apache.zookeeper.test.ClientBase.ClientBase.startServerInstance(File, ServerCnxnFactory, String), false, comments
src.java.test.org.apache.zookeeper.test.TruncateTest.TruncateTest.testTruncate(), false, test_method
#####
zookeeper-3.4.5
ZOOKEEPER-1844
https://issues.apache.org/jira/browse/ZOOKEEPER-1844
TruncateTest fails on windows TruncateTest has been failing consistently on windows: https://builds.apache.org/job/ZooKeeper-trunk-WinVS2008_java/627/testReport/junit/org.apache.zookeeper.test/TruncateTest/testTruncate/
fails on windows has been failing consistently on windows: https://builds.apache.org/job/ZooKeeper-trunk-WinVS2008_java/627/testReport/junit/org.apache.zookeeper.test/TruncateTest/testTruncate/
******
src.java.main.org.apache.zookeeper.server.persistence.FileTxnSnapLog.FileTxnSnapLog.restore(DataTree, Map<Long, Integer>, PlayBackListener), true
src.java.main.org.apache.zookeeper.server.persistence.FileTxnLog.FileTxnLog.getLastLoggedZxid(), true
src.java.main.org.apache.zookeeper.server.persistence.FileTxnLog.FileTxnLog.close(TxnIterator), false, new_method
src.java.main.org.apache.zookeeper.server.persistence.FileTxnLog.FileTxnLog.truncate(long), true
src.java.main.org.apache.zookeeper.server.persistence.FileTxnLog.FileTxnLog.close(), true
src.java.test.org.apache.zookeeper.server.quorum.LearnerHandlerTest.LearnerHandlerTest.testTxnLogProposalIteratorClosure(), false, new_method
src.java.test.org.apache.zookeeper.test.TruncateTest.TruncateTest.testTruncationStreamReset(), false, test_method
src.java.main.org.apache.zookeeper.server.quorum.LearnerHandler.LearnerHandler.syncFollower(long, ZKDatabase, Leader), true
src.java.main.org.apache.zookeeper.server.TxnLogProposalIterator.TxnLogProposalIterator.close(), false, new_method
src.java.main.org.apache.zookeeper.server.ZKDatabase.ZKDatabase.getProposalsFromTxnLog(long, long), true
#####
zookeeper-3.4.5
ZOOKEEPER-1841
https://issues.apache.org/jira/browse/ZOOKEEPER-1841
problem in QuorumTest QuorumTest.testNoLogBeforeLeaderEstablishment fails with Assertion: "NOt following"
problem in fails with Assertion: "NOt following"
******
src.java.test.org.apache.zookeeper.test.QuorumTest.QuorumTest.testFollowersStartAfterLeader(), false, test_method
src.java.test.org.apache.zookeeper.test.QuorumTest.QuorumTest.testNoLogBeforeLeaderEstablishment(), false, test_method
src.java.test.org.apache.zookeeper.test.QuorumTest.QuorumTest.testMultiToFollower(), false, test_method
src.java.test.org.apache.zookeeper.test.FollowerTest.FollowerTest.testFollowersStartAfterLeader(), false, new_method
src.java.test.org.apache.zookeeper.test.FollowerTest.FollowerTest.testNoLogBeforeLeaderEstablishment(), false, new_method
src.java.test.org.apache.zookeeper.test.FollowerTest.FollowerTest.testMultiToFollower(), false, new_method
#####
zookeeper-3.4.5
ZOOKEEPER-1839
https://issues.apache.org/jira/browse/ZOOKEEPER-1839
Deadlock in NettyServerCnxn Deadlock found during NettyServerCnxn closure. Please see the attached threaddump.
Deadlock in found during closure. Please see the attached threaddump.
******
src.java.main.org.apache.zookeeper.server.NettyServerCnxnFactory.NettyServerCnxnFactory.closeAll(), true
src.java.main.org.apache.zookeeper.server.NettyServerCnxnFactory.NettyServerCnxnFactory.closeSession(long), true
src.java.main.org.apache.zookeeper.server.NettyServerCnxn.NettyServerCnxn.close(), true
#####
zookeeper-3.4.5
ZOOKEEPER-1837
https://issues.apache.org/jira/browse/ZOOKEEPER-1837
Fix JMXEnv checks (potential race conditions) The following failures in ZooKeeper-3.4-WinVS2008_java and ZooKeeper-trunk-WinVS2008_java require fixing: [junit] junit.framework.AssertionFailedError: expected:<0> but was:<1> [junit] at junit.framework.Assert.fail(Assert.java:47) [junit] at junit.framework.Assert.failNotEquals(Assert.java:283) [junit] at junit.framework.Assert.assertEquals(Assert.java:64) [junit] at junit.framework.Assert.assertEquals(Assert.java:195) [junit] at junit.framework.Assert.assertEquals(Assert.java:201) [junit] at org.apache.zookeeper.test.JMXEnv.ensureOnly(JMXEnv.java:138) [junit] at org.apache.zookeeper.test.ClientBase.startServer(ClientBase.java:417) [junit] at org.apache.zookeeper.test.ZooKeeperQuotaTest.testQuota(ZooKeeperQuotaTest.java:80) [junit] at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) [junit] at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) [junit] at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) [junit] at java.lang.reflect.Method.invoke(Method.java:597) [junit] at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44) [junit] at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15) [junit] at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41) [junit] at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20) [junit] junit.framework.AssertionFailedError: expected:<0> but was:<1> [junit] at junit.framework.Assert.fail(Assert.java:47) [junit] at junit.framework.Assert.failNotEquals(Assert.java:283) [junit] at junit.framework.Assert.assertEquals(Assert.java:64) [junit] at junit.framework.Assert.assertEquals(Assert.java:195) [junit] at junit.framework.Assert.assertEquals(Assert.java:201) [junit] at org.apache.zookeeper.test.JMXEnv.ensureOnly(JMXEnv.java:138) [junit] at org.apache.zookeeper.test.ClientBase.startServer(ClientBase.java:417) [junit] at org.apache.zookeeper.test.ZooKeeperQuotaTest.testQuota(ZooKeeperQuotaTest.java:80) [junit] at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) [junit] at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) [junit] at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) [junit] at java.lang.reflect.Method.invoke(Method.java:597) [junit] at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44) [junit] at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15) [junit] at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41) [junit] at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20) [junit] at org.apache.zookeeper.JUnit4ZKTestRunner$LoggedInvokeMethod.evaluate(JUnit4ZKTestRunner.java:52) [ junit.framework.AssertionFailedError: expected [0x142e5f027b50001] expected:<1> but was:<0> at org.apache.zookeeper.test.JMXEnv.ensureAll(JMXEnv.java:115) at org.apache.zookeeper.test.ClientBase.createClient(ClientBase.java:197) at org.apache.zookeeper.test.ClientBase.createClient(ClientBase.java:171) at org.apache.zookeeper.test.ClientBase.createClient(ClientBase.java:156) at org.apache.zookeeper.test.ClientBase.createClient(ClientBase.java:149) at org.apache.zookeeper.ZooKeeperTest.testDeleteRecursive(ZooKeeperTest.java:45) at org.apache.zookeeper.JUnit4ZKTestRunner$LoggedInvokeMethod.evaluate(JUnit4ZKTestRunner.java:52)
Fix checks (potential race conditions) The following failures in and require fixing:
******
src.java.test.org.apache.zookeeper.test.ClientBase.ClientBase.createClient(CountdownWatcher, String, int), false, test_method
src.java.test.org.apache.zookeeper.test.QuorumUtil.QuorumUtil.startAll(), false, refactoring
src.java.test.org.apache.zookeeper.test.JMXEnv.JMXEnv.ensureOnly(String...), false, test_method
#####
zookeeper-3.4.5
ZOOKEEPER-1834
https://issues.apache.org/jira/browse/ZOOKEEPER-1834
Catch IOException in FileTxnLog Upon an IOException in FileTxnLog#next(), the log file open remains open, which causes test cases at least in BufferSizeTest to fail. We need to add a catch block.
Catch  in the log file open remains open, which causes test cases at least in to fail. We need to add a catch block.
******
src.java.main.org.apache.zookeeper.server.persistence.FileTxnLog.FileTxnLog.next(), true
#####
zookeeper-3.4.5
ZOOKEEPER-1817
https://issues.apache.org/jira/browse/ZOOKEEPER-1817
Fix don't care for b3.4 See umbrella jira.
Fix don't care for b3.4 See umbrella jira.
******
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.getBCVote(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.setBCVote(Vote), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.run(), true
src.java.main.org.apache.zookeeper.server.quorum.Vote.Vote.equals(Object), true
src.java.main.org.apache.zookeeper.server.quorum.Vote.Vote.toString(), true
src.java.main.org.apache.zookeeper.server.quorum.FastLeaderElection.FastLeaderElection.run(), true
src.java.main.org.apache.zookeeper.server.quorum.FastLeaderElection.FastLeaderElection.termPredicate(HashMap<Long, Vote>, Vote), false, access_modifier
src.java.main.org.apache.zookeeper.server.quorum.FastLeaderElection.FastLeaderElection.checkLeader(HashMap<Long, Vote>, long, long), false, access_modifier
src.java.main.org.apache.zookeeper.server.quorum.FastLeaderElection.FastLeaderElection.ooePredicate(HashMap<Long, Vote>, HashMap<Long, Vote>, Notification), true
src.java.main.org.apache.zookeeper.server.quorum.FastLeaderElection.FastLeaderElection.lookForLeader(), true
src.java.test.org.apache.zookeeper.server.quorum.FLEDontCareTest.FLEDontCareTest.MockFLE(QuorumPeer, QuorumCnxManager), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.FLEDontCareTest.FLEDontCareTest.termPredicate(HashMap<Long, Vote>, Vote), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.FLEDontCareTest.FLEDontCareTest.checkLeader(HashMap<Long, Vote>, long, long), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.FLEDontCareTest.FLEDontCareTest.ooePredicate(HashMap<Long, Vote>, HashMap<Long, Vote>, FastLeaderElection.Notification), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.FLEDontCareTest.FLEDontCareTest.setUp(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.FLEDontCareTest.FLEDontCareTest.tearDown(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.FLEDontCareTest.FLEDontCareTest.testDontCare(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.FLEDontCareTest.FLEDontCareTest.testDontCareVersion(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.FLEDontCareTest.FLEDontCareTest.testLookingNormal(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.FLEDontCareTest.FLEDontCareTest.testLookingDiffRounds(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.FLEDontCareTest.FLEDontCareTest.genNotification(int, long, long, long, ServerState, long, long, HashMap<Long, Vote>), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.FLEDontCareTest.FLEDontCareTest.testOutofElection(), false, new_method
#####
zookeeper-3.4.5
ZOOKEEPER-1812
https://issues.apache.org/jira/browse/ZOOKEEPER-1812
ZooInspector reconnection always fails if first connection fails Steps to reproduce: Connect to localhost:2181 when ZooKeeper server is down. After a few seconds, ZooInspector warns that the connection has failed start the ZooKeeper server Reconnect to localhost:2181, ZooInspector will still not be able to connect to the server. The workaround is to relaunch ZooInspector.
reconnection always fails if first connection fails Steps to reproduce: Connect to localhost:2181 when ZooKeeper server is down. After a few seconds, warns that the connection has failed start the ZooKeeper server Reconnect to localhost:2181, will still not be able to connect to the server. The workaround is to relaunch.
******
src.contrib.zooinspector.src.java.org.apache.zookeeper.inspector.manager.ZooInspectorManagerImpl.ZooInspectorManagerImpl.connect(Properties), true
#####
zookeeper-3.4.5
ZOOKEEPER-1798
https://issues.apache.org/jira/browse/ZOOKEEPER-1798
Fix race condition in testNormalObserverRun This is the output messges: <noformat> Testcase: testNormalObserverRun took 4.221 sec FAILED expected:<data[2]> but was:<data[1]> junit.framework.AssertionFailedError: expected:<data[2]> but was:<data[1]> at org.apache.zookeeper.server.quorum.Zab1_0Test$8.converseWithObserver(Zab1_0Test.java:1118) at org.apache.zookeeper.server.quorum.Zab1_0Test.testObserverConversation(Zab1_0Test.java:546) at org.apache.zookeeper.server.quorum.Zab1_0Test.testNormalObserverRun(Zab1_0Test.java:994) <noformat>
Fix race condition in This is the output messges:
******
src.java.main.org.apache.zookeeper.server.quorum.ObserverZooKeeperServer.ObserverZooKeeperServer.shutdown(), false, new_method
src.java.main.org.apache.zookeeper.server.SyncRequestProcessor.SyncRequestProcessor.shutdown(), true
src.java.test.org.apache.zookeeper.server.quorum.Zab1_0Test.Zab1_0Test.converseWithObserver(InputArchive, OutputArchive, Observer), false, test_method
#####
zookeeper-3.4.5
ZOOKEEPER-1781
https://issues.apache.org/jira/browse/ZOOKEEPER-1781
ZooKeeper Server fails if snapCount is set to 1  If snapCount is set to 1, ZooKeeper Server can start but it fails with the below error: 2013-10-02 18:09:07,600 [myid:1] - ERROR [SyncThread:1:SyncRequestProcessor@151] - Severe unrecoverable error, exiting java.lang.IllegalArgumentException: n must be positive at java.util.Random.nextInt(Random.java:300) at org.apache.zookeeper.server.SyncRequestProcessor.run(SyncRequestProcessor.java:93) In source code, it maybe be supposed that snapCount must be 2 or more: org.apache.zookeeper.server.SyncRequestProcessor.java 91 // we do this in an attempt to ensure that not all ofthe servers 92 // in the ensemble take a snapshot at the same time 93 int randRoll = r.nextInt(snapCount/2); I think this supposition is not bad because snapCount = 1 is not realistic setting... But, it may be better to mention this restriction in documentation or add a validation in the source code.
ZooKeeper Server fails if is set to 1  If is set to 1, ZooKeeper Server can start but it fails with the below error:- Severe unrecoverable error, exiting n must be positive at In source code, it maybe be supposed that must be 2 or more: I think this supposition is not bad because is not realistic setting... But, it may be better to mention this restriction in documentation or add a validation in the source code.
******
src.java.test.org.apache.zookeeper.server.InvalidSnapCountTest.InvalidSnapCountTest.MainThread(int), false, new_method
src.java.test.org.apache.zookeeper.server.InvalidSnapCountTest.InvalidSnapCountTest.run(), false, new_method
src.java.test.org.apache.zookeeper.server.InvalidSnapCountTest.InvalidSnapCountTest.shutdown(), false, new_method
src.java.test.org.apache.zookeeper.server.InvalidSnapCountTest.InvalidSnapCountTest.testInvalidSnapCount(), false, new_method
src.java.test.org.apache.zookeeper.server.InvalidSnapCountTest.InvalidSnapCountTest.process(WatchedEvent), false, new_method
src.java.main.org.apache.zookeeper.server.ZooKeeperServer.ZooKeeperServer.getSnapCount(), true
#####
zookeeper-3.4.5
ZOOKEEPER-1774
https://issues.apache.org/jira/browse/ZOOKEEPER-1774
QuorumPeerMainTest fails consistently with "complains about host" assertion failure QuorumPeerMainTest fails consistently with "complains about host" assertion failure. 2013-10-01 16:09:17,962 [myid:] - INFO [main:JUnit4ZKTestRunner$LoggedInvokeMethod@54] - TEST METHOD FAILED testBadPeerAddressInQuorum java.lang.AssertionError: complains about host at org.junit.Assert.fail(Assert.java:91) at org.junit.Assert.assertTrue(Assert.java:43) at org.apache.zookeeper.server.quorum.QuorumPeerMainTest.testBadPeerAddressInQuorum(QuorumPeerMainTest.java:434) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:597) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20) at org.apache.zookeeper.JUnit4ZKTestRunner$LoggedInvokeMethod.evaluate(JUnit4ZKTestRunner.java:52) at org.junit.rules.TestWatchman$1.evaluate(TestWatchman.java:48) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:76) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184) at org.junit.runners.ParentRunner.run(ParentRunner.java:236) at junit.framework.JUnit4TestAdapter.run(JUnit4TestAdapter.java:39) at org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:518) at org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.launch(JUnitTestRunner.java:1052) at org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.main(JUnitTestRunner.java:906) 2013-10-01 16:09:17,963 [myid:] - INFO [main:ZKTestCase$1@65] - FAILED testBadPeerAddressInQuorum java.lang.AssertionError: complains about host at org.junit.Assert.fail(Assert.java:91) at org.junit.Assert.assertTrue(Assert.java:43) at org.apache.zookeeper.server.quorum.QuorumPeerMainTest.testBadPeerAddressInQuorum(QuorumPeerMainTest.java:434) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:597) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20) at org.apache.zookeeper.JUnit4ZKTestRunner$LoggedInvokeMethod.evaluate(JUnit4ZKTestRunner.java:52) at org.junit.rules.TestWatchman$1.evaluate(TestWatchman.java:48) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:76) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184) at org.junit.runners.ParentRunner.run(ParentRunner.java:236) at junit.framework.JUnit4TestAdapter.run(JUnit4TestAdapter.java:39) at org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:518) at org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.launch(JUnitTestRunner.java:1052) at org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.main(JUnitTestRunner.java:906)
fails consistently with "complains about host" assertion failure fails consistently with "complains about host" assertion failure.
******
src.java.test.org.apache.zookeeper.server.quorum.QuorumPeerMainTest.QuorumPeerMainTest.testBadPeerAddressInQuorum(), false, test_method
#####
zookeeper-3.4.5
ZOOKEEPER-1771
https://issues.apache.org/jira/browse/ZOOKEEPER-1771
ZooInspector authentication ZooInspector doesn't support authentication, so it always connects as anonymous to the ensemble. It would be nice to be able to configure the authentication scheme+data in order to browse the nodes that have ACLs set.
authentication doesn't support authentication, so it always connects as anonymous to the ensemble. It would be nice to be able to configure the authentication scheme+data in order to browse the nodes that have ACLs set.
******
src.contrib.zooinspector.src.java.org.apache.zookeeper.inspector.manager.ZooInspectorManagerImpl.ZooInspectorManagerImpl.connect(Properties), true
src.contrib.zooinspector.src.java.org.apache.zookeeper.inspector.manager.ZooInspectorManagerImpl.ZooInspectorManagerImpl.getConnectionPropertiesTemplate(), true
src.contrib.zooinspector.src.java.org.apache.zookeeper.inspector.manager.ZooInspectorManagerImpl.ZooInspectorManagerImpl.loadDefaultConnectionFile(), true
src.contrib.zooinspector.src.java.org.apache.zookeeper.inspector.manager.ZooInspectorManagerImpl.ZooInspectorManagerImpl.loadNodeViewersFile(File), true
#####
zookeeper-3.4.5
ZOOKEEPER-1770
https://issues.apache.org/jira/browse/ZOOKEEPER-1770
NullPointerException in SnapshotFormatter SnapshotFormatter fails with a NullPointerException when parsing one snapshot (with "null" data in one Znode): Exception in thread "main" java.lang.NullPointerException at org.apache.zookeeper.server.SnapshotFormatter.printZnode(SnapshotFormatter.java:90) at org.apache.zookeeper.server.SnapshotFormatter.printZnode(SnapshotFormatter.java:95) at org.apache.zookeeper.server.SnapshotFormatter.printZnode(SnapshotFormatter.java:95) at org.apache.zookeeper.server.SnapshotFormatter.printZnode(SnapshotFormatter.java:95) at org.apache.zookeeper.server.SnapshotFormatter.printZnodeDetails(SnapshotFormatter.java:79) at org.apache.zookeeper.server.SnapshotFormatter.printDetails(SnapshotFormatter.java:71) at org.apache.zookeeper.server.SnapshotFormatter.run(SnapshotFormatter.java:67) at org.apache.zookeeper.server.SnapshotFormatter.main(SnapshotFormatter.java:51)
fails with a when parsing one snapshot (with "null" data in one Znode): Exception in thread "main"
******
src.java.test.org.apache.zookeeper.test.InvalidSnapshotTest.InvalidSnapshotTest.testSnapshotFormatterWithNull(), false, new_method
src.java.main.org.apache.zookeeper.server.SnapshotFormatter.SnapshotFormatter.printZnode(DataTree, String), true
#####
zookeeper-3.4.5
ZOOKEEPER-1755
https://issues.apache.org/jira/browse/ZOOKEEPER-1755
Concurrent operations of four letter 'dump' ephemeral command and killSession causing NPE Potential problem occurs, when executing four letter 'dump' command and at the meantime zkserver has triggered session closure and removing the related information from the DataTree. Please see the exception: java.lang.NullPointerException at org.apache.zookeeper.server.DataTree.dumpEphemerals(DataTree.java:1278) at org.apache.zookeeper.server.DataTreeTest$1.run(DataTreeTest.java:82)
Concurrent operations of four letter 'dump' ephemeral command and causing Potential problem occurs, when executing four letter 'dump' command and at the meantime zkserver has triggered session closure and removing the related information from the Please see the exception:
******
src.java.test.org.apache.zookeeper.server.DataTreeTest.DataTreeTest.testDumpEphemerals(), false, new_method
src.java.test.org.apache.zookeeper.server.DataTreeTest.DataTreeTest.killZkClientSession(long, long, DataTree, int), false, new_method
src.java.test.org.apache.zookeeper.server.DataTreeTest.DataTreeTest.createEphemeralNode(long, DataTree, int), false, new_method
src.java.main.org.apache.zookeeper.server.DataTree.DataTree.dumpEphemerals(PrintWriter), true
#####
zookeeper-3.4.5
ZOOKEEPER-1753
https://issues.apache.org/jira/browse/ZOOKEEPER-1753
ClientCnxn is not properly releasing the resources, which are used to ping RwServer While pinging to the RwServer, ClientCnxn is opening a socket and using BufferedReader. These are not properly closed in finally block and could cause leaks on exceptional cases. ClientCnxn#pingRwServer() try { Socket sock = new Socket(addr.getHostName(), addr.getPort()); BufferedReader br = new BufferedReader( new InputStreamReader(sock.getInputStream())); ...... sock.close(); br.close(); } catch (ConnectException e) { // ignore, this just means server is not up } catch (IOException e) { // some unexpected error, warn about it LOG.warn("Exception while seeking for r/w server " + e.getMessage(), e); }
is not properly releasing the resources, which are used to ping RwServer While pinging to the RwServer, is opening a socket and using These are not properly closed in finally block and could cause leaks on exceptional cases.
******
src.java.main.org.apache.zookeeper.ClientCnxn.ClientCnxn.pingRwServer(), true
#####
zookeeper-3.4.5
ZOOKEEPER-1751
https://issues.apache.org/jira/browse/ZOOKEEPER-1751
ClientCnxn#run could miss the second ping or connection get dropped before a ping We could throw SessionTimeoutException exception even when timeToNextPing may also be negative depending on the time when the following line is executed by the thread because we check time out before sending a ping. to = readTimeout - clientCnxnSocket.getIdleRecv(); In addition, we only ping twice no matter how long the session time out value is. For example, we set session time out = 60mins then we only try ping twice in 40mins window. Therefore, the connection could be dropped by OS after idle time out. The issue is causing randomly "connection loss" or "session expired" issues in client side which is bad for applications like HBase.
could miss the second ping or connection get dropped before a ping We could throw exception even when may also be negative depending on the time when the following line is executed by the thread because we check time out before sending a ping. In addition, we only ping twice no matter how long the session time out value is. For example, we set session time out = 60mins then we only try ping twice in 40mins window. Therefore, the connection could be dropped by OS after idle time out. The issue is causing randomly "connection loss" or "session expired" issues in client side which is bad for applications like HBase.
******
src.java.main.org.apache.zookeeper.ClientCnxn.ClientCnxn.run(), true
#####
zookeeper-3.4.5
ZOOKEEPER-1750
https://issues.apache.org/jira/browse/ZOOKEEPER-1750
Race condition producing NPE in NIOServerCnxn.toString  The socket is closed and the variable "sock" is set to null for normal reasons, but the toString method is called before "sock" can be set again, producing a NullPointerException. Stack trace: 2013-08-29 01:49:19,991 6277 [CommitProcWorkThread-3] WARN org.apache.zookeeper.server.WorkerService - Unexpected exception java.lang.NullPointerException at org.apach.zookeeper.server.NIOServerCnxn.toString(NIOServerCnxn.java:961) at java.lang.String.valueOf(String.java:2854) at java.lang.StringBuilder.append(StringBuilder.java:128) at org.apache.zookeeper.server.NIOServerCnxn.process(NIOServerCnxn.java:1104) at org.apache.zookeeper.server.WatchManager.triggerWatch(WatchManager.java:120) at org.apache.zookeeper.server.WatchManager.triggerWatch(WatchManager.java:92) at org.apache.zookeeper.server.DataTree.createNode(DataTree.java:544) at org.apache.zookeeper.server.DataTree.processTxn(DataTree.java:805) at org.apache.zookeeper.server.ZKDatabase.processTxn(ZKDatabase.java:319) at org.apache.zookeeper.server.ZooKeeperServer.processTxn(ZooKeeperServer.java:967) at org.apache.zookeeper.server.FinalRequestProcessor.processRequest(FinalRequestProcessor.java:115) at org.apache.zookeeper.server.quorum.Leader$ToBeAppliedRequestProcessor.processRequest(Leader.java:859) at org.apache.zookeeper.server.quorum.CommitProcessor$CommitWorkRequest.doWork(CommitProcessor.java:271) at org.apache.zookeeper.server.WorkerService$ScheduledWorkRequest.run(WorkerService.java:152) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) at java.lang.Thread.run(Thread.java:722)
Race condition producing The socket is closed and the variable "sock" is set to null for normal reasons, but the method is called before "sock" can be set again, producing a. Stack trace:
******
src.java.main.org.apache.zookeeper.server.NIOServerCnxn.NIOServerCnxn.sendBufferSync(ByteBuffer), true
src.java.main.org.apache.zookeeper.server.NIOServerCnxn.NIOServerCnxn.doIO(SelectionKey), true
src.java.main.org.apache.zookeeper.server.NIOServerCnxn.NIOServerCnxn.closeSock(), true
src.java.main.org.apache.zookeeper.server.NIOServerCnxn.NIOServerCnxn.closeSock(SocketChannel), true
src.java.main.org.apache.zookeeper.server.NIOServerCnxn.NIOServerCnxn.getRemoteSocketAddress(), true
src.java.main.org.apache.zookeeper.server.NIOServerCnxn.NIOServerCnxn.getSocketAddress(), true
src.java.test.org.apache.zookeeper.server.NIOServerCnxnTest.NIOServerCnxnTest.testOperationsAfterCnxnClose(), false, new_method
#####
zookeeper-3.4.5
ZOOKEEPER-1733
https://issues.apache.org/jira/browse/ZOOKEEPER-1733
FLETest#testLE is flaky on windows boxes FLETest#testLE fail intermittently on windows boxes. The reason is that in LEThread#run() we have: if(leader == i){ synchronized(finalObj){ successCount++; if(successCount > (count/2)) finalObj.notify(); } break; } Basically once we have a confirmed leader, the leader thread dies due to the "break" of while loop. While in the verification step, we check if the leader thread alive or not as following: if(threads.get((int) leader).isAlive()){ Assert.fail("Leader hasn't joined: " + leader); } On windows boxes, the above verification step fails frequently because leader thread most likely already exits. Do we know why we have the leader alive verification step only lead thread can bump up successCount >= count/2?
is flaky on windows boxes fail intermittently on windows boxes. The reason is that in  we have Basically once we have a confirmed leader, the leader thread dies due to the "break" of while loop. While in the verification step, we check if the leader thread alive or not as following: On windows boxes, the above verification step fails frequently because leader thread most likely already exits. Do we know why we have the leader alive verification step only lead thread can bump up
******
src.java.test.org.apache.zookeeper.test.FLETest.FLETest.setUp(), false, test_method
src.java.test.org.apache.zookeeper.test.FLETest.FLETest.run(), true
src.java.test.org.apache.zookeeper.test.FLETest.FLETest.waitForQuorum(long), true
src.java.test.org.apache.zookeeper.test.FLETest.FLETest.runElection(int), true
#####
zookeeper-3.4.5
ZOOKEEPER-1732
https://issues.apache.org/jira/browse/ZOOKEEPER-1732
ZooKeeper server unable to join established ensemble I have a test in which I do a rolling restart of three ZooKeeper servers and it was failing from time to time. I ran the tests in a loop until the failure came out and it seems that at some point one of the servers is unable to join the enssemble formed by the other two.
ZooKeeper server unable to join established ensemble I have a test in which I do a rolling restart of three ZooKeeper servers and it was failing from time to time. I ran the tests in a loop until the failure came out and it seems that at some point one of the servers is unable to join the enssemble formed by the other two.
******
src.java.test.org.apache.zookeeper.test.FLETest.FLETest.testJoinInconsistentEnsemble(), false, test_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.updateElectionVote(long), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.Leader.Leader.startZkServer(), true
src.java.main.org.apache.zookeeper.server.quorum.Learner.Learner.syncWithLeader(long), true
src.java.main.org.apache.zookeeper.server.quorum.FastLeaderElection.FastLeaderElection.lookForLeader(), true
#####
zookeeper-3.4.5
ZOOKEEPER-1715
https://issues.apache.org/jira/browse/ZOOKEEPER-1715
Upgrade netty version Upgrade netty version
Upgrade netty version
******
src.java.main.org.apache.zookeeper.server.NIOServerCnxn.NIOServerCnxn.disableRecv(), true
src.java.main.org.apache.zookeeper.server.NIOServerCnxn.NIOServerCnxn.disableRecvNoWait(), false, refactoring
src.java.main.org.apache.zookeeper.server.NettyServerCnxn.NettyServerCnxn.receiveMessage(ChannelBuffer), true
#####
zookeeper-3.4.5
ZOOKEEPER-1696
https://issues.apache.org/jira/browse/ZOOKEEPER-1696
Fail to run zookeeper client on Weblogic application server The problem in details is described here: http://comments.gmane.org/gmane.comp.java.zookeeper.user/2897 The provided link also contains a reference to fix implementation. ####<Apr 24, 2013 1:03:28 PM MSK> <Warning> <org.apache.zookeeper.ClientCnxn> <devapp090> <clust2> <[ACTIVE] ExecuteThread: '2' for queue: 'weblogic.kernel.Default (devapp090:2182)> <internal> <> <> <1366794208810> <BEA-000000> <WARN org.apache.zookeeper.ClientCnxn - Session 0x0 for server null, unexpected error, closing socket connection and attempting reconnect java.lang.IllegalArgumentException: No Configuration was registered that can handle the configuration named Client at com.bea.common.security.jdkutils.JAASConfiguration.getAppConfigurationEntry(JAASConfiguration.java:130) at org.apache.zookeeper.client.ZooKeeperSaslClient.<init>(ZooKeeperSaslClient.java:97) at org.apache.zookeeper.ClientCnxn$SendThread.startConnect(ClientCnxn.java:943) at org.apache.zookeeper.ClientCnxn$SendThread.run(ClientCnxn.java:993) >
Fail to run zookeeper client on Weblogic application server The problem in details is described here: http://comments.gmane.org/gmane.comp.java.zookeeper.user/2897 The provided link also contains a reference to fix implementation.
******
src.java.main.org.apache.zookeeper.client.ZooKeeperSaslClient.ZooKeeperSaslClient.ZooKeeperSaslClient(String), true
src.java.main.org.apache.zookeeper.client.ZooKeeperSaslClient.ZooKeeperSaslClient.clientTunneledAuthenticationInProgress(), true
#####
zookeeper-3.4.5
ZOOKEEPER-1667
https://issues.apache.org/jira/browse/ZOOKEEPER-1667
Watch event isn't handled correctly when a client reestablish to a server When a client reestablish to a server, it will send the watches which have not been triggered. But the code in DataTree does not handle it correctly. It is obvious, we just do not notice it scenario: 1) Client a set a data watch on /d, then disconnect, client b delete /d and create it again. When client a reestablish to zk, it will receive a NodeCreated rather than a NodeDataChanged. 2) Client a set a exists watch on /e(not exist), then disconnect, client b create /e. When client a reestablish to zk, it will receive a NodeDataChanged rather than a NodeCreated.
Watch event isn't handled correctly when a client reestablish to a server When a client reestablish to a server, it will send the watches which have not been triggered. But the code in does not handle it correctly. It is obvious, we just do not notice it scenario: 1) Client a set a data watch on /d, then disconnect, client b delete /d and create it again. When client a reestablish to zk, it will receive a rather than a 2) Client a set a exists watch on /e(not exist), then disconnect, client b create /e. When client a reestablish to zk, it will receive a rather than a
******
src.java.test.org.apache.zookeeper.test.WatchEventWhenAutoReset.WatchEventWhenAutoReset.process(WatchedEvent), false, new_method
src.java.test.org.apache.zookeeper.test.WatchEventWhenAutoReset.WatchEventWhenAutoReset.assertEvent(long, EventType), false, new_method
src.java.test.org.apache.zookeeper.test.WatchEventWhenAutoReset.WatchEventWhenAutoReset.createClient(QuorumUtil, int, EventsWatcher), false, new_method
src.java.test.org.apache.zookeeper.test.WatchEventWhenAutoReset.WatchEventWhenAutoReset.createClient(QuorumUtil, int), false, new_method
src.java.test.org.apache.zookeeper.test.WatchEventWhenAutoReset.WatchEventWhenAutoReset.testNodeDataChanged(), false, new_method
src.java.test.org.apache.zookeeper.test.WatchEventWhenAutoReset.WatchEventWhenAutoReset.testNodeCreated(), false, new_method
src.java.test.org.apache.zookeeper.test.WatchEventWhenAutoReset.WatchEventWhenAutoReset.testNodeDeleted(), false, new_method
src.java.test.org.apache.zookeeper.test.WatchEventWhenAutoReset.WatchEventWhenAutoReset.testNodeChildrenChanged(), false, new_method
src.java.main.org.apache.zookeeper.server.DataTree.DataTree.setWatches(long, List<String>, List<String>, List<String>, Watcher), true
#####
zookeeper-3.4.5
ZOOKEEPER-1666
https://issues.apache.org/jira/browse/ZOOKEEPER-1666
Avoid Reverse DNS lookup if the hostname in connection string is literal IP address. In our ENV, if the InetSocketAddress.getHostName() is called and the host name in the connection string are literal IP address, then the call will trigger a reverse DNS lookup which is very slow. And in this situation, the host name can simply set as the IP without causing any problem.
Avoid Reverse DNS lookup if the hostname in connection string is literal IP address. In our ENV, if the is called and the host name in the connection string are literal IP address, then the call will trigger a reverse DNS lookup which is very slow. And in this situation, the host name can simply set as the IP without causing any problem.
******
src.java.main.org.apache.zookeeper.client.StaticHostProvider.StaticHostProvider.resolveAndShuffle(Collection<InetSocketAddress>), true
src.java.test.org.apache.zookeeper.test.StaticHostProviderTest.StaticHostProviderTest.testLiteralIPNoReverseNS(), false, new_method
src.java.test.org.apache.zookeeper.test.StaticHostProviderTest.StaticHostProviderTest.getHostProviderUnresolved(byte), false, new_method
src.java.test.org.apache.zookeeper.test.StaticHostProviderTest.StaticHostProviderTest.getUnresolvedServerAddresses(byte), false, new_method
#####
zookeeper-3.4.5
ZOOKEEPER-1657
https://issues.apache.org/jira/browse/ZOOKEEPER-1657
Increased CPU usage by unnecessary SASL checks I did some profiling in one of our Java environments and found an interesting footprint in ZooKeeper. The SASL support seems to trigger a lot times on the client although it's not even in use. Is there a switch to disable SASL completely? The attached screenshot shows a 10-minute profiling session on one of our production Jetty servers. The Jetty server handles ~1k web requests per minute. The average response time per web request is a few milli seconds. The profiling was performed on a machine running for >24h. We noticed a significant CPU increase on our servers when deploying an update from ZooKeeper 3.3.2 to ZooKeeper 3.4.5. Thus, we started investigating. The screenshot shows that only 32% CPU time are spent in Jetty. In contrast, 65% are spend in ZooKeeper. A few notes/thoughts: ClientCnxn$SendThread.clientTunneledAuthenticationInProgress seems to be the culprit javax.security.auth.login.Configuration.getConfiguration seems to be called very often? There is quite a bit reflection involved in java.security.AccessController.doPrivileged No security manager is active in the JVM: I tend to place an if-check in the code before calling AccessController.doPrivileged. When no SM is installed, the runnable can be called directly which safes cycles.
Increased CPU usage by unnecessary SASL checks I did some profiling in one of our Java environments and found an interesting footprint in ZooKeeper. The SASL support seems to trigger a lot times on the client although it's not even in use. Is there a switch to disable SASL completely? The attached screenshot shows a 10-minute profiling session on one of our production Jetty servers. The Jetty server handles ~1k web requests per minute. The average response time per web request is a few milli seconds. The profiling was performed on a machine running for >24h. We noticed a significant CPU increase on our servers when deploying an update from ZooKeeper 3.3.2 to ZooKeeper 3.4.5. Thus, we started investigating. The screenshot shows that only 32% CPU time are spent in Jetty. In contrast, 65% are spend in ZooKeeper. A few notes/thoughts:   seems to be the culprit  seems to be called very often? There is quite a bit reflection involved in   No security manager is active in the JVM: I tend to place an if-check in the code before calling When no SM is installed, the runnable can be called directly which safes cycles.
******
src.java.main.org.apache.zookeeper.ClientCnxn.ClientCnxn.startConnect(), true
src.java.main.org.apache.zookeeper.ClientCnxn.ClientCnxn.clientTunneledAuthenticationInProgress(), true
src.java.main.org.apache.zookeeper.client.ZooKeeperSaslClient.ZooKeeperSaslClient.isEnabled(), false, new_method
src.java.test.org.apache.zookeeper.test.SaslClientTest.SaslClientTest.setUp(), false, new_method
src.java.test.org.apache.zookeeper.test.SaslClientTest.SaslClientTest.tearDown(), false, new_method
src.java.test.org.apache.zookeeper.test.SaslClientTest.SaslClientTest.testSaslClientDisabled(), false, new_method
#####
zookeeper-3.4.5
ZOOKEEPER-1648
https://issues.apache.org/jira/browse/ZOOKEEPER-1648
Fix WatcherTest in JDK7 JDK7 run unit tests in random order causing intermittent WatcherTest failure. The fix is to clean up static variable that interfere with other tests.
Fix in JDK7 JDK7 run unit tests in random order causing intermittent failure. The fix is to clean up static variable that interfere with other tests.
******
src.java.test.org.apache.zookeeper.test.WatcherTest.WatcherTest.setUp(), false, new_method
#####
zookeeper-3.4.5
ZOOKEEPER-1642
https://issues.apache.org/jira/browse/ZOOKEEPER-1642
Leader loading database twice The leader server currently loads the database before running leader election when trying to figure out the zxid it needs to use for the election and again when it starts leading. This is problematic for larger databases so we should remove the redundant load if possible. The code references are: getLastLoggedZxid() in QuorumPeer; loadData() in ZooKeeperServer.
Leader loading database twice The leader server currently loads the database before running leader election when trying to figure out the zxid it needs to use for the election and again when it starts leading. This is problematic for larger databases so we should remove the redundant load if possible. The code references are:
******
src.java.main.org.apache.zookeeper.server.ZooKeeperServer.ZooKeeperServer.loadData(), true
#####
zookeeper-3.4.5
ZOOKEEPER-1633
https://issues.apache.org/jira/browse/ZOOKEEPER-1633
Introduce a protocol version to connection initiation message Currently the first message a server sends to another server includes just one field - the server's id (long). This is in QuorumCnxManager.java. This makes changes to the information passed during this initial connection very difficult. This patch will change the first field of the message to be a protocol version (a negative number that can't be a server id). The second field will be the server id. The third field is number of bytes in the remainder of the message. A 3.4 server will read the first field as before, but if this is a negative number it will read the second field to find the server id, and then remove the remainder of the message from the stream. This will not affect 3.4 since 3.4 and earlier servers send just the server id (so the code in the patch will not run unless there is a server > 3.4 trying to connect). This will, however, provide the necessary flexibility for future releases as well as an upgrade path from 3.4
Introduce a protocol version to connection initiation message Currently the first message a server sends to another server includes just one field - the server's id (long). This is in This makes changes to the information passed during this initial connection very difficult. This patch will change the first field of the message to be a protocol version (a negative number that can't be a server id). The second field will be the server id. The third field is number of bytes in the remainder of the message. A 3.4 server will read the first field as before, but if this is a negative number it will read the second field to find the server id, and then remove the remainder of the message from the stream. This will not affect 3.4 since 3.4 and earlier servers send just the server id (so the code in the patch will not run unless there is a server > 3.4 trying to connect). This will, however, provide the necessary flexibility for future releases as well as an upgrade path from 3.4
******
src.java.main.org.apache.zookeeper.server.quorum.QuorumCnxManager.QuorumCnxManager.receiveConnection(Socket), true
src.java.test.org.apache.zookeeper.server.quorum.CnxManagerTest.CnxManagerTest.TestCnxManager(QuorumPeer), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.CnxManagerTest.CnxManagerTest.senderWorkerMapContains(Long), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.CnxManagerTest.CnxManagerTest.getSid(Message), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.CnxManagerTest.CnxManagerTest.getMsgString(Message), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.CnxManagerTest.CnxManagerTest.testCnxFromFutureVersion(), false, new_method
#####
zookeeper-3.4.5
ZOOKEEPER-1629
https://issues.apache.org/jira/browse/ZOOKEEPER-1629
testTransactionLogCorruption occasionally fails It seems that testTransactionLogCorruption is very flaky,for example fails here: https://builds.apache.org/job/ZooKeeper-trunk-jdk7/500/ https://builds.apache.org/job/ZooKeeper-trunk-jdk7/502/ https://builds.apache.org/job/ZooKeeper-trunk-jdk7/503/#showFailuresLink also fails for older builds (no longer on the website), for example all builds from 381 to 399.
occasionally fails It seems that is very flaky,for example fails here: https://builds.apache.org/job/ZooKeeper-trunk-jdk7/500/ https://builds.apache.org/job/ZooKeeper-trunk-jdk7/502/ https://builds.apache.org/job/ZooKeeper-trunk-jdk7/503/#showFailuresLink also fails for older builds (no longer on the website), for example all builds from 381 to 399.
******
src.java.test.org.apache.zookeeper.server.util.PortForwarder.PortForwarder.run(), false, test_method
src.java.test.org.apache.zookeeper.server.TruncateCorruptionTest.TruncateCorruptionTest.await(Check, long), false, test_method
src.java.test.org.apache.zookeeper.server.TruncateCorruptionTest.TruncateCorruptionTest.testTransactionLogCorruption(), false, test_method
src.java.test.org.apache.zookeeper.server.TruncateCorruptionTest.TruncateCorruptionTest.stopForwarding(List<PortForwarder>), true
src.java.test.org.apache.zookeeper.server.TruncateCorruptionTest.TruncateCorruptionTest.startForwarding(), true
src.java.test.org.apache.zookeeper.server.TruncateCorruptionTest.TruncateCorruptionTest.waitForConnection(ZooKeeper), true
src.java.test.org.apache.zookeeper.server.TruncateCorruptionTest.TruncateCorruptionTest.process(WatchedEvent), true
src.java.test.org.apache.zookeeper.server.TruncateCorruptionTest.TruncateCorruptionTest.ZkWatcher(String), true
src.java.test.org.apache.zookeeper.server.TruncateCorruptionTest.TruncateCorruptionTest.ZookeeperServerWrapper(int, int), true
src.java.test.org.apache.zookeeper.server.TruncateCorruptionTest.TruncateCorruptionTest.start(), true
src.java.test.org.apache.zookeeper.server.TruncateCorruptionTest.TruncateCorruptionTest.await(long), true
src.java.test.org.apache.zookeeper.server.TruncateCorruptionTest.TruncateCorruptionTest.stop(), true
src.java.test.org.apache.zookeeper.server.TruncateCorruptionTest.TruncateCorruptionTest.clean(), true
#####
zookeeper-3.4.5
ZOOKEEPER-1624
https://issues.apache.org/jira/browse/ZOOKEEPER-1624
PrepRequestProcessor abort multi-operation incorrectly We found this issue when trying to issue multiple instances of the following multi-op concurrently multi { 1. create sequential node /a- 2. create node /b } The expected result is that only the first multi-op request should success and the rest of request should fail because /b is already exist However, the reported result is that the subsequence multi-op failed because of sequential node creation failed which is not possible. Below is the return code for each sub-op when issuing 3 instances of the above multi-op asynchronously 1. ZOK, ZOK 2. ZOK, ZNODEEXISTS, 3. ZNODEEXISTS, ZRUNTIMEINCONSISTENCY, When I added more debug log. The cause is that PrepRequestProcessor rollback outstandingChanges of the second multi-op incorrectly causing sequential node name generation to be incorrect. Below is the sequential node name generated by PrepRequestProcessor 1. create /a-0001 2. create /a-0003 3. create /a-0001 The bug is getPendingChanges() method. In failed to copied ChangeRecord for the parent node ("/"). So rollbackPendingChanges() cannot restore the right previous change record of the parent node when aborting the second multi-op The impact of this bug is that sequential node creation on the same parent node may fail until the previous one is committed. I am not sure if there is other implication or not.
abort multi-operation incorrectly We found this issue when trying to issue multiple instances of the following multi-op concurrently multi The expected result is that only the first multi-op request should success and the rest of request should fail because /b is already exist However, the reported result is that the subsequence multi-op failed because of sequential node creation failed which is not possible. Below is the return code for each sub-op when issuing 3 instances of the above multi-op asynchronously When I added more debug log. The cause is that rollback of the second multi-op incorrectly causing sequential node name generation to be incorrect. Below is the sequential node name generated by  The bug is In failed to copied for the parent node ("/"). So cannot restore the right previous change record of the parent node when aborting the second multi-op The impact of this bug is that sequential node creation on the same parent node may fail until the previous one is committed. I am not sure if there is other implication or not.
******
src.java.test.org.apache.zookeeper.test.MultiAsyncTransactionTest.MultiAsyncTransactionTest.setUp(), false, new_method
src.java.test.org.apache.zookeeper.test.MultiAsyncTransactionTest.MultiAsyncTransactionTest.finishPendingOps(), false, new_method
src.java.test.org.apache.zookeeper.test.MultiAsyncTransactionTest.MultiAsyncTransactionTest.waitForPendingOps(int), false, new_method
src.java.test.org.apache.zookeeper.test.MultiAsyncTransactionTest.MultiAsyncTransactionTest.testSequentialNodeCreateInAsyncMulti(), false, new_method
src.java.main.org.apache.zookeeper.server.PrepRequestProcessor.PrepRequestProcessor.getPendingChanges(MultiTransactionRecord), true
#####
zookeeper-3.4.5
ZOOKEEPER-1622
https://issues.apache.org/jira/browse/ZOOKEEPER-1622
session ids will be negative in the year 2022 Someone decided to use a large number for their myid file. This cause session ids to go negative, and our software (Apache Accumulo) did not handle this very well. While diagnosing the problem, I noticed this in SessionImpl: public static long initializeNextSession(long id) { long nextSid = 0; nextSid = (System.currentTimeMillis() << 24) >> 8; nextSid = nextSid | (id <<56); return nextSid; } When the 40th bit in System.currentTimeMillis() is a one, sign extension will fill the upper 8 bytes of nextSid, and id will not make the session id unique. I recommend changing the right shift to the logical shift: public static long initializeNextSession(long id) { long nextSid = 0; nextSid = (System.currentTimeMillis() << 24) >>> 8; nextSid = nextSid | (id <<56); return nextSid; } But, we have until the year 2022 before we have to worry about it.
session ids will be negative in the year 2022 Someone decided to use a large number for their myid file. This cause session ids to go negative, and our software (Apache Accumulo) did not handle this very well. While diagnosing the problem, I noticed this in   When the 40th bit in is a one, sign extension will fill the upper 8 bytes of and id will not make the session id unique. I recommend changing the right shift to the logical shift:   But, we have until the year 2022 before we have to worry about it.
******
src.java.main.org.apache.zookeeper.server.SessionTrackerImpl.SessionTrackerImpl.initializeNextSession(long), true
#####
zookeeper-3.4.5
ZOOKEEPER-1610
https://issues.apache.org/jira/browse/ZOOKEEPER-1610
Some classes are using == or != to compare Long/String objects instead of .equals() The classes org.apache.zookeeper.client.ZooKeeperSaslClient.java and org.apache.zookeeper.server.quorum.flexible.QuorumHierarchical.java compare Strings and/or Longs using referential equality. Usually, this is not a problem because the Longs are cached and Strings are interned, but I myself had problems with those kind of comparisons in the past because one production JVM didn't reused the objects.
Some classes are using == or != to compare Long/String objects instead of  The classes compare Strings and/or Longs using referential equality. Usually, this is not a problem because the Longs are cached and Strings are interned, but I myself had problems with those kind of comparisons in the past because one production JVM didn't reused the objects.
******
src.java.main.org.apache.zookeeper.server.quorum.flexible.QuorumHierarchical.QuorumHierarchical.equals(Object), true
src.java.main.org.apache.zookeeper.client.ZooKeeperSaslClient.ZooKeeperSaslClient.respondToServer(byte[], ClientCnxn), true
#####
zookeeper-3.4.5
ZOOKEEPER-1606
https://issues.apache.org/jira/browse/ZOOKEEPER-1606
intermittent failures in ZkDatabaseCorruptionTest on jenkins ZkDatabaseCorruptionTest is failing intermittently on jenkins with: "Error Message: the last server is not the leader" Seeing this on jdk7/openjdk7/solaris - 3 times in the last month. https://builds.apache.org/view/S-Z/view/ZooKeeper/job/ZooKeeper-trunk-openjdk7/2/testReport/junit/org.apache.zookeeper.test/ZkDatabaseCorruptionTest/testCorruption/
intermittent failures in on jenkins is failing intermittently on jenkins with: "Error Message: the last server is not the leader" Seeing this on - 3 times in the last month. https://builds.apache.org/view/S-Z/view/ZooKeeper/job/ZooKeeper-trunk-openjdk7/2/testReport/junit/org.apache.zookeeper.test/ZkDatabaseCorruptionTest/testCorruption/
******
src.java.test.org.apache.zookeeper.test.ZkDatabaseCorruptionTest.ZkDatabaseCorruptionTest.testCorruption(), false, test_method
#####
zookeeper-3.4.5
ZOOKEEPER-1603
https://issues.apache.org/jira/browse/ZOOKEEPER-1603
StaticHostProviderTest testUpdateClientMigrateOrNot hangs StaticHostProviderTest method testUpdateClientMigrateOrNot hangs forever. On my laptop getHostName for 10.10.10.* takes 5+ seconds per call. As a result this method effectively runs forever. Every time I run this test it hangs. Consistent.
hangs method hangs forever. On my laptop for 10.10.10.* takes 5+ seconds per call. As a result this method effectively runs forever. Every time I run this test it hangs. Consistent.
******
src.java.main.org.apache.zookeeper.client.StaticHostProvider.StaticHostProvider.resolveAndShuffle(Collection<InetSocketAddress>), true
src.java.main.org.apache.zookeeper.client.StaticHostProvider.StaticHostProvider.updateServerList(Collection<InetSocketAddress>, InetSocketAddress), true
src.java.main.org.apache.zookeeper.client.StaticHostProvider.StaticHostProvider.StaticHostProvider(Collection<InetSocketAddress>), true
src.java.test.org.apache.zookeeper.test.StaticHostProviderTest.StaticHostProviderTest.testNextGoesRound(), false, test_method
src.java.test.org.apache.zookeeper.test.StaticHostProviderTest.StaticHostProviderTest.testNextGoesRoundAndSleeps(), false, test_method
src.java.test.org.apache.zookeeper.test.StaticHostProviderTest.StaticHostProviderTest.testNextDoesNotSleepForZero(), false, test_method
src.java.test.org.apache.zookeeper.test.StaticHostProviderTest.StaticHostProviderTest.testTwoConsequitiveCallsToNextReturnDifferentElement(), false, test_method
src.java.test.org.apache.zookeeper.test.StaticHostProviderTest.StaticHostProviderTest.testOnConnectDoesNotReset(), false, test_method
src.java.test.org.apache.zookeeper.test.StaticHostProviderTest.StaticHostProviderTest.testUpdateClientMigrateOrNot(), false, test_method
src.java.test.org.apache.zookeeper.test.StaticHostProviderTest.StaticHostProviderTest.testUpdateMigrationGoesRound(), false, test_method
src.java.test.org.apache.zookeeper.test.StaticHostProviderTest.StaticHostProviderTest.testUpdateLoadBalancing(), false, test_method
src.java.test.org.apache.zookeeper.test.StaticHostProviderTest.StaticHostProviderTest.getHostProvider(int), true
src.java.test.org.apache.zookeeper.test.StaticHostProviderTest.StaticHostProviderTest.getServerAddresses(int), true
#####
zookeeper-3.4.5
ZOOKEEPER-1578
https://issues.apache.org/jira/browse/ZOOKEEPER-1578
org.apache.zookeeper.server.quorum.Zab1_0Test failed due to hard code with 33556 port org.apache.zookeeper.server.quorum.Zab1_0Test was failed both with SUN JDK and open JDK. [junit] Running org.apache.zookeeper.server.quorum.Zab1_0Test [junit] Tests run: 8, Failures: 0, Errors: 1, Time elapsed: 18.334 sec [junit] Test org.apache.zookeeper.server.quorum.Zab1_0Test FAILED Zab1_0Test log: Zab1_0Test log: 2012-07-11 23:17:15,579 [myid:] - INFO [main:Leader@427] - Shutdown called java.lang.Exception: shutdown Leader! reason: end of test at org.apache.zookeeper.server.quorum.Leader.shutdown(Leader.java:427) at org.apache.zookeeper.server.quorum.Zab1_0Test.testLastAcceptedEpoch(Zab1_0Test.java:211) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:48) 2012-07-11 23:17:15,584 [myid:] - ERROR [main:Leader@139] - Couldn't bind to port 33556 java.net.BindException: Address already in use at java.net.PlainSocketImpl.bind(PlainSocketImpl.java:402) at java.net.ServerSocket.bind(ServerSocket.java:328) at java.net.ServerSocket.bind(ServerSocket.java:286) at org.apache.zookeeper.server.quorum.Leader.<init>(Leader.java:137) at org.apache.zookeeper.server.quorum.Zab1_0Test.createLeader(Zab1_0Test.java:810) at org.apache.zookeeper.server.quorum.Zab1_0Test.testLeaderInElectingFollowers(Zab1_0Test.java:224) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 2012-07-11 23:17:20,202 [myid:] - ERROR [LearnerHandler-bdvm039.svl.ibm.com/9.30.122.48:40153:LearnerHandler@559] - Unex pected exception causing shutdown while sock still open java.net.SocketTimeoutException: Read timed out at java.net.SocketInputStream.read(SocketInputStream.java:129) at java.io.BufferedInputStream.fill(BufferedInputStream.java:218) at java.io.BufferedInputStream.read(BufferedInputStream.java:237) at java.io.DataInputStream.readInt(DataInputStream.java:370) at org.apache.jute.BinaryInputArchive.readInt(BinaryInputArchive.java:63) at org.apache.zookeeper.server.quorum.QuorumPacket.deserialize(QuorumPacket.java:83) at org.apache.jute.BinaryInputArchive.readRecord(BinaryInputArchive.java:108) at org.apache.zookeeper.server.quorum.LearnerHandler.run(LearnerHandler.java:291) 2012-07-11 23:17:20,203 [myid:] - WARN [LearnerHandler-bdvm039.svl.ibm.com/9.30.122.48:40153:LearnerHandler@569] - **** GOODBYE bdvm039.svl.ibm.com/9.30.122.48:40153 ******** 2012-07-11 23:17:20,204 [myid:] - INFO [Thread-20:Leader@421] - Shutting down 2012-07-11 23:17:20,204 [myid:] - INFO [Thread-20:Leader@427] - Shutdown called java.lang.Exception: shutdown Leader! reason: lead ended this failure seems 33556 port is already used, but it is not in use with command check in fact. There is a hard code in unit test, we can improve it with code patch.
was failed both with SUN JDK and open was failed both with SUN JDK and open JDK Shutdown called Couldn't bind to port 33556 Address already in use this failure seems 33556 port is already used, but it is not in use with command check in fact. There is a hard code in unit test, we can improve it with code patch.
******
src.java.test.org.apache.zookeeper.server.quorum.Zab1_0Test.Zab1_0Test.prepareLeader(File, QuorumPeer), false, test_method
#####
zookeeper-3.4.5
ZOOKEEPER-1573
https://issues.apache.org/jira/browse/ZOOKEEPER-1573
Unable to load database due to missing parent node While replaying txnlog on data tree, the server has a code to detect missing parent node. This code block was last modified as part of ZOOKEEPER-1333. In our production, we found a case where this check is return false positive. The sequence of txns is as follows: zxid 1: create /prefix/a zxid 2: create /prefix/a/b zxid 3: delete /prefix/a/b zxid 4: delete /prefix/a The server start capturing snapshot at zxid 1. However, by the time it traversing the data tree down to /prefix, txn 4 is already applied and /prefix have no children. When the server restore from snapshot, it process txnlog starting from zxid 2. This txn generate missing parent error and the server refuse to start up. The same check allow me to discover bug in ZOOKEEPER-1551, but I don't know if we have any option beside removing this check to solve this issue.
Unable to load database due to missing parent node While replaying on data tree, the server has a code to detect missing parent node. This code block was last modified as part of ZOOKEEPER-1333. In our production, we found a case where this check is return false positive. The sequence of is as follows: However, by the time it traversing the data tree down to /prefix, 4 is already applied and /prefix have no children. When the server restore from snapshot, it process starting from 2. This generate missing parent error and the server refuse to start up. The same check allow me to discover bug in ZOOKEEPER-1551, but I don't know if we have any option beside removing this check to solve this issue.
******
src.java.main.org.apache.zookeeper.server.persistence.FileTxnSnapLog.FileTxnSnapLog.processTransaction(TxnHeader, DataTree, Map<Long, Integer>, Record), true
src.java.test.org.apache.zookeeper.test.LoadFromLogTest.LoadFromLogTest.testRestore(), false, test_method
src.java.test.org.apache.zookeeper.test.LoadFromLogTest.LoadFromLogTest.testRestoreWithTransactionErrors(), false, test_method
src.java.test.org.apache.zookeeper.test.LoadFromLogTest.LoadFromLogTest.testReloadSnapshotWithMissingParent(), false, new_method
src.java.test.org.apache.zookeeper.test.LoadFromLogTest.LoadFromLogTest.getConnectedZkClient(), false, new_method
#####
zookeeper-3.4.5
ZOOKEEPER-1564
https://issues.apache.org/jira/browse/ZOOKEEPER-1564
Allow JUnit test build with IBM Java The org.apache.zookeeper.test.ClientBase, org.apache.zookeeper.test.ClientTest, org.apache.zookeeper.test.QuorumBase and org.apache.zookeeper.test.QuorumUtil classes import the com.sun.management.UnixOperatingSystemMXBean class, that fail to build when using IBM Java 6 SR 11. This issue is resolved by new class OSMXBean class proposed in JIRA's ZOOKEEPER-1474. The class OSMXBean (org.apache.zookeeper.server.util.OSMXBean) is a wrapper for the implementation of com.sun.management.UnixOperatingSystemMXBean, and decides to use the SUN API or its own implementation depending on the runtime (vendor) used.
Allow JUnit test build with IBM Java classes import the class, that fail to build when using IBM Java 6 SR 11. This issue is resolved by new class proposed in JIRA's ZOOKEEPER-1474. The class is a wrapper for the implementation of, and decides to use the SUN API or its own implementation depending on the runtime (vendor) used.
******
src.java.test.org.apache.zookeeper.test.ClientTest.ClientTest.testClientCleanup(), false, test_method
src.java.test.org.apache.zookeeper.test.ClientBase.ClientBase.setUp(), false, test_method
src.java.test.org.apache.zookeeper.test.ClientBase.ClientBase.tearDown(), true
src.java.test.org.apache.zookeeper.test.QuorumBase.QuorumBase.setUp(boolean), false, test_method
src.java.test.org.apache.zookeeper.test.QuorumBase.QuorumBase.tearDown(), true
src.java.test.org.apache.zookeeper.test.QuorumUtil.QuorumUtil.shutdown(int), false, test_method
#####
zookeeper-3.4.5
ZOOKEEPER-1558
https://issues.apache.org/jira/browse/ZOOKEEPER-1558
Leader should not snapshot uncommitted state Leader currently takes a snapshot when it calls loadData in the beginning of the lead() method. The loaded data, however, may contain uncommitted state.
Leader should not snapshot uncommitted state Leader currently takes a snapshot when it calls in the beginning of the method. The loaded data, however, may contain uncommitted state.
******
src.java.main.org.apache.zookeeper.server.SyncRequestProcessor.SyncRequestProcessor.setRandRoll(int), false, new_method
src.java.main.org.apache.zookeeper.server.SyncRequestProcessor.SyncRequestProcessor.setSnapCount(int), true
src.java.main.org.apache.zookeeper.server.SyncRequestProcessor.SyncRequestProcessor.run(), true
src.java.main.org.apache.zookeeper.server.ZooKeeperServer.ZooKeeperServer.loadData(), true
src.java.test.org.apache.zookeeper.server.quorum.Zab1_0Test.Zab1_0Test.testDirtySnapshot(), false, new_method
#####
zookeeper-3.4.5
ZOOKEEPER-1552
https://issues.apache.org/jira/browse/ZOOKEEPER-1552
Enable sync request processor in Observer Observer doesn't forward its txns to SyncRequestProcessor. So it never persists the txns onto disk or periodically creates snapshots. This increases the start-up time since it will get the entire snapshot if the observer has be running for a long time.
Enable  in doesn't forward its txns to . So it never persists the txns onto disk or periodically creates snapshots. This increases the start-up time since it will get the entire snapshot if the observer has be running for a long time.
******
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.getSyncEnabled(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.setSyncEnabled(boolean), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.QuorumPeerConfig.parseProperties(Properties), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.QuorumPeerConfig.getSyncEnabled(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerMain.QuorumPeerMain.runFromConfig(QuorumPeerConfig), true
src.java.main.org.apache.zookeeper.server.quorum.ObserverZooKeeperServer.ObserverZooKeeperServer.ObserverZooKeeperServer(FileTxnSnapLog, QuorumPeer, ZKDatabase), false, refactoring
src.java.main.org.apache.zookeeper.server.quorum.ObserverZooKeeperServer.ObserverZooKeeperServer.commitRequest(Request), true
src.java.main.org.apache.zookeeper.server.quorum.ObserverZooKeeperServer.ObserverZooKeeperServer.setupRequestProcessors(), true
src.java.main.org.apache.zookeeper.server.SyncRequestProcessor.SyncRequestProcessor.run(), true
src.java.main.org.apache.zookeeper.server.SyncRequestProcessor.SyncRequestProcessor.flush(LinkedList<Request>), true
src.java.main.org.apache.zookeeper.server.SyncRequestProcessor.SyncRequestProcessor.shutdown(), true
#####
zookeeper-3.4.5
ZOOKEEPER-1551
https://issues.apache.org/jira/browse/ZOOKEEPER-1551
Observers ignore txns that come after snapshot and UPTODATE  In Learner.java, txns which comes after the learner has taken the snapshot (after NEWLEADER packet) are stored in packetsNotCommitted. The follower has special logic to apply these txns at the end of syncWithLeader() method. However, the observer will ignore these txns completely, causing data inconsistency.
Observers ignore txns that come after snapshot and UPTODATE  In txns which comes after the learner has taken the snapshot (after NEWLEADER packet) are stored in. The follower has special logic to apply these txns at the end of method. However, the observer will ignore these txns completely, causing data inconsistency.
******
src.java.main.org.apache.zookeeper.server.quorum.Leader.Leader.startForwarding(LearnerHandler, long), true
src.java.main.org.apache.zookeeper.server.quorum.Learner.Learner.syncWithLeader(long), true
src.java.test.org.apache.zookeeper.server.quorum.Zab1_0Test.Zab1_0Test.testObserverConversation(ObserverConversation), false, refactoring
src.java.test.org.apache.zookeeper.server.quorum.Zab1_0Test.Zab1_0Test.waitForChange(), false, refactoring
src.java.test.org.apache.zookeeper.server.quorum.Zab1_0Test.Zab1_0Test.process(WatchedEvent), false, refactoring
src.java.test.org.apache.zookeeper.server.quorum.Zab1_0Test.Zab1_0Test.changed(), false, refactoring
src.java.test.org.apache.zookeeper.server.quorum.Zab1_0Test.Zab1_0Test.testNormalObserverRun(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.Zab1_0Test.Zab1_0Test.ConversableObserver(QuorumPeer, ObserverZooKeeperServer), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.Zab1_0Test.Zab1_0Test.setLeaderSocketAddress(InetSocketAddress), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.Zab1_0Test.Zab1_0Test.findLeader(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.Zab1_0Test.Zab1_0Test.createObserver(File, QuorumPeer), false, new_method
#####
zookeeper-3.4.5
ZOOKEEPER-1535
https://issues.apache.org/jira/browse/ZOOKEEPER-1535
ZK Shell/Cli re-executes last command on exit In the ZK 3.4.3 release's version of zkCli.sh, the last command that was executed is re-executed when you ctrl+d out of the shell. In the snippet below, ls is executed, and then ctrl+d is triggered (inserted below to illustrate), the output from ls appears again, due to the command being re-run. [zk: zookeeper.example.com:2181(CONNECTED) 0] ls /blah [foo] [zk: zookeeper.example.com:2181(CONNECTED) 1] <ctrl+d> [foo] $
ZK Shell/Cli re-executes last command on exit In the ZK 3.4.3 release's version of, the last command that was executed is re-executed when you ctrl+d out of the shell. In the snippet below, ls is executed, and then ctrl+d is triggered (inserted below to illustrate), the output from ls appears again, due to the command being re-run.
******
src.java.main.org.apache.zookeeper.ZooKeeperMain.ZooKeeperMain.run(), true
#####
zookeeper-3.4.5
ZOOKEEPER-1495
https://issues.apache.org/jira/browse/ZOOKEEPER-1495
ZK client hangs when using a function not available on the server. This happens for example when using zk#multi with a 3.4 client but a 3.3 server. The issue seems to be on the server side: the servers drops the packets with an unknown OpCode in ZooKeeperServer#submitRequest public void submitRequest(Request si) { // snip try { touch(si.cnxn); boolean validpacket = Request.isValid(si.type); // ===> Check on case OpCode.* if (validpacket) { // snip } else { LOG.warn("Dropping packet at server of type " + si.type); // if invalid packet drop the packet. } } catch (MissingSessionException e) { if (LOG.isDebugEnabled()) { LOG.debug("Dropping request: " + e.getMessage()); } } } The solution discussed in ZOOKEEPER-1381 would be to get an exception on the client side then & close the session.
ZK client hangs when using a function not available on the server. This happens for example when using zk#multi with a 3.4 client but a 3.3 server. The issue seems to be on the server side: the servers drops the packets with an unknown The solution discussed in ZOOKEEPER-1381 would be to get an exception on the client side then & close the session.
******
src.java.test.org.apache.zookeeper.test.ClientTest.ClientTest.testNonExistingOpCode(), false, new_method
src.java.test.org.apache.zookeeper.TestableZooKeeper.TestableZooKeeper.submitRequest(RequestHeader, Record, Record, WatchRegistration), false, new_method
src.java.main.org.apache.zookeeper.server.UnimplementedRequestProcessor.UnimplementedRequestProcessor.processRequest(Request), false, new_method
src.java.main.org.apache.zookeeper.server.UnimplementedRequestProcessor.UnimplementedRequestProcessor.shutdown(), false, new_method
src.java.main.org.apache.zookeeper.server.ZooKeeperServer.ZooKeeperServer.submitRequest(Request), true
#####
zookeeper-3.4.5
ZOOKEEPER-1478
https://issues.apache.org/jira/browse/ZOOKEEPER-1478
Small bug in QuorumTest.testFollowersStartAfterLeader( ) The following code appears in QuorumTest.testFollowersStartAfterLeader( ): for (int i = 0; i < 30; i++) { try { zk.create("/test", "test".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); break; } catch(KeeperException.ConnectionLossException e) { Thread.sleep(1000); } // test fails if we still can't connect to the quorum after 30 seconds. Assert.fail("client could not connect to reestablished quorum: giving up after 30+ seconds."); } From the comment it looks like the intention was to try to reconnect 30 times and only then trigger the Assert, but that's not what this does. After we fail to connect once and Thread.sleep is executed, Assert.fail will be executed without retrying create.
Small bug in The following code appears in   From the comment it looks like the intention was to try to reconnect 30 times and only then trigger the Assert, but that's not what this does. After we fail to connect once and is executed, will be executed without retrying create.
******
src.java.test.org.apache.zookeeper.test.QuorumTest.QuorumTest.testFollowersStartAfterLeader(), false, test_method
#####
zookeeper-3.4.5
ZOOKEEPER-1474
https://issues.apache.org/jira/browse/ZOOKEEPER-1474
Cannot build Zookeeper with IBM Java: use of Sun MXBean classes zookeeper.server.NIOServerCnxn and zookeeper.server.NettyServerCnxn imports com.sun.management.UnixOperatingSystemMXBean . This OperatingSystemMXBean class is not implemented by IBM or open java. In my case, I need IBM Java so I can run zookeeper in Power ppc64 servers.
Cannot build Zookeeper with IBM Java: use of  classes imports. This class is not implemented by IBM or open java. In my case, I need IBM Java so I can run zookeeper in Power ppc64 servers.
******
src.java.main.org.apache.zookeeper.server.NIOServerCnxn.NIOServerCnxn.commandRun(), true
src.java.main.org.apache.zookeeper.server.util.OSMXBean.OSMXBean.OSMXBean(), false, new_method
src.java.main.org.apache.zookeeper.server.util.OSMXBean.OSMXBean.getUnix(), false, new_method
src.java.main.org.apache.zookeeper.server.util.OSMXBean.OSMXBean.getOSUnixMXBeanMethod(String), false, new_method
src.java.main.org.apache.zookeeper.server.util.OSMXBean.OSMXBean.getOpenFileDescriptorCount(), false, new_method
src.java.main.org.apache.zookeeper.server.util.OSMXBean.OSMXBean.getMaxFileDescriptorCount(), false, new_method
src.java.test.org.apache.zookeeper.test.OSMXBeanTest.OSMXBeanTest.initialize(), false, new_method
src.java.test.org.apache.zookeeper.test.OSMXBeanTest.OSMXBeanTest.testGetUnix(), false, new_method
src.java.test.org.apache.zookeeper.test.OSMXBeanTest.OSMXBeanTest.testGetOpenFileDescriptorCount(), false, new_method
src.java.test.org.apache.zookeeper.test.OSMXBeanTest.OSMXBeanTest.testGetMaxFileDescriptorCount(), false, new_method
src.java.main.org.apache.zookeeper.server.NettyServerCnxn.NettyServerCnxn.commandRun(), true
#####
zookeeper-3.4.5
ZOOKEEPER-1459
https://issues.apache.org/jira/browse/ZOOKEEPER-1459
Standalone ZooKeeperServer is not closing the transaction log files on shutdown When shutdown the standalone ZK server, its only clearing the zkdatabase and not closing the transaction log streams. When tries to delete the temporary files in unit tests on windows, its failing. ZooKeeperServer.java if (zkDb != null) { zkDb.clear(); } Suggestion to close the zkDb as follows, this inturn will take care transaction logs: if (zkDb != null) { zkDb.clear(); try { zkDb.close(); } catch (IOException ie) { LOG.warn("Error closing logs ", ie); } }
is not closing the transaction log files on shutdownWhen shutdown the standalone ZK server, its only clearing the zkdatabase and not closing the transaction log streams. When tries to delete the temporary files in unit tests on windows, its failing. Suggestion to close the zkDb as follows, this inturn will take care transaction logs
******
src.java.main.org.apache.zookeeper.server.ZooKeeperServerMain.ZooKeeperServerMain.runFromConfig(ServerConfig), true
src.java.test.org.apache.zookeeper.server.ZooKeeperServerMainTest.ZooKeeperServerMainTest.MainThread(int), false, refactoring
src.java.test.org.apache.zookeeper.server.ZooKeeperServerMainTest.ZooKeeperServerMainTest.shutdown(), false, method_signature
src.java.test.org.apache.zookeeper.server.ZooKeeperServerMainTest.ZooKeeperServerMainTest.deleteDirs(), false, new_method
src.java.test.org.apache.zookeeper.server.ZooKeeperServerMainTest.ZooKeeperServerMainTest.delete(File), false, new_method
src.java.test.org.apache.zookeeper.server.ZooKeeperServerMainTest.ZooKeeperServerMainTest.testStandalone(), false, test_method
#####
zookeeper-3.4.5
ZOOKEEPER-1448
https://issues.apache.org/jira/browse/ZOOKEEPER-1448
Node+Quota creation in transaction log can crash leader startup Hi, I've found a bug in zookeeper related to quota creation which can shutdown zookeeper leader on startup. Steps to reproduce: 1. create /quota_bug 2. setquota -n 10000 /quota_bug 3. stop the whole ensemble (the previous operations should be in the transaction log) 4. start all the servers 5. the elected leader will shutdown with an exception (Missing stat node for count /zookeeper/quota/quota_bug/zookeeper_ stats) I've debugged a bit what happening and I found the following problem: On startup each server loads the last snapshot and replays the last transaction log. While doing this it fills up the pTrie variable of the DataTree with the path of the nodes which have quota. After the leader is elected the leader servers loads the snapshot and last transaction log but it doesn't clean up the pTrie variable. This means it still contains the "/quota_bug" path. Now when the "create /quota_bug" is processed from the transaction log the DataTree already thinks that the quota nodes ("/zookeeper/quota/quota_bug/zookeeper_limits" and "/zookeeper/quota/quota_bug/zookeeper_stats") are created but those node creation actually comes later in the transaction log. This leads to the missing stat node exception. I think clearing the pTrie should solve this problem.
Node+Quota creation in transaction log can crash leader startup Hi, I've found a bug in zookeeper related to quota creation which can shutdown zookeeper leader on startup. Steps to reproduce: 1. create /quota_bug 2. setquota -n 10000 /quota_bug 3. stop the whole ensemble (the previous operations should be in the transaction log) 4. start all the servers 5. the elected leader will shutdown with an exception (Missing stat node for I've debugged a bit what happening and I found the following problem: On startup each server loads the last snapshot and replays the last transaction log. While doing this it fills up the variable of the with the path of the nodes which have quota. After the leader is elected the leader servers loads the snapshot and last transaction log but it doesn't clean up the variable. This means it still contains the  path. Now when the is processed from the transaction log the already thinks that the quota nodes are created but those node creation actually comes later in the transaction log. This leads to the missing stat node exception. I think clearing the should solve this problem.
******
src.java.main.org.apache.zookeeper.common.PathTrie.PathTrie.clear(), false, new_method
src.java.test.org.apache.zookeeper.test.DataTreeTest.DataTreeTest.testPathTrieClearOnDeserialize(), false, new_method
src.java.main.org.apache.zookeeper.server.DataTree.DataTree.deserialize(InputArchive, String), true
#####
zookeeper-3.4.5
ZOOKEEPER-1414
https://issues.apache.org/jira/browse/ZOOKEEPER-1414
QuorumPeerMainTest.testQuorum, testBadPackets are failing intermittently The QuorumPeerMainTest.testQuorum, testBadPackets testcases are failing intermittently due to the wrong ZKClient usage pattern. Saw the following ConnectionLoss on 3.4 version: KeeperErrorCode = ConnectionLoss for /foo_q1 org.apache.zookeeper.KeeperException$ConnectionLossException: KeeperErrorCode = ConnectionLoss for /foo_q1 at org.apache.zookeeper.KeeperException.create(KeeperException.java:90) at org.apache.zookeeper.KeeperException.create(KeeperException.java:42) at org.apache.zookeeper.ZooKeeper.create(ZooKeeper.java:657) at org.apache.zookeeper.server.quorum.QuorumPeerMainTest.testBadPackets(QuorumPeerMainTest.java:212) Since the ZooKeeper connection is happening in async way through ClientCnxn, the client should wait for the 'KeeperState.SyncConnected' event before start using. But these test cases are not waiting for the connection like: ZooKeeper zk = new ZooKeeper("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT, this); zk.create("/foo_q1", "foobar1".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
The are failing intermittently due to the wrong ZKClient usage pattern. Saw the following ConnectionLoss on 3.4 version: Since the ZooKeeper connection is happening in async way through, the client should wait for the event before start using. But these test cases are not waiting for the connection like:
******
src.java.test.org.apache.zookeeper.server.quorum.QuorumPeerMainTest.QuorumPeerMainTest.testQuorum(), false, test_method
src.java.test.org.apache.zookeeper.server.quorum.QuorumPeerMainTest.QuorumPeerMainTest.testBadPackets(), false, test_method
#####
zookeeper-3.4.5
ZOOKEEPER-1388
https://issues.apache.org/jira/browse/ZOOKEEPER-1388
Client side 'PathValidation' is missing for the multi-transaction api. Multi ops: Op.create(path,..), Op.delete(path, ..), Op.setData(path, ..), Op.check(path, ...) apis are not performing the client side path validation and the call will go to the server side and is throwing exception back to the client. It would be good to provide ZooKeeper client side path validation for the multi transaction apis. Presently its getting err codes from the server, which is also not properly conveying the cause. For example: When specified invalid znode path in Op.create, it giving the following exception. This will not be useful to know the actual cause. org.apache.zookeeper.KeeperException$NoNodeException: KeeperErrorCode = NoNode at org.apache.zookeeper.KeeperException.create(KeeperException.java:115) at org.apache.zookeeper.ZooKeeper.multiInternal(ZooKeeper.java:1174) at org.apache.zookeeper.ZooKeeper.multi(ZooKeeper.java:1115)
Client side is missing for the multi-transaction api. Multi ops: apis are not performing the client side path validation and the call will go to the server side and is throwing exception back to the client. It would be good to provide ZooKeeper client side path validation for the multi transaction apis. Presently its getting err codes from the server, which is also not properly conveying the cause. For example: When specified invalid znode path in it giving the following exception. This will not be useful to know the actual cause.
******
src.java.main.org.apache.zookeeper.CreateMode.CreateMode.fromFlag(int), false, refactoring
src.java.test.org.apache.zookeeper.test.MultiTransactionTest.MultiTransactionTest.multiHavingErrors(ZooKeeper, Iterable<Op>, List<Integer>, String), false, new_method
src.java.test.org.apache.zookeeper.test.MultiTransactionTest.MultiTransactionTest.testInvalidPath(), false, new_method
src.java.test.org.apache.zookeeper.test.MultiTransactionTest.MultiTransactionTest.testBlankPath(), false, new_method
src.java.test.org.apache.zookeeper.test.MultiTransactionTest.MultiTransactionTest.testInvalidCreateModeFlag(), false, new_method
src.java.main.org.apache.zookeeper.Op.Op.validate(), false, new_method
src.java.main.org.apache.zookeeper.ZooKeeper.ZooKeeper.multi(Iterable<Op>), true
src.java.main.org.apache.zookeeper.ZooKeeper.ZooKeeper.multi(Iterable<Op>, MultiCallback, Object), true
src.java.main.org.apache.zookeeper.ZooKeeper.ZooKeeper.generateMultiTransaction(Iterable<Op>), true
#####
zookeeper-3.4.5
ZOOKEEPER-1387
https://issues.apache.org/jira/browse/ZOOKEEPER-1387
Wrong epoch file created It looks like line 443 in QuorumPeer [1] may need to change from: writeLongToFile(CURRENT_EPOCH_FILENAME, acceptedEpoch); to writeLongToFile(ACCEPTED_EPOCH_FILENAME, acceptedEpoch); I only noticed this reading the code, so I may be wrong and I don't know yet if/how this affects the runtime. [1] https://github.com/apache/zookeeper/blob/trunk/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java#L443
Wrong epoch file created It looks like may need to change from:  I only noticed this reading the code, so I may be wrong and I don't know yet if/how this affects the runtime.
******
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.loadDataBase(), true
src.java.test.org.apache.zookeeper.server.quorum.Zab1_0Test.Zab1_0Test.readContentsOfFile(File), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.Zab1_0Test.Zab1_0Test.testInitialAcceptedCurrent(), false, new_method
#####
zookeeper-3.4.5
ZOOKEEPER-1382
https://issues.apache.org/jira/browse/ZOOKEEPER-1382
Zookeeper server holds onto dead/expired session ids in the watch data structures I've observed that zookeeper server holds onto expired session ids in the watcher data structures. The result is the wchp command reports session ids that cannot be found through cons/dump and those expired session ids sit there maybe until the server is restarted. Here are snippets from the client and the server logs that lead to this state, for one particular session id 0x134485fd7bcb26f - There are 4 servers in the zookeeper cluster - 223, 224, 225 (leader), 226 and I'm using ZkClient to connect to the cluster From the application log - application.log.2012-01-26-325.gz:2012/01/26 04:56:36.177 INFO [ClientCnxn] [main-SendThread(223.prod:12913)] [application Session establishment complete on server 223.prod/172.17.135.38:12913, sessionid = 0x134485fd7bcb26f, negotiated timeout = 6000 application.log.2012-01-27.gz:2012/01/27 09:52:37.714 INFO [ClientCnxn] [main-SendThread(223.prod:12913)] [application] Client session timed out, have not heard from server in 9827ms for sessionid 0x134485fd7bcb26f, closing socket connection and attempting reconnect application.log.2012-01-27.gz:2012/01/27 09:52:38.191 INFO [ClientCnxn] [main-SendThread(226.prod:12913)] [application] Unable to reconnect to ZooKeeper service, session 0x134485fd7bcb26f has expired, closing socket connection On the leader zk, 225 - zookeeper.log.2012-01-27-leader-225.gz:2012-01-27 09:52:34,010 - INFO [SessionTracker:ZooKeeperServer@314] - Expiring session 0x134485fd7bcb26f, timeout of 6000ms exceeded zookeeper.log.2012-01-27-leader-225.gz:2012-01-27 09:52:34,010 - INFO [ProcessThread:-1:PrepRequestProcessor@391] - Processed session termination for sessionid: 0x134485fd7bcb26f On the server, the client was initially connected to, 223 - zookeeper.log.2012-01-26-223.gz:2012-01-26 04:56:36,173 - INFO [CommitProcessor:1:NIOServerCnxn@1580] - Established session 0x134485fd7bcb26f with negotiated timeout 6000 for client /172.17.136.82:45020 zookeeper.log.2012-01-27-223.gz:2012-01-27 09:52:34,018 - INFO [CommitProcessor:1:NIOServerCnxn@1435] - Closed socket connection for client /172.17.136.82:45020 which had sessionid 0x134485fd7bcb26f Here are the log snippets from 226, which is the server, the client reconnected to, before getting session expired event - 2012-01-27 09:52:38,190 - INFO [NIOServerCxn.Factory:0.0.0.0/0.0.0.0:12913:NIOServerCnxn@770] - Client attempting to renew session 0x134485fd7bcb26f at /172.17.136.82:49367 2012-01-27 09:52:38,191 - INFO [QuorumPeer:/0.0.0.0:12913:NIOServerCnxn@1573] - Invalid session 0x134485fd7bcb26f for client /172.17.136.82:49367, probably expired 2012-01-27 09:52:38,191 - INFO [NIOServerCxn.Factory:0.0.0.0/0.0.0.0:12913:NIOServerCnxn@1435] - Closed socket connection for client /172.17.136.82:49367 which had sessionid 0x134485fd7bcb26f wchp output from 226, taken on 01/30 - nnarkhed-ld:zk-cons-wchp-2012013000 nnarkhed$ grep 0x134485fd7bcb26f 226.*wchp | wc -l 3 wchp output from 223, taken on 01/30 - nnarkhed-ld:zk-cons-wchp-2012013000 nnarkhed$ grep 0x134485fd7bcb26f 223.*wchp | wc -l 0 cons output from 223 and 226, taken on 01/30 - nnarkhed-ld:zk-cons-wchp-2012013000 nnarkhed$ grep 0x134485fd7bcb26f 226.*cons | wc -l 0 nnarkhed-ld:zk-cons-wchp-2012013000 nnarkhed$ grep 0x134485fd7bcb26f 223.*cons | wc -l 0 So, what seems to have happened is that the client was able to re-register the watches on the new server (226), after it got disconnected from 223, inspite of having an expired session id. In NIOServerCnxn, I saw that after suspecting that a session is expired, a server removes the cnxn and its watches from its internal data structures. But before that it allows more requests to be processed even if the session is expired - // Now that the session is ready we can start receiving packets synchronized (this.factory) { sk.selector().wakeup(); enableRecv(); } } catch (Exception e) { LOG.warn("Exception while establishing session, closing", e); close(); } I wonder if the client somehow sneaked in the set watches, right after the server removed the connection through removeCnxn() API ?
Zookeeper server holds onto dead/expired session ids in the watch data structures I've observed that zookeeper server holds onto expired session ids in the watcher data structures. The result is the wchp command reports session ids that cannot be found through cons/dump and those expired session ids sit there maybe until the server is restarted. Here are snippets from the client and the server logs that lead to this state, for one particular session id 0x134485fd7bcb26f - There are 4 servers in the zookeeper cluster - 223, 224, 225 (leader), 226 and I'm using ZkClient to connect to the cluster From the application log - On the leader zk, 225 - On the server, the client was initially connected to, 223 - Here are the log snippets from 226, which is the server, the client reconnected to, before getting session expired event - So, what seems to have happened is that the client was able to re-register the watches on the new server (226), after it got disconnected from 223, inspite of having an expired session id. In I saw that after suspecting that a session is expired, a server removes the cnxn and its watches from its internal data structures. But before that it allows more requests to be processed even if the session is expired - I wonder if the client somehow sneaked in the set watches, right after the server removed the connection through API ?
******
src.java.test.org.apache.zookeeper.server.MockNIOServerCnxn.MockNIOServerCnxn.MockNIOServerCnxn(ZooKeeperServer, SocketChannel, SelectionKey, NIOServerCnxnFactory, SelectorThread), false, new_method
src.java.test.org.apache.zookeeper.server.MockNIOServerCnxn.MockNIOServerCnxn.doIO(SelectionKey), false, new_method
src.java.test.org.apache.zookeeper.server.MockNIOServerCnxn.MockNIOServerCnxn.isSocketOpen(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.WatchLeakTest.WatchLeakTest.WatchLeakTest(boolean), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.WatchLeakTest.WatchLeakTest.Collection(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.WatchLeakTest.WatchLeakTest.testWatchesLeak(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.WatchLeakTest.WatchLeakTest.MyFollower(QuorumPeer, FollowerZooKeeperServer), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.WatchLeakTest.WatchLeakTest.SelectableChannel(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.WatchLeakTest.WatchLeakTest.selector(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.WatchLeakTest.WatchLeakTest.isValid(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.WatchLeakTest.WatchLeakTest.cancel(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.WatchLeakTest.WatchLeakTest.interestOps(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.WatchLeakTest.WatchLeakTest.interestOps(int), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.WatchLeakTest.WatchLeakTest.readyOps(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.WatchLeakTest.WatchLeakTest.createWatchesMessage(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.WatchLeakTest.WatchLeakTest.createConnRequest(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.WatchLeakTest.WatchLeakTest.createClientSocketChannel(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.WatchLeakTest.WatchLeakTest.createValidateSessionPacketResponse(boolean), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.WatchLeakTest.WatchLeakTest.createValidateSessionPacket(), false, new_method
src.java.main.org.apache.zookeeper.server.NIOServerCnxn.NIOServerCnxn.isSocketOpen(), false, refactoring
src.java.main.org.apache.zookeeper.server.NIOServerCnxn.NIOServerCnxn.doIO(SelectionKey), false, refactoring
src.java.test.org.apache.zookeeper.MockPacket.MockPacket.MockPacket(RequestHeader, ReplyHeader, Record, Record, WatchRegistration), false, new_method
src.java.test.org.apache.zookeeper.MockPacket.MockPacket.MockPacket(RequestHeader, ReplyHeader, Record, Record, WatchRegistration, boolean), false, new_method
src.java.test.org.apache.zookeeper.MockPacket.MockPacket.createAndReturnBB(), false, new_method
src.java.main.org.apache.zookeeper.server.ZooKeeperServer.ZooKeeperServer.finishSessionInit(ServerCnxn, boolean), true
src.java.test.org.apache.zookeeper.server.MockSelectorThread.MockSelectorThread.MockSelectorThread(NIOServerCnxnFactory), false, new_method
src.java.test.org.apache.zookeeper.server.MockSelectorThread.MockSelectorThread.addInterestOpsUpdateRequest(SelectionKey), false, new_method
#####
zookeeper-3.4.5
ZOOKEEPER-1379
https://issues.apache.org/jira/browse/ZOOKEEPER-1379
'printwatches, redo, history and connect '. client commands always print usage. This is not necessary while executing the commands: 'printwatches, redo, history and connect usage is getting print .basically we are printing usage if user has entered the command wrong but in these commands case every time usage is getting print. eg [zk: localhost:2181(CONNECTED) 0] printwatches printwatches is on ZooKeeper -server host:port cmd args connect host:port get path [watch] ls path [watch] set path data [version] delquota [-n|-b] path quit printwatches on|off create [-s] [-e] path data acl stat path [watch] close ls2 path [watch] history listquota path setAcl path acl getAcl path sync path redo cmdno addauth scheme auth delete path [version] setquota -n|-b val path
'printwatches, redo, history and connect '. client commands always print usage. This is not necessary while executing the commands: 'printwatches, redo, history and connect usage is getting print .basically we are printing usage if user has entered the command wrong but in these commands case every time usage is getting print. eg
******
src.java.main.org.apache.zookeeper.ZooKeeperMain.ZooKeeperMain.processZKCmd(MyCommandOptions), true
src.java.test.org.apache.zookeeper.ZooKeeperTest.ZooKeeperTest.testCliCommandsNotEchoingUsage(), false, test_method
#####
zookeeper-3.4.5
ZOOKEEPER-1179
https://issues.apache.org/jira/browse/ZOOKEEPER-1179
NettyServerCnxn does not properly close socket on 4 letter word requests When calling a 4-letter-word to a server configured to use NettyServerCnxnFactory, the factory will not properly cancel all the keys and close the socket after sending the response for the 4lw. The close request will throw this exception, and the thread will not shut down: 2011-09-13 12:14:17,546 - WARN [New I/O server worker #1-1:NettyServerCnxnFactory$CnxnChannelHandler@117] - Exception caught [id: 0x009300cc, /1.1.1.1:38542 => /139.172.114.138:2181] EXCEPTION: java.io.IOException: A non-blocking socket operation could not be completed immediately java.io.IOException: A non-blocking socket operation could not be completed immediately at sun.nio.ch.SocketDispatcher.close0(Native Method) at sun.nio.ch.SocketDispatcher.preClose(SocketDispatcher.java:44) at sun.nio.ch.SocketChannelImpl.implCloseSelectableChannel(SocketChannelImpl.java:684) at java.nio.channels.spi.AbstractSelectableChannel.implCloseChannel(AbstractSelectableChannel.java:201) at java.nio.channels.spi.AbstractInterruptibleChannel.close(AbstractInterruptibleChannel.java:97) at org.jboss.netty.channel.socket.nio.NioWorker.close(NioWorker.java:593) at org.jboss.netty.channel.socket.nio.NioServerSocketPipelineSink.handleAcceptedSocket(NioServerSocketPipelineSink.java:119) at org.jboss.netty.channel.socket.nio.NioServerSocketPipelineSink.eventSunk(NioServerSocketPipelineSink.java:76) at org.jboss.netty.channel.Channels.close(Channels.java:720) at org.jboss.netty.channel.AbstractChannel.close(AbstractChannel.java:208) at org.apache.zookeeper.server.NettyServerCnxn.close(NettyServerCnxn.java:116) at org.apache.zookeeper.server.NettyServerCnxn.cleanupWriterSocket(NettyServerCnxn.java:241) at org.apache.zookeeper.server.NettyServerCnxn.access$0(NettyServerCnxn.java:231) at org.apache.zookeeper.server.NettyServerCnxn$CommandThread.run(NettyServerCnxn.java:314) at org.apache.zookeeper.server.NettyServerCnxn$CommandThread.start(NettyServerCnxn.java:305) at org.apache.zookeeper.server.NettyServerCnxn.checkFourLetterWord(NettyServerCnxn.java:674) at org.apache.zookeeper.server.NettyServerCnxn.receiveMessage(NettyServerCnxn.java:791) at org.apache.zookeeper.server.NettyServerCnxnFactory$CnxnChannelHandler.processMessage(NettyServerCnxnFactory.java:217) at org.apache.zookeeper.server.NettyServerCnxnFactory$CnxnChannelHandler.messageReceived(NettyServerCnxnFactory.java:141) at org.jboss.netty.channel.Channels.fireMessageReceived(Channels.java:274) at org.jboss.netty.channel.Channels.fireMessageReceived(Channels.java:261) at org.jboss.netty.channel.socket.nio.NioWorker.read(NioWorker.java:350) at org.jboss.netty.channel.socket.nio.NioWorker.processSelectedKeys(NioWorker.java:281) at org.jboss.netty.channel.socket.nio.NioWorker.run(NioWorker.java:201) at org.jboss.netty.util.internal.IoWorkerRunnable.run(IoWorkerRunnable.java:46) at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) at java.lang.Thread.run(Thread.java:619)
does not properly close socket on 4 letter word requests When calling a 4-letter-word to a server configured to use the factory will not properly cancel all the keys and close the socket after sending the response for the 4lw. The close request will throw this exception, and the thread will not shut down: A non-blocking socket operation could not be completed immediately A non-blocking socket operation could not be completed immediately at
******
src.java.test.org.apache.zookeeper.server.NettyServerCnxnTest.NettyServerCnxnTest.testSendCloseSession(), false, new_method
src.java.test.org.apache.zookeeper.server.NettyServerCnxnTest.NettyServerCnxnTest.setUp(), false, new_method
src.java.main.org.apache.zookeeper.server.NettyServerCnxn.NettyServerCnxn.sendBuffer(ByteBuffer), true
#####
zookeeper-3.4.5
ZOOKEEPER-1096
https://issues.apache.org/jira/browse/ZOOKEEPER-1096
Leader communication should listen on specified IP, not wildcard address Server should specify the local address that is used for leader communication and leader election (and not use the default of listening on all interfaces). This is similar to the clientPortAddress parameter that was added a year ago. After reviewing the code, we can't think of a reason why only the port would be used with the wildcard interface, when servers are already connecting specifically to that interface anyway. I have submitted a patch, but it does not account for all leader election algorithms. Probably should have an option to toggle this, for backwards compatibility, although it seems like it would be a bug if this change broke things. There is some more information about making it an option here: http://mail-archives.apache.org/mod_mbox/hadoop-zookeeper-dev/201008.mbox/%3CAANLkTikkT97Djqt3CU=H2+7Gnj_4p28hgCXjh345HiyN@mail.gmail.com%3E
Leader communication should listen on specified IP, not wildcard address Server should specify the local address that is used for leader communication and leader election (and not use the default of listening on all interfaces). This is similar to the parameter that was added a year ago. After reviewing the code, we can't think of a reason why only the port would be used with the wildcard interface, when servers are already connecting specifically to that interface anyway. I have submitted a patch, but it does not account for all leader election algorithms. Probably should have an option to toggle this, for backwards compatibility, although it seems like it would be a bug if this change broke things. There is some more information about making it an option here: http://mail-archives.apache.org/mod_mbox/hadoop-zookeeper-dev/201008.mbox/%3CAANLkTikkT97Djqt3CU=H2+7Gnj_4p28hgCXjh345HiyN@mail.gmail.com%3E
******
src.java.test.org.apache.zookeeper.test.LENonTerminateTest.LENonTerminateTest.MockQuorumPeer(Map<Long, QuorumServer>, File, File, int, int, long, int, int, int), false, test_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.QuorumPeer(Map<Long, QuorumServer>, File, File, int, long, int, int, int, ServerCnxnFactory), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.QuorumPeer(Map<Long, QuorumServer>, File, File, int, long, int, int, int, ServerCnxnFactory, QuorumVerifier, String), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.QuorumPeer(Map<Long, QuorumServer>, File, File, int, long, int, int, int, ServerCnxnFactory, QuorumVerifier, String), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.QuorumPeer(Map<Long, QuorumServer>, File, File, int, int, long, int, int, int, QuorumVerifier), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.getQuorumListenOnAllIPs(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeer.QuorumPeer.setQuorumListenOnAllIPs(boolean), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.Leader.Leader.Leader(QuorumPeer, LeaderZooKeeperServer), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumCnxManager.QuorumCnxManager.run(), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.QuorumPeerConfig.parseProperties(Properties), true
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerConfig.QuorumPeerConfig.getQuorumListenOnAllIPs(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.QuorumPeerMain.QuorumPeerMain.runFromConfig(QuorumPeerConfig), true
#####
zookeeper-3.4.5
ZOOKEEPER-87
https://issues.apache.org/jira/browse/ZOOKEEPER-87
Follower does not shut itself down if its too far behind the leader. Currently, the follower if lagging behind keeps sending pings to the leader it will stay alive and will keep getting further and further behind the leader. The follower should shut itself down if it is not able to keep up to the leader within some limit so that gurantee of updates can be made to the clients connected to different servers.
Follower does not shut itself down if its too far behind the leader. Currently, the follower if lagging behind keeps sending pings to the leader it will stay alive and will keep getting further and further behind the leader. The follower should shut itself down if it is not able to keep up to the leader within some limit so that gurantee of updates can be made to the clients connected to different servers.
******
src.java.test.org.apache.zookeeper.test.QuorumTest.QuorumTest.testNoLogBeforeLeaderEstablishment(), false, test_method
src.java.test.org.apache.zookeeper.test.QuorumUtil.QuorumUtil.QuorumUtil(int), false, test_method
src.java.test.org.apache.zookeeper.test.QuorumUtil.QuorumUtil.QuorumUtil(int), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.LearnerHandler.LearnerHandler.start(), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.LearnerHandler.LearnerHandler.updateProposal(long, long), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.LearnerHandler.LearnerHandler.updateAck(long), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.LearnerHandler.LearnerHandler.check(long), false, new_method
src.java.main.org.apache.zookeeper.server.quorum.LearnerHandler.LearnerHandler.sendPackets(), true
src.java.main.org.apache.zookeeper.server.quorum.LearnerHandler.LearnerHandler.run(), true
src.java.main.org.apache.zookeeper.server.quorum.LearnerHandler.LearnerHandler.ping(), true
src.java.test.org.apache.zookeeper.server.quorum.Zab1_0Test.Zab1_0Test.testTxnTimeout(), false, new_method
src.java.test.org.apache.zookeeper.server.quorum.Zab1_0Test.Zab1_0Test.createFollower(File, QuorumPeer), false, refactoring
#####
