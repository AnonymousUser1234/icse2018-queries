AspectJ
28974
99a873c3070bea836e8cd4bd33c610fb41efa2c6
"Compiler error when introducing a ""final"" field" The aspect below fails to compile with 1.1b2, producing the compilation error: -------------------- $ ajc com/ibm/amc/*.java com/ibm/amc/ejb/*.java d:/eclipse/runtime-workspace-ajsamples/Mock EJBs/com/ibm/amc/DemoBeanEJB.java:1: Cannot assign a value to the final field com.ibm.amc.DemoBean.ajc$interField$co m_ibm_amc$verbose !! no source information available !! 1 error --------------------------- package com.ibm.amc; import com.ibm.amc.ejb.SessionBean; /** * @author colyer * * To change this generated comment edit the template variable "typecomment": * Window&gt;Preferences&gt;Java&gt;Templates. * To enable and disable the creation of type comments go to * Window&gt;Preferences&gt;Java&gt;Code Generation. */ public aspect DemoBeanEJB { declare parents: DemoBean implements SessionBean; // THIS NEXT LINE IS THE CULPRIT static final boolean DemoBean.verbose = true; private transient String DemoBean.ctx; public void DemoBean.ejbActivate( ) { if ( verbose ) { System.out.println( "ejbActivate Called" ); } } } ------------------- Making the inter-type declaration non-final solves the problem...
"Compiler error when introducing a ""final"" field" The aspect below fails to compile with 1.1b2, producing the compilation error: -------------------- $ ajc Cannot assign a value to the final field !! no source information available !! 1 error --------------------------- /** * @author colyer * * To change this generated comment edit the template variable "": * Window&gt;Preferences&gt;Java&gt;Templates. * To enable and disable the creation of type comments go to * Window&gt;Preferences&gt;Java&gt;Code Generation. */  // THIS NEXT LINE IS THE CULPRIT ------------------- Making the inter-type declaration non-final solves the problem...
******
org.aspectj.matcher/src/org/aspectj/weaver/AjcMemberMaker.makePublic(int),False,comments|refactoring
org.aspectj.matcher/src/org/aspectj/weaver/AjcMemberMaker.interFieldClassField(ResolvedMember, TypeX),True
org.aspectj.matcher/src/org/aspectj/weaver/AjcMemberMaker.interFieldInterfaceField(ResolvedMember field, TypeX onClass, TypeX),True
org.aspectj.matcher/src/org/aspectj/weaver/AjcMemberMaker.interMethod(ResolvedMember, UnresolvedType, boolean),True
#####
AspectJ
28919
27817202657a92778479de5063097086b511385b
waever tries to weave into native methods ... If you don't find the exception below in a bug, please add a new bug To make the bug a priority, please include a test program that can reproduce this exception. bad non-abstract method with no code: private native int nativeMessagePumpInitialize() on public class plc.comm.pvi.PviCom$LinkEventHandlerImpl bad non-abstract method with no code: private native int nativeMessagePumpInitialize() on public class plc.comm.pvi.PviCom$LinkEventHandlerImpl java.lang.RuntimeException: bad non-abstract method with no code: private native int nativeMessagePumpInitialize() on public class plc.comm.pvi.PviCom$LinkEventHandlerImpl at org.aspectj.weaver.bcel.LazyMethodGen.&lt;init&gt;(Unknown Source) at org.aspectj.weaver.bcel.LazyClassGen.&lt;init&gt;(Unknown Source) at org.aspectj.weaver.bcel.BcelObjectType.getLazyClassGen(Unknown Source) at org.aspectj.weaver.bcel.BcelWeaver.weave(Unknown Source) at org.aspectj.weaver.bcel.BcelWeaver.weave(Unknown Source) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.weaveAndGenerateClassFiles (Unknown Source) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild (Unknown Source) at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(Unknown Source) at org.aspectj.tools.ajc.Main.run(Unknown Source) at org.aspectj.tools.ajc.Main.runMain(Unknown Source) at org.aspectj.tools.ajc.Main.main(Unknown Source)
waever tries to weave into native methods ... If you don't find the exception below in a bug, please add a new bug To make the bug a priority, please include a test program that can reproduce this exception. bad non-abstract method with no code: private native int  on public class bad non-abstract method with no code: private native int  on public class : bad non-abstract method with no code: 
******
weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.LazyMethodGen(Method, weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.LazyClassGen),True
weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.run(),True
weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.pack(),True
weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.killNops(),False,new_method
#####
AspectJ
29186
c1260e6b26b78f0f431b778cd8f22d3493e97f3f
ajc -emacssym chokes on pointcut that includes an intertype method This works fine without -emacssym, but dies with it: aspect Foo { before() : call(void foo()) { } void Bar.bar() { foo(); } } class Bar { void foo() { } } munger: (before: (persingleton(Foo) &amp;&amp; call(ExactTypePattern(void) foo()))-&gt;void Foo.ajc$before$Foo$f()) on method-call(void Bar.foo()) trouble in: public class Foo extends java.lang.Object: TypeMungers: [(BcelTypeMunger ResolvedTypeMunger(Method, void Bar.bar()))] public static final Foo ajc$perSingletonInstance static void &lt;clinit&gt;(): INVOKESTATIC Foo.ajc$clinit ()V (line 1) staticinitialization(void Foo.&lt;clinit&gt;()) | RETURN staticinitialization(void Foo.&lt;clinit&gt;()) end static void &lt;clinit&gt;() void &lt;init&gt;(): ALOAD_0 // Foo this (line 1) INVOKESPECIAL java.lang.Object.&lt;init&gt; ()V constructor-execution(void Foo.&lt;init&gt;()) | RETURN constructor-execution(void Foo.&lt;init&gt;()) end void &lt;init&gt;() public void ajc$before$Foo$f() AdviceAttribute(before, call(ExactTypePattern(void) foo()), 0, 15) : advice-execution(void Foo.ajc$before$Foo$f()) | RETURN (line 2) advice-execution(void Foo.ajc$before$Foo$f()) end public void ajc$before$Foo$f() public static void ajc$interMethod$Foo$Bar$bar(Bar) EffectiveSignatureAttribute(void Bar.bar(), method-execution) : method-execution(void Bar.bar()) | ALOAD_0 // Bar arg0 (line 3) | method-call(void Bar.foo()) | | GETSTATIC Foo.ajc$perSingletonInstance LFoo; | | INVOKEVIRTUAL Foo.ajc$before$Foo$f ()V | | INVOKEVIRTUAL Bar.foo ()V | method-call(void Bar.foo()) | RETURN method-execution(void Bar.bar()) end public static void ajc$interMethod$Foo$Bar$bar(Bar) public static void ajc$interMethodDispatch1$Foo$Bar$bar(Bar) EffectiveSignatureAttribute(void Bar.bar(), method-call) : ALOAD_0 // Bar arg0 INVOKEVIRTUAL Bar.ajc$interMethodDispatch2$$bar ()V RETURN end public static void ajc$interMethodDispatch1$Foo$Bar$bar(Bar) public static Foo aspectOf() org.aspectj.weaver.AjAttribute$AjSynthetic@f8f7db : GETSTATIC Foo.ajc$perSingletonInstance LFoo; ARETURN end public static Foo aspectOf() public static boolean hasAspect() org.aspectj.weaver.AjAttribute$AjSynthetic@5856a5 : GETSTATIC Foo.ajc$perSingletonInstance LFoo; IFNULL L0 ICONST_1 IRETURN L0: ICONST_0 IRETURN end public static boolean hasAspect() private static void ajc$clinit() org.aspectj.weaver.AjAttribute$AjSynthetic@c39a20 : NEW Foo DUP INVOKESPECIAL Foo.&lt;init&gt; ()V PUTSTATIC Foo.ajc$perSingletonInstance LFoo; RETURN end private static void ajc$clinit() end public class Foo Exception thrown from AspectJ 1.1b2 This might be logged as a bug already -- see the bug database at http://dev.eclipse.org (product: AspectJ, component: compiler) Bugs for exceptions thrown have titles File:line from the top stack, e.g., "SomeFile.java:243" If you don't find the exception below in a bug, please add a new bug To make the bug a priority, please include a test program that can reproduce this exception. null java.lang.NullPointerException at org.aspectj.weaver.AsmAdaptor.findOrCreateBodyNode(Unknown Source) at org.aspectj.weaver.AsmAdaptor.getNode(Unknown Source) at org.aspectj.weaver.AsmAdaptor.noteMunger(Unknown Source) at org.aspectj.weaver.Shadow.implementMungers(Unknown Source) at org.aspectj.weaver.Shadow.implement(Unknown Source) at org.aspectj.weaver.bcel.BcelClassWeaver.implement(Unknown Source) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(Unknown Source) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(Unknown Source) at org.aspectj.weaver.bcel.BcelWeaver.weave(Unknown Source) at org.aspectj.weaver.bcel.BcelWeaver.weave(Unknown Source) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.weaveAndGenerateClassFiles(Unknown Source) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(Unknown Source) at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(Unknown Source) at org.aspectj.tools.ajc.Main.run(Unknown Source) at org.aspectj.tools.ajc.Main.runMain(Unknown Source) at org.aspectj.tools.ajc.Main.main(Unknown Source) 1 fail|abort
ajc -emacssym chokes on pointcut that includes an intertype method This works fine without -emacssym, but dies with it: This might be logged as a bug already -- see the bug database at Bugs for exceptions thrown have titles File:line from the top stack, e.g., ":243" If you don't find the exception below in a bug, please add a new bug To make the bug a priority, please include a test program that can reproduce this exception. null 1 fail|abort
******
weaver/src/org/aspectj/weaver/ResolvedTypeX.isSynthetic(),False,new_method
org.aspectj.matcher/src/org/aspectj/weaver/Shadow.implementMungers(),True
weaver/src/org/aspectj/weaver/bcel/BcelWeaver.weave(UnwovenClassFile, BcelObjectType),True
asm.src.org.aspectj.asm.StructureModel.findClassInNodes(Collection, String),False,new_method
asm.src.org.aspectj.asm.StructureModel.visit(MemberTypeDeclaration, ClassScope),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.endVisit(LocalTypeDeclaration, BlockScope),False,new_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.visit(AnonymousLocalTypeDeclaration, BlockScope),False,new_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.endVisit(AnonymousLocalTypeDeclaration, BlockScope),False,new_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.findEnclosingClass(Stack),False,new_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.visit(MethodDeclaration, ClassScope),True
weaver/src/org/aspectj/weaver/AsmAdaptor.getNode(model, Advice),True
weaver/src/org/aspectj/weaver/AsmAdaptor.getNode(model, Shadow),True
weaver/src/org/aspectj/weaver/AsmAdaptor.findOrCreateBodyNode(ProgramElementNode,Member,Shadow),False,comments
weaver/src/org/aspectj/weaver/AsmAdaptor.findMemberInClass(classNode, Member),True
org.aspectj.matcher/src/org/aspectj/weaver/Lint,True
#####
AspectJ
29769
85a827a7f269a18a0c80802811bbc2aa3766c2e4
Ajde does not support new AspectJ 1.1 compiler options The org.aspectj.ajde.BuildOptionsAdapter interface does not yet support the new AspectJ 1.1 compiler options. These need to be added to the interface, any old or renamed options deprecated, and then the correct processing needs to happen within Ajde to pass these options to the compiler. This enhancement is needed by the various IDE projects for there AspectJ 1.1 support.
Ajde does not support new AspectJ 1.1 compiler options The interface does not yet support the new AspectJ 1.1 compiler options. These need to be added to the interface, any old or renamed options deprecated, and then the correct processing needs to happen within Ajde to pass these options to the compiler. This enhancement is needed by the various IDE projects for there AspectJ 1.1 support.
******
ajde/testdata/figures-coverage/figures/Figure,False,test
ajde/testsrc/org/aspectj/ajde/AjdeTests,False,test
ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserProperties.getInJars(),False,new_method
ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserProperties.getOutJar(),False,new_method
ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserProperties.getSourceRoots(),False,new_method
ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserProperties.getAspectPath(),False,new_method
ajde/src/org/aspectj/ajde/BuildOptionsAdapter.getUseJavacMode(),False,comments
ajde/src/org/aspectj/ajde/BuildOptionsAdapter.getWorkingOutputPath(),False,comments
ajde/src/org/aspectj/ajde/BuildOptionsAdapter.getPreprocessMode(),False,comments
ajde/src/org/aspectj/ajde/BuildOptionsAdapter.getCharacterEncoding(),False,comments
ajde/src/org/aspectj/ajde/BuildOptionsAdapter.getSourceOnePointFourMode(),False,comments
ajde/src/org/aspectj/ajde/BuildOptionsAdapter.getLenientSpecMode(),False,comments
ajde/src/org/aspectj/ajde/BuildOptionsAdapter.getStrictSpecMode(),False,comments
ajde/src/org/aspectj/ajde/BuildOptionsAdapter.getPortingMode(),False,comments
ajde/src/org/aspectj/ajde/BuildOptionsAdapter.getComplianceLevel(),False,new_method
ajde/src/org/aspectj/ajde/BuildOptionsAdapter.getSourceCompatibilityLevel(),False,new_method
ajde/src/org/aspectj/ajde/BuildOptionsAdapter.getWarnings(),False,new_method
ajde/src/org/aspectj/ajde/BuildOptionsAdapter.getDebugLevel(),False,new_method
ajde/src/org/aspectj/ajde/BuildOptionsAdapter.getNoImportError(),False,new_method
ajde/src/org/aspectj/ajde/BuildOptionsAdapter.getPreserveAllLocals(),False,new_method
ajde/src/org/aspectj/ajde/ProjectPropertiesAdapter.getInJars(),False,new_method
ajde/src/org/aspectj/ajde/ProjectPropertiesAdapter.getOutJar(),False,new_method
ajde/src/org/aspectj/ajde/ProjectPropertiesAdapter.getSourceRoots(),False,new_method
ajde/src/org/aspectj/ajde/ProjectPropertiesAdapter.getAspectPath(),False,new_method
/ajde/src/org/aspectj/ajde/internal/AspectJBuildManager.getFormattedOptionsString(BuildOptionsAdapter buildOptions, ProjectPropertiesAdapter),True
/ajde/src/org/aspectj/ajde/internal/AspectJBuildManager.formatSet(Set),False,new_method
/ajde/src/org/aspectj/ajde/internal/AspectJBuildManager.formatOptionalString(String),False,new_method
ajde/src/org/aspectj/ajde/internal/CompilerAdapter.configureBuildOptions(AjBuildConfig, BuildOptionsAdapter),False,new_method
ajde/src/org/aspectj/ajde/internal/CompilerAdapter.genBuildConfig(String),True
ajde/src/org/aspectj/ajde/internal/CompilerAdapter.configureBuildOptions(config, BuildOptionsAdapter),False,new_method
ajde/src/org/aspectj/ajde/internal/CompilerAdapter.disableWarnings(Map),False,new_method
ajde/src/org/aspectj/ajde/internal/CompilerAdapter.enableWarnings(Map, Set),False,new_method
ajde/src/org/aspectj/ajde/internal/CompilerAdapter.configureNonStandardOptions(AjBuildConfig, BuildOptionsAdapter),False,new_method
ajde/src/org/aspectj/ajde/internal/CompilerAdapter.configureProjectOptions(AjBuildConfig, ProjectPropertiesAdapter),False,new_method
ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.getUseJavacMode() ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.setUseJavacMode(boolean value),False,comments
ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.getWorkingOutputPath(),False,comments
ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.setWorkingDir(String path),False,comments
ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.getPreprocessMode(),False,comments
ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.setPreprocessMode(boolean),False,comments
ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.getSourceOnePointFourMode(),False,new_method
ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.setSourceOnePointFourMode(boolean),False,new_method
ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.getLenientSpecMode(),False,new_method
ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.setLenientSpecMode(boolean),False,new_method
ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.getStrictSpecMode(),False,new_method
ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.setStrictSpecMode(boolean),False,new_method
ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.getPortingMode(),False,new_method
ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.setPortingMode(boolean),False,new_method
/org/aspectj/ajde/ui/internal/AjcBuildOptions.getComplianceLevel(),False,new_method
/org/aspectj/ajde/ui/internal/AjcBuildOptions.setComplianceLevel(String),False,new_method
/org/aspectj/ajde/ui/internal/AjcBuildOptions.getSourceCompatibilityLevel(),False,new_method
/org/aspectj/ajde/ui/internal/AjcBuildOptions.setSourceCompatibilityLevel(String),False,new_method
/org/aspectj/ajde/ui/internal/AjcBuildOptions.getWarnings(),False,new_method
/org/aspectj/ajde/ui/internal/AjcBuildOptions.setWarnings(Set),False,new_method
/org/aspectj/ajde/ui/internal/AjcBuildOptions.getDebugLevel(),False,new_method
/org/aspectj/ajde/ui/internal/AjcBuildOptions.getNoImportError(),False,new_method
/org/aspectj/ajde/ui/internal/AjcBuildOptions.setNoImportError(boolean),False,new_method
/org/aspectj/ajde/ui/internal/AjcBuildOptions.getPreserveAllLocals(),False,new_method
/org/aspectj/ajde/ui/internal/AjcBuildOptions.setPreserveAllLocals(boolean),False,new_method
/org/aspectj/ajde/ui/internal/AjcBuildOptions.toWarningSet(String),False,new_method
/org/aspectj/ajde/ui/internal/AjcBuildOptions.fromWarningSet(Set),False,new_method
/org/aspectj/ajde/ui/internal/AjcBuildOptions.toDegubSet(String),False,new_method
/org/aspectj/ajde/ui/internal/AjcBuildOptions.fromDebugSet(Set),False,new_method
ajde/testsrc/org/aspectj/ajde/BuildOptionsTest.testVerboseMode(),False,new_method|test_method
ajde/testsrc/org/aspectj/ajde/BuildOptionsTest.testNonStandardOptions(),False,new_method|test_method
ajde/testsrc/org/aspectj/ajde/BuildOptionsTest.testComplianceLevel(),False,new_method|test_method
ajde/testsrc/org/aspectj/ajde/BuildOptionsTest.testSourceCompatibilityLevel(),False,new_method|test_method
ajde/testsrc/org/aspectj/ajde/BuildOptionsTest.testWarnings(),False,new_method|test_method
ajde/testsrc/org/aspectj/ajde/BuildOptionsTest.testDebugLevel(),False,new_method|test_method
ajde/testsrc/org/aspectj/ajde/BuildOptionsTest.testNoImportError(),False,new_method|test_method
ajde/testsrc/org/aspectj/ajde/BuildOptionsTest.testPreserveLocals(),False,new_method|test_method
ajde/testsrc/org/aspectj/ajde/NullIdeManager.init(),False,new_method|test_method
ajde/testsrc/org/aspectj/ajde/NullIdeProperties.getClasspath(),False,test_method
ajde/testsrc/org/aspectj/ajde/NullIdeProperties.setInJars(Set),False,new_method|test_method
ajde/testsrc/org/aspectj/ajde/NullIdeProperties.getInJars(),False,new_method|test_method
ajde/testsrc/org/aspectj/ajde/NullIdeProperties.setOutJar(String),False,new_method|test_method
ajde/testsrc/org/aspectj/ajde/NullIdeProperties.getOutJar(),False,new_method|test_method
ajde/testsrc/org/aspectj/ajde/NullIdeProperties.setSourceRoots(Set),False,new_method|test_method
ajde/testsrc/org/aspectj/ajde/NullIdeProperties.getSourceRoots(),False,new_method|test_method
ajde/testsrc/org/aspectj/ajde/NullIdeProperties.setAspectPath(Set),False,new_method|test_method
ajde/testsrc/org/aspectj/ajde/NullIdeProperties.getAspectPath(),False,new_method|test_method
ajde/testsrc/org/aspectj/ajde/StructureModelRegressionTest.test(),False,test_method
ajde/testsrc/org/aspectj/ajde/StructureModelRegressionTest.structureNodesEqual(StructureNode, StructureNode),False,new_method|test_method
ajde/testsrc/org/aspectj/ajde/StructureModelTest.testFieldInitializerCorrespondence(),False,test_method
ajde/testsrc/org/aspectj/ajde/StructureModelTest.testFileNodeFind(),False,test_method
ajde/testsrc/org/aspectj/ajde/StructureModelTest.testMainClassNodeInfo(),False,test_method),False,test_method
ajde/testsrc/org/aspectj/ajde/ui/StructureViewManagerTest.testFreshStructureModelCreation(),False,test_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.parseOption(String, LinkedList),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.AjBuildConfig(),False,new_method
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.testXlint(),False,test_method
#####
AspectJ
29959
3e2801ad504e8f6b3fa7b50a42bf2706994e1727
super call in intertype method declaration body causes VerifyError AspectJ Compiler 1.1beta4 This program: aspect Foo { void A.foo() { } void B.foo() { super.foo(); } } class A { } class B extends A { } class Main { public static void main(String[] args) { new B(); } } causes this error at runtime: Exception in thread "main" java.lang.VerifyError: (class: B, method: ajc$superDispatch$B$foo signature: ()V) Illegal use of nonvirtual function call at Main.main(Foo.java:11) Note that foo is never even called; the error happens at load time when the new B() expression causes class B to be loaded. There's no error if either one of the foo methods is declared in its class directly. This is kind of a showstopper... --Doug
super call in intertype method declaration body causes VerifyError AspectJ Compiler 1.1beta4 This program: causes this error at runtime: Exception in thread "main": (class: B, method: : ()V) Illegal use of nonvirtual function call at Note that foo is never even called; the error happens at load time when the new B() expression causes class B to be loaded. There's no error if either one of the foo methods is declared in its class directly. This is kind of a showstopper... --Doug
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMethodBinding,True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeConstructorDeclaration.makePreMethod(ClassScope, ExplicitConstructorCall),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeConstructorDeclaration.makeAttribute(EclipseWorld),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/SuperFixerVisitor.endVisit(MessageSend, BlockScope),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMethodBinding.getAccessMethod(),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMethodBinding.InterTypeMethodBinding(EclipseWorld, ResolvedMember, TypeX,AbstractMethodDeclaration),True
org.rg.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.manageSyntheticAccessIfNecessary(BlockScope),True
org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.manageSyntheticAccessIfNecessary(BlockScope),True
org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.manageSyntheticAccessIfNecessary(BlockScope),True
org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.getAccessMethod(),True
tests/bugs/SuperToIntro.main(String[]),False,new_method|test_method
#####
AspectJ
30168
d15eb325fc77d9f1eb0ac9ec1f6886562d531105
Error with certain combination of advice This program causes the java VM to crash. It is a minimal example -- if you remove anything in the aspects it works. 1. PROGRAM CODE package test; import org.aspectj.lang.*; import org.aspectj.lang.reflect.*; public class Test3 { public static void main(String[] args) throws Exception { Test3 a = new Test3(); a.foo(-3); } public void foo(int i) { this.x=i; } int x; } aspect Log { pointcut assign(Object newval, Object targ): set(* test..*) &amp;&amp; args(newval) &amp;&amp; target(targ); before(Object newval, Object targ): assign(newval,targ) { Signature sign = thisJoinPoint.getSignature(); System.out.println(targ.toString() + "." + sign.getName() + ":=" + newval); } /* } // Different error message if you divide into two aspects aspect Tracing { */ pointcut tracedCall(): call(* test..*(..))/* &amp;&amp; !within(Tracing)*/ &amp;&amp; !within(Log); after() returning (Object o): tracedCall() { // Works if you comment out either of these two lines thisJoinPoint.getSignature(); System.out.println(thisJoinPoint); } } 2. RESULTS ON SOLARIS [erik@oden test] java test.Test3 test.Test3@b8df17.x:=-3 Unexpected Signal : 11 occurred at PC=0xFA415A00 Function=[Unknown.] Library=(N/A) NOTE: We are unable to locate the function name symbol for the error just occurred. Please refer to release documentation for possible reason and solutions. Current Java thread: Dynamic libraries: 0x10000 java 0xff350000 /usr/lib/libthread.so.1 0xff390000 /usr/lib/libdl.so.1 0xff200000 /usr/lib/libc.so.1 0xff330000 /usr/platform/SUNW,Ultra-250/lib/libc_psr.so.1 0xfe000000 /usr/j2se/jre/lib/sparc/client/libjvm.so 0xff2e0000 /usr/lib/libCrun.so.1 0xff1e0000 /usr/lib/libsocket.so.1 0xff100000 /usr/lib/libnsl.so.1 0xff0d0000 /usr/lib/libm.so.1 0xff310000 /usr/lib/libw.so.1 0xff0b0000 /usr/lib/libmp.so.2 0xff080000 /usr/j2se/jre/lib/sparc/native_threads/libhpi.so 0xff050000 /usr/j2se/jre/lib/sparc/libverify.so 0xff020000 /usr/j2se/jre/lib/sparc/libjava.so 0xfe7e0000 /usr/j2se/jre/lib/sparc/libzip.so 0xfe5b0000 /usr/lib/locale/sv_SE/sv_SE.so.2 Local Time = Fri Jan 24 13:38:29 2003 Elapsed Time = 2 # # HotSpot Virtual Machine Error : 11 # Error ID : 4F530E43505002D3 01 # Please report this error at # http://java.sun.com/cgi-bin/bugreport.cgi # # Java VM: Java HotSpot(TM) Client VM (1.4.0-b92 mixed mode) # # An error report file has been saved as hs_err_pid15099.log. # Please refer to the file for further information. # Abort [erik@oden test] [erik@oden test] /usr/j2se.old/bin/java test.Test3 test.Test3@1afa3.x:=-3 Unexpected Signal : 11 occurred at PC=0x85c24 Function name=(N/A) Library=(N/A) NOTE: We are unable to locate the function name symbol for the error just occurred. Please refer to release documentation for possible reason and solutions. Current Java thread: Dynamic libraries: 0x10000 /usr/j2se.old/bin/../bin/sparc/native_threads/java 0xff350000 /usr/lib/libthread.so.1 0xff390000 /usr/lib/libdl.so.1 0xff200000 /usr/lib/libc.so.1 0xff330000 /usr/platform/SUNW,Ultra-250/lib/libc_psr.so.1 0xfe480000 /usr/j2se.old/jre/lib/sparc/client/libjvm.so 0xff2e0000 /usr/lib/libCrun.so.1 0xff1e0000 /usr/lib/libsocket.so.1 0xff100000 /usr/lib/libnsl.so.1 0xff0d0000 /usr/lib/libm.so.1 0xff310000 /usr/lib/libw.so.1 0xff0b0000 /usr/lib/libmp.so.2 0xff080000 /usr/j2se.old/jre/lib/sparc/native_threads/libhpi.so 0xff050000 /usr/j2se.old/jre/lib/sparc/libverify.so 0xfe440000 /usr/j2se.old/jre/lib/sparc/libjava.so 0xff020000 /usr/j2se.old/jre/lib/sparc/libzip.so 0xfe260000 /usr/lib/locale/sv_SE/sv_SE.so.2 Local Time = Fri Jan 24 13:39:20 2003 Elapsed Time = 2 # # HotSpot Virtual Machine Error : 11 # Error ID : 4F530E43505002C4 01 # Please report this error at # http://java.sun.com/cgi-bin/bugreport.cgi # # Java VM: Java HotSpot(TM) Client VM (1.3.1_02-b02 mixed mode) # # An error report file has been saved as hs_err_pid15100.log. # Please refer to the file for further information. # Abort [erik@oden test] 3. RESULTS ON WINDOWS 2000 Results on Windows 2000 (If I have copied it correctly) &gt;java -classpath ..\..\aspectj1.1\lib\aspectjrt.jar;. test.Test3 test.Test3@1a8c4e7.x:=-3 Exception in thread "main" java.lang.NullPointerException at test.Log.ajc$afterReturning$test_Log$30d(Test3.java:37) at test.Test3.main(Test3.java:8) &gt;java -version java version "1.4.1_01" Java(TM) 2 Runtime Environment, Standard Edition (build 1.4.1_01-b01) Java HotSpot(TM) Client VM (build 1.4.1_01-b01, mixed mode) java
Error with certain combination of advice This program causes the java VM to crash. It is a minimal example -- if you remove anything in the aspects it works. 1. 2. RESULTS ON SOLARIS [erik@oden test] java @b8df17.x:=-3 Unexpected Signal : 11 occurred at PC=0xFA415A00 Function=[Unknown.] Library=(N/A) NOTE: We are unable to locate the function name symbol for the error just occurred. Please refer to release documentation for possible reason and solutions. Local Time = Fri Jan 24 13:38:29 2003 Elapsed Time = 2 # # HotSpot Virtual Machine Error : 11 # Error ID : 4F530E43505002D3 01 # Please report this error at # http://java.sun.com/cgi-bin/bugreport.cgi # # Java VM: Java HotSpot(TM) Client VM (1.4.0-b92 mixed mode) # # An error report file has been saved as # Please refer to the file for further information. # Abort [erik@oden test] [erik@oden test] @1afa3.x:=-3 Unexpected Signal : 11 occurred at PC=0x85c24 Function name=(N/A) Library=(N/A) NOTE: We are unable to locate the function name symbol for the error just occurred. Please refer to release documentation for possible reason and solutions. Current Java thread: Dynamic libraries: Local Time = Fri Jan 24 13:39:20 2003 Elapsed Time = 2 # # HotSpot Virtual Machine Error : 11 # Error ID : 4F530E43505002C4 01 # Please report this error at # http://java.sun.com/cgi-bin/bugreport.cgi # # Java VM: Java HotSpot(TM) Client VM (1.3.1_02-b02 mixed mode) # # An error report file has been saved as hs_err_pid15100.log. # Please refer to the file for further information. # Abort [erik@oden test] 3. RESULTS ON WINDOWS 2000 Results on Windows 2000 (If I have copied it correctly) -version java version "1.4.1_01" Java(TM) 2 Runtime Environment, Standard Edition (build 1.4.1_01-b01) Java HotSpot(TM) Client VM (build 1.4.1_01-b01, mixed mode) java
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ThisJoinPointVisitor.computeJoinPointParams(),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ThisJoinPointVisitor.checkAndFix(ASTObject),True 
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ThisJoinPointVisitor.replaceEffectivelyStaticRef(MessageSend),True 
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ThisJoinPointVisitor.getEquivalentStaticBinding(MethodBinding),False,new_method
tests/bugs/crashes/test/Test3.main(String[]),False,test_method|new_method
tests/bugs/crashes/test/Test3.foo(int),False,test_method|new_method
tests/bugs/crashes/test/Test3.before(Object, Object),False,test_method|new_method
tests/bugs/crashes/test/Test3.assign(Object, Object),False,test_method|new_method
tests/bugs/crashes/test/Test3.after(),False,test_method|new_method
tests/bugs/crashes/test/Test3.tracedCall(),False,test_method|new_method
#####
AspectJ
31423
19c3e16d2212bdd41144da2150c8ef46b4a759a5
Pointcut adviceexecution() does not work Pointcut adviceexecution() does not seem to pick advice execution join points in beta4. Here is a program that shows the problem: public class Test { public static void main(String[] args) { } } aspect Aspect1 { before() : execution(* Test.*(..)) { System.out.println("Reached " + thisJoinPoint); } } aspect Aspect2 { before() : adviceexecution() &amp;&amp; !within(Aspect2) { System.out.println("Reached " + thisJoinPoint); } } F:\aop\bugs\1.1\b4\adviceexecution&gt;ajc -version AspectJ Compiler 1.1beta4 F:\aop\bugs\1.1\b4\adviceexecution&gt;ajc Test.java F:\aop\bugs\1.1\b4\adviceexecution&gt;java Test Reached execution(void Test.main(String[]))
does not work does not seem to pick advice execution join points in beta4. Here is a program that shows the problem: java Test Reached execution()
******
tests/bugs/AdviceExec.main(String[]),False,new_method|test_method
org.aspectj.matcher/src/org/aspectj/weaver/patterns/KindedPointcut.match(Shadow),False,Refactoring
org.aspectj.matcher/src/org/aspectj/weaver/patterns/SignaturePattern.matches(Member, World),True
#####
AspectJ
33635
cb775240056309c20aac308be5ab2abd9696be84
Negation of if pointcut does not work In "!if(expression)" the negation part is ignored. I am using beta4. How to reproduce: public class Test { public static void main(String args[]) { } } aspect NotIfBugAspect { before() : execution(* main(..)) &amp;&amp; !if(true) { System.out.println("NotIfBugAspect message"); } } &gt; ajc *.java &gt; java Test NotIfBugAspect message If I change the pointcut in before advice to move negation inside if(), everything works fine: aspect NotIfBugAspect { before() : execution(* main(..)) &amp;&amp; if(!true) { System.out.println("NotIfBugAspect message"); } } &gt; ajc *.java &gt; java Test &lt;no output&gt;
Negation of if pointcut does not work In "(expression)" the negation part is ignored. I am using beta4. How to reproduce: 
******
tests/bugs/NotIf.main(String[]),False,test_method|new_method
tests/bugs/NotIf.testTrue(),False,test_method|new_method
tests/bugs/NotIf.testFalse(),False,test_method|new_method
org.aspectj.matcher/src/org/aspectj/weaver/patterns/IfPointcut.findResidue(Shadow, ExposedState),True
#####
AspectJ
32463
d1e5c0a57c5da220b8f7357550db84f1009dbe2e
ajc reports error when encountering static declaration of nested classes Version: AspectJ Compiler 1.1beta4 The ajc compiler issues a spurious error message and exits with a negative error code when weaving code containing static declaration of a nested class. The compiler seem to write the classfiles correctly but the negative exit status causes problems when e.g. using the AjcCompilerAdapter in ant. To reproduce: 1) Extract the following two files into an empty directory: // File: A.aj: aspect A { pointcut withinTest(): within(Test); pointcut callToHandleOrder() : (withinTest() &amp;&amp; call(* handleOrder(..))); Object around(): callToHandleOrder() { return "DUMMY inserted by ASPECT" ; } } // End of File A.aj // File : Test.java public class Test { // Commenting out the static declaration makes everything work OK static { class StaticNestedClass { } } public static void main(String[] args) { System.out.println(new Test().handleOrder("test")); } private String handleOrder(String t) { return t; } } // End of Test.java 2) Compile the files ajc -sourceroots . -verbose Output: ----- compiling c:/aspectj1.1/doc/examples/bug/./A.aj compiling c:/aspectj1.1/doc/examples/bug/./Test.java weaving might need to weave [UnwovenClassFile(null, Test$1$StaticNestedClass), UnwovenClassFile(null, A), UnwovenClassFile(null, Test)](world=true) wrote class file: c:\aspectj1.1\doc\examples\bug\A.class can't find type Test$1 wrote class file: c:\aspectj1.1\doc\examples\bug\Test$1$StaticNestedClass.class wrote class file: c:\aspectj1.1\doc\examples\bug\Test.class 1 error ------
ajc reports error when encountering static declaration of nested classes Version: AspectJ Compiler 1.1beta4 The ajc compiler issues a spurious error message and exits with a negative error code when weaving code containing static declaration of a nested class. The compiler seem to write the classfiles correctly but the negative exit status causes problems when e.g. using the in ant. To reproduce: 1) Extract the following two files into an empty directory: // File: 2) Compile the files ajc -sourceroots . -verbose Output: ----- compiling error ------
******
tests/bugs/WeaveLocal.main(string[]),False,new_method
tests/bugs/WeaveLocal.handleOrder(String),False,new_method
org.aspectj.matcher/src/org/aspectj/weaver/NameMangler.getOutermostType(TypeX),True
org.aspectj.matcher/src/org/aspectj/weaver/NameMangler.makeVisibilityName(int modifiers, TypeX),True
weaver/src/org/aspectj/weaver/ResolvedTypeX.getOutermostType(ResolvedTypeX),True
weaver/src/org/aspectj/weaver/ResolvedTypeX.getDeclaringType(),False,new_method
weaver/src/org/aspectj/weaver/ResolvedTypeX.isVisible(int, ResolvedTypeX, ResolvedTypeX),True
weaver/src/org/aspectj/weaver/TypeX.getDeclaringType(),True
org.aspectj.matcher/src/org/aspectj/weaver/patterns/WithinPointcut.match(Shadow),True
weaver/testsrc/org/aspectj/weaver/TypeXTestCase.testNameAndSigWithInners(),True
#####
AspectJ
29934
0fb5f693794e571ab693813cbc80578b2bc7b470
runtime NullPointerException when applying around advice to other around advice When the program below is run, it produces a NullPointerException... java.lang.NullPointerException at A2.ajc$around$A2$3b6proceed(CflowCycles.java) at A2.ajc$around$A2$3b6_aroundBody3(CflowCycles.java:35) at Target.run(CflowCycles.java:24) at CflowCycles.run_aroundBody4(CflowCycles.java:8) at CflowCycles.main_aroundBody6(CflowCycles.java:24) at CflowCycles.main(CflowCycles.java:24) ---(in new/CflowCycles.java and in ajcTestsFailing.xml) import org.aspectj.testing.Tester; /** @testcase cflow cycles in advice from different aspects */ public class CflowCycles { public static void main( String args[] ) { Tester.expectEvent("target A1"); Tester.expectEvent("target A2"); new Target().run(); Tester.checkAllEventsIgnoreDups(); } } class Target { public void run(){ } } aspect A1 { pointcut TargetRunFlow () // ok if no cflow: within(Target) &amp;&amp; execution(* *(..)) &amp;&amp; !within (A1+); : !within(A1+) &amp;&amp; !preinitialization(new(..)) &amp;&amp; !initialization(new (..))//cflow(within(Target) &amp;&amp; execution(* *(..))) &amp;&amp; !within(A1+) ; Object around () : TargetRunFlow() { Tester.event("target A1"); return proceed(); } // ok if in the same class } aspect A2 { pointcut TargetRun () : within(Target) &amp;&amp; execution(* *(..)) &amp;&amp; !within(A2+); ; Object around () : TargetRun() { Tester.event("target A2"); return proceed(); } }
runtime when applying around advice to other around advice When the program below is run, it produces a ... ---(in  ok if in the same class 
******
weaver/src/org/aspectj/weaver/bcel/BcelShadow.weaveAroundInline(BcelAdvice, boolean),True
#####
AspectJ
34858
7746fcb7e977c7a91bd70081a2197a999ec18ad3
Weaver crash this test file (Test.java) crashes the weaver: public class Test { static aspect MockProcessing { pointcut testFlow(final Thread thread) : cflow(execution(void run()) &amp;&amp; this(thread) &amp;&amp; within(Thread)); // the within is an optimization Object around() : call(* DummyConfiguration.createRootApplicationModule(..)) &amp;&amp; testFlow(Thread) { return null; } } } class Bar { void foo() { DummyConfiguration.createRootApplicationModule(); } } class DummyConfiguration { static Object createRootApplicationModule() { return null; } } prompt&gt;ajc -d 11bin -1.4 Test.java Exception thrown from AspectJ 1.1rc1 This might be logged as a bug already -- find current bugs at http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler Bugs for exceptions thrown have titles File:line from the top stack, e.g., "SomeFile.java:243" If you don't find the exception below in a bug, please add a new bug at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ To make the bug a priority, please include a test program that can reproduce this exception. 0 0 java.lang.ArrayIndexOutOfBoundsException: 0 at org.aspectj.weaver.IntMap.get(IntMap.java:109) at org.aspectj.weaver.patterns.CflowPointcut.concretize1(CflowPointcut.j ava:170) at org.aspectj.weaver.patterns.ReferencePointcut.concretize1(ReferencePo intcut.java:270) at org.aspectj.weaver.patterns.AndPointcut.concretize1(AndPointcut.java: 88) at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:127) at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:120) at org.aspectj.weaver.Advice.concretize(Advice.java:207) at org.aspectj.weaver.CrosscuttingMembers.addShadowMunger(CrosscuttingMe mbers.java:78) at org.aspectj.weaver.CrosscuttingMembers.addShadowMungers(CrosscuttingM embers.java:72) at org.aspectj.weaver.ResolvedTypeX.collectCrosscuttingMembers(ResolvedT ypeX.java:328) at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect(Crosscut tingMembersSet.java:54) at org.aspectj.weaver.bcel.BcelWeaver.prepareForWeave(BcelWeaver.java:16 4) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:214) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.weaveAndGenerat eClassFiles(AjBuildManager.java:394) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBu ildManager.java:149) at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:55) at org.aspectj.tools.ajc.Main.run(Main.java:216) at org.aspectj.tools.ajc.Main.runMain(Main.java:155) at org.aspectj.tools.ajc.Main.main(Main.java:72) 1 fail|abort
Weaver crash this test file () crashes the weaver: public class Test { static aspect the within is an optimization  prompt&gt;ajc -d 11bin -1.4 Test.java Exception thrown from AspectJ 1.1rc1 This might be logged as a bug already -- find current bugs at Bugs for exceptions thrown have titles File:line from the top stack, e.g., ":243" If you don't find the exception below in a bug, please add a new bug at To make the bug a priority, please include a test program that can reproduce this exception. 0 0 1 fail|abort
******
tests/bugs/CflowBinding.main(String[]),False,test_method|new_method
tests/bugs/CflowBinding.bar(int),False,test_method|new_method
tests/bugs/CflowBinding.m(),False,test_method|new_method
tests/bugs/CflowBindingOrig.main(String[]),False,test_method|new_method
tests/bugs/CflowBindingOrig.testFlow(Thread),False,test_method|new_method
tests/bugs/CflowBindingOrig.createRootApplicationModule(),False,test_method|new_method
tests/bugs/CflowBindingOrig.foo(),False,test_method|new_method
org.aspectj.matcher/src/org/aspectj/weaver/patterns/CflowPointcut.concretize1(ResolvedTypeX, IntMap),True
#####
AspectJ
34925
56cc4f27afaf591f8cebb2450513cc6eb7d51299
compiler crash on yesterday's rc1 build These test files crash the compiler (in fact if you just compile ConvertToUnchecked it crashes it): ConvertToUnchecked.java: import java.io.IOException; // example 3 aspect ConvertToUnchecked { // make all exceptions in an application unchecked; "soft" //declare soft: (Exception &amp;&amp; !RuntimeException): within(com.foo.app..*); // convert IOExceptions in a package to PersistenceException pointcut module() : within(test.*); // within (com.foo.framework.persistence.*); // convert exceptions // within(test.*) would work to allow an immediate catch, except for // the last statement in a try block // however, I suspect that would also generate inefficient code // even this might be inefficient: it needs to wrap every method body in a // try ... catch block after() throwing (IOException e) : within(test.*) { throw new PersistenceException(e); } declare soft: (IOException): module(); } // tested by: test.ConvertToUnchecked ---- PersistenceException.java public class PersistenceException extends Exception { public PersistenceException(Throwable cause) { super(cause); } } --- sample run: C:\ron\devel\articles\errorHandling&gt;ajc -1.4 ConvertToUnchecked.java Persistence Exception.java java.lang.RuntimeException: unimplemented: throw new PersistenceException(e) at org.aspectj.ajdt.internal.compiler.lookup.EclipseShadow.makeShadow (Ec lipseShadow.java:148) at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeShadow (E clipseFactory.java:292) at org.aspectj.ajdt.internal.compiler.problem.AjProblemReporter.unhandle dException(AjProblemReporter.java:67) at org.eclipse.jdt.internal.compiler.flow.FlowContext.checkExceptionHand lers(FlowContext.java:249) at org.eclipse.jdt.internal.compiler.ast.ThrowStatement.analyseCode (Thro wStatement.java:35) at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.analy seCode(AbstractMethodDeclaration.java:106) at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode (Typ eDeclaration.java:445) at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.anal yseCode(CompilationUnitDeclaration.java:76) at org.eclipse.jdt.internal.compiler.Compiler.process (Compiler.java:539) at org.aspectj.ajdt.internal.compiler.AjCompiler.process (AjCompiler.java :65) at org.eclipse.jdt.internal.compiler.Compiler.compile (Compiler.java:340) at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile (Ab stractImageBuilder.java:232) at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile (Ab stractImageBuilder.java:171) at org.aspectj.ajdt.internal.core.builder.AjBuildManager$BatchBuilder.ru n(AjBuildManager.java:656) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild (AjBu ildManager.java:139) at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:55) at org.aspectj.tools.ajc.Main.run(Main.java:216) at org.aspectj.tools.ajc.Main.runMain(Main.java:155) at org.aspectj.tools.ajc.Main.main(Main.java:72) C:\ron\devel\articles\errorHandling\ConvertToUnchecked.java:0 Internal compiler error java.lang.RuntimeException: unimplemented: throw new PersistenceException(e) at org.aspectj.ajdt.internal.compiler.lookup.EclipseShadow.makeShadow (Ec lipseShadow.java:148) at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeShadow (E clipseFactory.java:292) at org.aspectj.ajdt.internal.compiler.problem.AjProblemReporter.unhandle dException(AjProblemReporter.java:67) at org.eclipse.jdt.internal.compiler.flow.FlowContext.checkExceptionHand lers(FlowContext.java:249) at org.eclipse.jdt.internal.compiler.ast.ThrowStatement.analyseCode (Thro wStatement.java:35) at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.analy seCode(AbstractMethodDeclaration.java:106) at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode (Typ eDeclaration.java:445) at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.anal yseCode(CompilationUnitDeclaration.java:76) at org.eclipse.jdt.internal.compiler.Compiler.process (Compiler.java:539) at org.aspectj.ajdt.internal.compiler.AjCompiler.process (AjCompiler.java :65) at org.eclipse.jdt.internal.compiler.Compiler.compile (Compiler.java:340) at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile (Ab stractImageBuilder.java:232) at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile (Ab stractImageBuilder.java:171) at org.aspectj.ajdt.internal.core.builder.AjBuildManager$BatchBuilder.ru n(AjBuildManager.java:656) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild (AjBu ildManager.java:139) at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:55) at org.aspectj.tools.ajc.Main.run(Main.java:216) at org.aspectj.tools.ajc.Main.runMain(Main.java:155) at org.aspectj.tools.ajc.Main.main(Main.java:72) !! no source information available !! ABORT Exception thrown from AspectJ 1.1rc1 This might be logged as a bug already -- find current bugs at http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler Bugs for exceptions thrown have titles File:line from the top stack, e.g., "SomeFile.java:243" If you don't find the exception below in a bug, please add a new bug at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ To make the bug a priority, please include a test program that can reproduce this exception. unimplemented: throw new PersistenceException(e) unimplemented: throw new PersistenceException(e) java.lang.RuntimeException: unimplemented: throw new PersistenceException(e) at org.aspectj.ajdt.internal.compiler.lookup.EclipseShadow.makeShadow (Ec lipseShadow.java:148) at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeShadow (E clipseFactory.java:292) at org.aspectj.ajdt.internal.compiler.problem.AjProblemReporter.unhandle dException(AjProblemReporter.java:67) at org.eclipse.jdt.internal.compiler.flow.FlowContext.checkExceptionHand lers(FlowContext.java:249) at org.eclipse.jdt.internal.compiler.ast.ThrowStatement.analyseCode (Thro wStatement.java:35) at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.analy seCode(AbstractMethodDeclaration.java:106) at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode (Typ eDeclaration.java:445) at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.anal yseCode(CompilationUnitDeclaration.java:76) at org.eclipse.jdt.internal.compiler.Compiler.process (Compiler.java:539) at org.aspectj.ajdt.internal.compiler.AjCompiler.process (AjCompiler.java :65) at org.eclipse.jdt.internal.compiler.Compiler.compile (Compiler.java:340) at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile (Ab stractImageBuilder.java:232) at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile (Ab stractImageBuilder.java:171) at org.aspectj.ajdt.internal.core.builder.AjBuildManager$BatchBuilder.ru n(AjBuildManager.java:656) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild (AjBu ildManager.java:139) at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:55) at org.aspectj.tools.ajc.Main.run(Main.java:216) at org.aspectj.tools.ajc.Main.runMain(Main.java:155) at org.aspectj.tools.ajc.Main.main(Main.java:72) 1 fail|abort, 1 error
compiler crash on yesterday's rc1 build These test files crash the compiler (in fact if you just compile ConvertToUnchecked it crashes it): // make all exceptions in an application unchecked; "soft" //declare // convert  in a package to // convert exceptions // would work to allow an immediate catch, except for // the last statement in a try block // however, I suspect that would also generate inefficient code // even this might be inefficient: it needs to wrap every method body in a // try ... !! no source information available !! ABORT Exception thrown from AspectJ 1.1rc1 This might be logged as a bug already -- find current bugs at http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler Bugs for exceptions thrown have titles File:line from the top stack, e.g., "SomeFile.java:243" If you don't find the exception below in a bug, please add a new bug at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ To make the bug a priority, please include a test program that can reproduce this exception. unimplemented: unimplemented: fail|abort, 1 error
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseShadow.EclipseShadow(EclipseFactory, Kind, Member, AstNode, ReferenceContext),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseShadow.getEnclosingType(),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseShadow.getEnclosingCodeSignature(),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseShadow.makeShadow(EclipseFactory, AstNode, ReferenceContext),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.unhandledException(TypeBinding, AstNode),True
tests/bugs/ConvertToUnchecked.main(String[]),False,test_method|new_method
tests/bugs/ConvertToUnchecked.PersistenceException(Throwable),False,test_method|new_method
tests/bugs/ConvertToUnchecked.Root(String),False,test_method|new_method
tests/bugs/ConvertToUnchecked.Foo(String),False,test_method|new_method
tests/bugs/ConvertToUnchecked.getFile(),False,test_method|new_method
tests/bugs/ConvertToUnchecked.m(),False,test_method|new_method
#####
AspectJ
36803
1e502f504f2ad333ad5627d8e9d106315c38ecc0
BCException thrown by AspectJ 1.1rc1[iajc] expected state: resolved got: concrete [iajc] expected state: resolved got: concrete [iajc] org.aspectj.weaver.BCException: expected state: resolved got: concrete [iajc] at org.aspectj.weaver.patterns.Pointcut.assertState (Pointcut.java:236) [iajc] at org.aspectj.weaver.patterns.Pointcut.concretize (Pointcut.java:126) [iajc] at org.aspectj.weaver.patterns.CflowPointcut.concretize1 (CflowPointcut.java:143) [iajc] at org.aspectj.weaver.patterns.NotPointcut.concretize1 (NotPointcut.java:94) [iajc] at org.aspectj.weaver.patterns.AndPointcut.concretize1 (AndPointcut.java:88) [iajc] at org.aspectj.weaver.patterns.ReferencePointcut.concretize1 (ReferencePointcut.java:270) [iajc] at org.aspectj.weaver.patterns.AndPointcut.concretize1 (AndPointcut.java:88) [iajc] at org.aspectj.weaver.patterns.ReferencePointcut.concretize1 (ReferencePointcut.java:270) [iajc] at org.aspectj.weaver.patterns.Pointcut.concretize (Pointcut.java:127) [iajc] at org.aspectj.weaver.patterns.Pointcut.concretize (Pointcut.java:120) [iajc] at org.aspectj.weaver.Advice.concretize(Advice.java:207) [iajc] at org.aspectj.weaver.CrosscuttingMembers.addShadowMunger (CrosscuttingMembers.java:78) [iajc] at org.aspectj.weaver.CrosscuttingMembers.addShadowMungers (CrosscuttingMembers.java:72) [iajc] at org.aspectj.weaver.ResolvedTypeX.collectCrosscuttingMembers (ResolvedTypeX.java:328) [iajc] at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect (CrosscuttingMembersSet.java:54) [iajc] at org.aspectj.weaver.bcel.BcelWeaver.prepareForWeave (BcelWeaver.java:164) [iajc] at org.aspectj.weaver.bcel.BcelWeaver.weave (BcelWeaver.java:214) [iajc] at org.aspectj.ajdt.internal.core.builder.AjBuildManager.weaveAndGenerateClassFile s(AjBuildManager.java:394) [iajc] at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild (AjBuildManager.java:149) [iajc] at org.aspectj.ajdt.ajc.AjdtCommand.runCommand (AjdtCommand.java:55) [iajc] at org.aspectj.tools.ajc.Main.run(Main.java:216) [iajc] at org.aspectj.tools.ajc.Main.runMain(Main.java:155) [iajc] at org.aspectj.tools.ant.taskdefs.AjcTask.execute (AjcTask.java:646) [iajc] at org.apache.tools.ant.UnknownElement.execute (UnknownElement.java:193) [iajc] at org.apache.tools.ant.Task.perform(Task.java:341) [iajc] at org.apache.tools.ant.Target.execute(Target.java:309) [iajc] at org.apache.tools.ant.Target.performTasks(Target.java:336) [iajc] at org.apache.tools.ant.Project.executeTarget (Project.java:1339) [iajc] at org.apache.tools.ant.Project.executeTargets (Project.java:1255) [iajc] at org.apache.tools.ant.Main.runBuild(Main.java:609) [iajc] at org.apache.tools.ant.Main.start(Main.java:196) [iajc] at org.apache.tools.ant.Main.main(Main.java:235)
BCException thrown by AspectJ 1.1rc1[iajc] expected state: resolved got: concrete [iajc] expected state: resolved got: concrete 
******
tests/bugs/CflowConcrete.main(String[]),False,test_method|new_method
org.aspectj.matcher/src/org/aspectj/weaver/patterns/KindedPointcut.concretize1(ResolvedTypeX, IntMap),True
org.aspectj.matcher/src/org/aspectj/weaver/patterns/Pointcut.concretize1(ResolvedTypeX, IntMap),True
org.aspectj.matcher/src/org/aspectj/weaver/patterns/WithinPointcut.concretize1(ResolvedTypeX, IntMap),True
org.aspectj.matcher/src/org/aspectj/weaver/patterns/WithincodePointcut.concretize1(ResolvedTypeX, IntMap),True
#####
AspectJ
34951
f236927770b4c1029e4d108c3991870609555dfb
NPE compiling without aspectjrt.jar Compiling spacewar without specifying aspectjrt.jar on the classpath causes a NPE. Expected an error message "aspectjrt.jar required". Steps to reproduce 1) install latest 2) cd doc/examples 3) java -jar ../../lib/aspectjtools.jar -verbose @spacewar/debug.lst RESULT:NPE in attached log
NPE compiling without Compiling spacewar without specifying on the classpath causes a NPE. Expected an error message "required". Steps to reproduce 1) install latest 2) cd 3) RESULT:NPE in attached log
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.initBcelWorld(IMessageHandler),True
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BasicCommandTestCase.testMissingRuntimeError(),False,new_method|test_method
#####
AspectJ
37576
99f5c14fb0df142b1e25361a7ff3951a5a6d4d5d
Ant task switches {boot}classpath entities in 1.1rc2 The AjcTask (iajc) task takes nested bootclasspath entities as classpath and vice-versa.
Ant task switches {boot}classpath entities in 1.1rc2 The (iajc) task takes nested bootclasspath entities as classpath and vice-versa.
******
taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.createClasspath(),True
taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.reateBootclasspath(),True
taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.execute(),True
taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.setupCommand(boolean),False,new_method
taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.testClasspath(),False,new_method|test_method
#####
AspectJ
37739
2072ac11448e493e26ab7ff818ce26c6ef33c19c
Unexpected Xlint:unresolvableMember warning with withincode The following code produces an Xlint:unresolvableMember warning: class A { A(Class type) {} A() { this(String.class); } } class B { public void test() { } public void test2() { test(); } } aspect C { void around() : (call (void B.test()) &amp;&amp; withincode (void B.test2())) { proceed(); } } The warning text is: Warning.java:22 can not resolve this member: void A.&lt;catch&gt;(java.lang.ClassNotFoundException) [Xlint:unresolvableMember] Line 22 is the line in the aspect that says "withincode". If I comment out the aspect, the warning goes away. Also, if I comment out A's default constructor, it goes away. The "String.class" seems to have something to do with the warning. I can reproduce this with 1.1rc1 and 1.1rc2.
Unexpected Xlint: warning with withincode The following code produces an Xlint:unresolvableMember warning: The warning text is::22 can not resolve this member: Line 22 is the line in the aspect that says "withincode". If I comment out the aspect, the warning goes away. Also, if I comment out A's default constructor, it goes away. The "" seems to have something to do with the warning. I can reproduce this with 1.1rc1 and 1.1rc2.
******
tests/bugs/CatchSig.CatchSig(Class),False,new_method|test_method
tests/bugs/CatchSig.CatchSig(),False,new_method|test_method
tests/bugs/CatchSig.main(String[]),False,new_method|test_method
tests/bugs/CatchSig.B(),False,new_method|test_method
tests/bugs/CatchSig.findClass(),False,new_method|test_method
tests/bugs/CatchSig.test(),False,new_method|test_method
tests/bugs/CatchSig.test2(),False,new_method|test_method
weaver/src/org/aspectj/weaver/bcel/BcelShadow.getEnclosingCodeSignature(),True
#####
AspectJ
38131
c509c6f751a553cc85d0210a408681f4f3ae05cb
ajc needs -d . option while correctly compiling classes from subpackage I am using 1.1rc1. This is a regression since rc1 and a deviation from javac. I am guessing this may have to do something with change in the underlying Eclipse compiler. Create a class in a subpackage such as: package subpackage; public class Test { public static void main(String[] args) { System.out.println("Hello"); } } Then compile using following command: &gt; ajc subpackage\Test.java You will see a directory "subpackage" created under the existing "subpackage" directory. The test.class is then put in subpackage\subpackage directory. This means running java command results in Exception in thread "main" java.lang.NoClassDefFoundError: subpackage/Test Running either of the following command fixes the problem: &gt; ajc -d . subpackage\Test.java or &gt; javac subpackage\Test.java No big deal, really. But it will be nice to have same behavior as javac.
ajc needs -d . option while correctly compiling classes from subpackage I am using 1.1rc1. This is a regression since rc1 and a deviation from javac. I am guessing this may have to do something with change in the underlying Eclipse compiler. Create a class in a subpackage such as: package subpackage; Then compile using following command: &gt; ajc You will see a directory "subpackage" created under the existing "subpackage" directory. The is then put in directory. This means running java command results in Exception in thread "main" : Running either of the following command fixes the problem: &gt; ajc -d . or &gt; javac No big deal, really. But it will be nice to have same behavior as javac.
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.outputClassFiles(CompilationResult),True
org.aspectj.ajdt.core/testdata/src1/WrongPackage.main(String[]),False,new_method
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BasicCommandTestCase.testImplicitOutputDir(),False,new_method|test_method
#####
AspectJ
39626
78869703a8bf08bfa4e8f19b26dcf877949b0ad2
Compiler error when compiling a buggy class I use AspectJ 1.1 from within eclipse. After some time of developing, I get following stack trace (Wrapped in the eclipse gui), when I try to compile a java file with a huge amount of syntax errors, missing variables, and other problems. As soon as I have fixed these issues, I can comnpile normally as ever. Unfortunatly I can not provide any more detailed information because: this errors pops up randomly, disappears when the bug is fixed, I have neither the time nor the permission to create a more accurate sample java.lang.NullPointerException at java.lang.String.&lt;init&gt;(String.java:214) at org.aspectj.ajdt.internal.core.builder.AsmBuilder.visit (AsmBuilder.java:231) at org.aspectj.ajdt.internal.core.builder.AsmBuilder.visit (AsmBuilder.java:259) at org.eclipse.jdt.internal.compiler.ast.AnonymousLocalTypeDeclaration.traverse (AnonymousLocalTypeDeclaration.java:138) at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.traverse (QualifiedAllocationExpression.java:342) at org.eclipse.jdt.internal.compiler.ast.MessageSend.traverse (MessageSend.java:299) at org.eclipse.jdt.internal.compiler.ast.Block.traverse(Block.java:147) at org.eclipse.jdt.internal.compiler.ast.ForStatement.traverse (ForStatement.java:347) at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse (MethodDeclaration.java:157) at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse (TypeDeclaration.java:946) at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse (CompilationUnitDeclaration.java:303) at org.aspectj.ajdt.internal.core.builder.AsmBuilder.internalBuild (AsmBuilder.java:169) at org.aspectj.ajdt.internal.core.builder.AsmBuilder.build (AsmBuilder.java:66) at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.finishedCompilationUnit (EclipseFactory.java:303) at org.aspectj.ajdt.internal.compiler.AjCompiler.process(AjCompiler.java:67) at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:338) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation (AjBuildManager.java:372) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild (AjBuildManager.java:133) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild (AjBuildManager.java:78) at org.aspectj.ajde.internal.CompilerAdapter.compile (CompilerAdapter.java:117) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run (AspectJBuildManager.java:164) LoadTest.java CrefoClient/src/com/dcbank/scoring/socketserver kind regards Arno Schmidmeier
Compiler error when compiling a buggy class I use AspectJ 1.1 from within eclipse. After some time of developing, I get following stack trace (Wrapped in the eclipse gui), when I try to compile a java file with a huge amount of syntax errors, missing variables, and other problems. As soon as I have fixed these issues, I can comnpile normally as ever. Unfortunatly I can not provide any more detailed information because: this errors pops up randomly, disappears when the bug is fixed, I have neither the time nor the permission to create a more accurate sample kind regards Arno Schmidmeier
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.AsmBuilder(CompilationResult),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.visit(LocalTypeDeclaration, BlockScope),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.visit(Initializer, MethodScope),True
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjdtBuilderTests.suite(),False,test_method
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AsmBuilderTest.suite(),False,test_method|new_method
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AsmBuilderTest.testNullHandlingOfVisit(),False,test_method|new_method
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AsmBuilderTest.getContents(),False,test_method|new_method
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AsmBuilderTest.getMainTypeName(),False,test_method|new_method
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AsmBuilderTest.getPackageName(),False,test_method|new_method
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AsmBuilderTest.getFileName(),False,test_method|new_method
#####
AspectJ
40257
acdf688ccc4d8b376141b2c8e28bc5d7b7612e90
"parsing of ""../"" paths in LST files is broken" Relative paths (e.g. "../") are no longer parser properly in AJDE 1.1.0.
"parsing of ""../"" paths in LST files is broken" Relative paths (e.g. "../") are no longer parser properly in AJDE 1.1.0.
******
ajbrowser/testsrc/org/aspectj/tools/ajbrowser/BrowserManagerTest.BrowserManagerTest(String),False,refactored
ajbrowser/testsrc/org/aspectj/tools/ajbrowser/BrowserManagerTest.suite(),True
ajbrowser/testsrc/org/aspectj/tools/ajbrowser/BrowserManagerTest.testAddProjectTask(),True
ajbrowser/testsrc/org/aspectj/tools/ajbrowser/BrowserManagerTest.testAddSourceLineTasks(),True
ajbrowser/testsrc/org/aspectj/tools/ajbrowser/BrowserManagerTest.testAddSourceLineTasks(),True
ajde/src/org/aspectj/ajde/ui/swing/CompilerMessagesCellRenderer.getListCellRendererComponent(JList, Object, int, boolean, boolean),True
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/AjdtAjcTests.suite(),False,refactoring
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.testNonExistentConfigFile(),False,new_method
#####
AspectJ
41123
3e5974557278e81a9891edd4269eca39a8d42f43
Weaving failure when using injars Sample run that fails using injars: :3 Class must implement the inherite d abstract method  $ajee_t ^^^^^^ 1 error It works in a single pass compilation:
Weaving failure when using injars Sample run that fails using injars: :3 Class must implement the inherite d abstract method  $ajee_t ^^^^^^ 1 error It works in a single pass compilation:
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.weaveInterTypeDeclarations(SourceTypeBinding, Collection, Collection, boolean),False,comments
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.doDeclareParents(DeclareParents, SourceTypeBinding),True
weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.makeMethodGen(LazyClassGen, ResolvedMember),True
weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.pack(),True
weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.makeSynthetic(),False,new_method
#####
AspectJ
40380
d5ea336dac0b484629f6453afcc7b271446732d4
AspectJ does not honour libraries defined via Project Properties AJDT 1.1.3, Eclipse 2.1 To build a JDK 1.4. program under Eclipse using JDK 1.3 the appropriate build library should be selected in the Project Properties "Java Build Path". However AspectJ continues to use the JDK associated with Eclipse so errors result from using 1.4 APIs. The same will occur running Eclipse under 1.4 and compiling programs for 1.5 Testcase: 1. Run Eclipse under JDK 1.3 2. Create a Java project which uses a 1.4 JDK 3. Write a Java classes that uses 1.4 APIs e.g. public class TestStringBuffer { public static void main(String[] args) { new StringBuffer("Test").indexOf("T"); } } 4. Convert to AspectJ project
AspectJ does not honour libraries defined via Project Properties AJDT 1.1.3, Eclipse 2.1 To build a JDK 1.4. program under Eclipse using JDK 1.3 the appropriate build library should be selected in the Project Properties "Java Build Path". However AspectJ continues to use the JDK associated with Eclipse so errors result from using 1.4 APIs. The same will occur running Eclipse under 1.4 and compiling programs for 1.5 Testcase: 1. Run Eclipse under JDK 1.3 2. Create a Java project which uses a 1.4 JDK 3. Write a Java classes that uses 1.4 APIs e.g. 4. Convert to AspectJ project
******
ajde/src/org/aspectj/ajde/internal/CompilerAdapter,False
org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.genBuildConfig(String[],CountingMessageHandler),False,refactoring
org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.genBuildConfig(String[], IMessageHandler),True
#####
AspectJ
42539
8660cc12bfbcd6f4957abd4dfc84735de6c048cf
throw derivative pointcuts not advised. Given the following point cut and advice: public aspect ExceptionAspect { pointcut exceptionThrower() : execution(public * ExceptionBugTest.*(..) throws Exception+); declare warning : exceptionThrower() : "throws Exception+"; } And the to be aspected code: public class ExceptionBugTest { class MyException extends Exception { } public void method1() throws Exception { } public void method2() throws MyException { } } listing file default.lst: C:\temp\AJC Bug\ExceptionAspect.aj C:\temp\AJC Bug\ExceptionBugTest.java AJC does not advise ExceptionBugTest.method2(). The output from the compilation is the following: C:\temp\AJC Bug&gt;ajc -argfile default.lst -classpath %ASPECTJ_HOME%\lib\aspectjrt.jar C:\eclipse\workspace\AJC Bug\ExceptionBugTest.java:11 throws Exception+ From the aspect-j mailing list, contributed by Jim Hugunin: &amp;lt;detail&amp;gt;The bug was caused because the code for ThrowsPattern mistakenly used the internal protected method TypePattern.matchesExactly instead of the external public method TypePattern.matchesStatically. Because the classes were in the same package, Java's accessibility rules allowed this. It would be nice if there was an easy way to specifiy that a method could only be accessed from subtypes.&amp;lt;/detail&amp;gt;
throw derivative pointcuts not advised. Given the following point cut and advice: And the to be aspected code: listing file AJC does not advise . The output from the compilation is the following: :11 throws Exception+ From the aspect-j mailing list, contributed by Jim Hugunin: &amp;lt;detail&amp;gt;The bug was caused because the code for  mistakenly used the internal protected method  instead of the external public method . Because the classes were in the same package, Java's accessibility rules allowed this. It would be nice if there was an easy way to specifiy that a method could only be accessed from subtypes.&amp;lt;/detail&amp;gt;
******
tests/bugs/throwsSignature/ExceptionAspect.exceptionThrower(),False,new_method|test_method
tests/bugs/throwsSignature/ExceptionBugTest.method1(),False,new_method|test_method
tests/bugs/throwsSignature/ExceptionBugTest.method2(),False,new_method|test_method
org.aspectj.matcher/src/org/aspectj/weaver/patterns/ThrowsPattern.matchesAny(TypePattern, ResolvedTypeX[]),True
#####
AspectJ
42993
b5127388a3b5a2403e8d8944766bbe1895e09530
"Language regression, or possible language improvement?" The file AspectBug.java: public aspect AspectBug extends AbstractCaching perthis(execution(ContainerLoader+.new(..))) { declare parents: ContainerDescriptor implements AbstractCaching.Key; protected pointcut loadExecutions( Key key ): ContainerLoader.containerLoads( *, key ); } abstract aspect AbstractCaching { interface Key {} protected abstract pointcut loadExecutions(Key key); } class Key { } class ContainerDescriptor { } class ActiveContainer { } class ContainerLoader { public ActiveContainer createContainer(ContainerDescriptor c) { return null; } public pointcut containerLoads(ContainerLoader loader, ContainerDescriptor containerDesc ): this(loader) &amp;&amp; args(containerDesc) &amp;&amp; execution(ActiveContainer ContainerLoader.createContainer (ContainerDescriptor)); } First, here are the versions of AspectJ I'm using (this is a bash shell under cygwin on Windows XP): ~&gt; CLASSPATH='C:\aspectj1.0\lib\aspectjrt.jar' /cygdrive/c/aspectj1.0/bin/ajc - version ajc version 1.0.6 (built Jul 24, 2002 6:21 PM PST) running on java 1.4.1_02 ~&gt; CLASSPATH='C:\aspectj1.1\lib\aspectjrt.jar' /cygdrive/c/aspectj1.1/bin/ajc - version AspectJ Compiler 1.1.0 ~&gt; CLASSPATH='C:\aspectj1.1.1rc1 \lib\aspectjrt.jar' /cygdrive/c/aspectj1.1.1rc1/bin/ajc -version AspectJ Compiler 1.1.1rc1 ~&gt; CLASSPATH='C:\aspectj1.1.1 \lib\aspectjrt.jar' /cygdrive/c/aspectj1.1.1/bin/ajc -version AspectJ Compiler 1.1.1 For all four of these compilers, I give them the AspectBug.java file (which is attached): ~&gt; CLASSPATH='C:\aspectj1.0\lib\aspectjrt.jar' /cygdrive/c/aspectj1.0/bin/ajc AspectBug.java ~&gt; CLASSPATH='C:\aspectj1.1\lib\aspectjrt.jar' /cygdrive/c/aspectj1.1/bin/ajc AspectBug.java ~&gt; CLASSPATH='C:\aspectj1.1.1rc1 \lib\aspectjrt.jar' /cygdrive/c/aspectj1.1.1rc1/bin/ajc AspectBug.java ~&gt; CLASSPATH='C:\aspectj1.1.1 \lib\aspectjrt.jar' /cygdrive/c/aspectj1.1.1/bin/ajc AspectBug.java C:\Documents and Settings\Macneil Shonle\AspectBug.java:7 incompatible type, expected ContainerDescriptor found BindingTypePattern(AbstractCaching$Key, 0) 1 error As you can see, only the final run (with the Sept 11 build of ajc) do we see the "incompatible type" error. If this is not a regression but a desirable result, how should the code be ported?
"Language regression, or possible language improvement?" The file : First, here are the versions of AspectJ I'm using (this is a bash shell under cygwin on Windows XP): ~&gt;7 incompatible type, expected ContainerDescriptor found  1 error As you can see, only the final run (with the Sept 11 build of ajc) do we see the "incompatible type" error. If this is not a regression but a desirable result, how should the code be ported?
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.completeTypeBindings(),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.addAdviceLikeDeclares(ClassScope),False,new_method
tests/bugs/ParentsAndPointcuts.main(String[]),False,new_method|test_method
tests/bugs/ParentsAndPointcuts.containerLoads(ContainerLoader, ContainerDescriptor),False,new_method|test_method
org.aspectj.matcher/src/org/aspectj/weaver/CrosscuttingMembersSet.addAdviceLikeDeclares(ResolvedTypeX),False,new_method
org.aspectj.matcher/src/org/aspectj/weaver/CrosscuttingMembersSet.getDeclareDominates(),False,refactoring
weaver/src/org/aspectj/weaver/ResolvedTypeX.collectDeclares(),True
weaver/src/org/aspectj/weaver/ResolvedTypeX.collectCrosscuttingMembers(),True
weaver/src/org/aspectj/weaver/ResolvedTypeX.collectDeclares(boolean),True
#####
AspectJ
39993
026b2728aef846823419ebffceb57fe8161e3d15
ajc stack trace on declaring hashcode() method in aspect From an email sent to the user's list 6/26/2003: ------------------------------------------ ajc 1.1 NPE when an aspect declares hashcode() as follows: interface Identifiable { void setId(Id id); Id getId(); } aspect IdentifiableAspect { private Id Identifiable.id = null; public Id Identifiable.getId() { return this.id; } public void Identifiable.setId(Id id) { this.id = id; } public int Identifiable.hashCode() { return (this.getId() == null) ? super.hashCode() : this.getId().hashCode(); } } A workaround for callers the compiler controls is to replace the declaration with around advice: int around(Identifiable i): target(i) &amp;&amp; call(public int hashCode()) { return (i.getId() == null) ? proceed(i) : i.getId().hashCode(); }
ajc stack trace on declaring method in aspect From an email sent to the user's list 6/26/2003: ------------------------------------------ ajc 1.1 NPE when an aspect declares as follows: interface A workaround for callers the compiler controls is to replace the declaration with around advice
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterSuperFixerVisitor.InterSuperFixerVisitor(InterTypeDeclaration, EclipseFactory, Scope),False,new_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterSuperFixerVisitor.endVisit(FieldReference, BlockScope),False,new_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterSuperFixerVisitor.endVisit(MessageSend, BlockScope),False,new_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterSuperFixerVisitor.fixReceiver(Expression, BlockScope),False,new_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterSuperReference.InterSuperReference(SuperReference, TypeBinding),False,new_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterSuperReference.resolveType(BlockScope),False,new_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeDeclaration.resolve(ClassScope),False,new_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeDeclaration.fixSuperCallsForInterfaceContext(ClassScope),False,new_method
tests/bugs/OverridingInterfaceObjectMethod.main(String[]),False,new_method|test_method
tests/bugs/OverridingInterfaceObjectMethod.Id(int),False,new_method|test_method
weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.addNeededSuperCallMethods(BcelClassWeaver, ResolvedTypeX, Set),False,new_method
weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.mungeNewMethod(BcelClassWeaver, NewMethodTypeMunger),True
weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.makeDispatcher(LazyClassGen, String, ResolvedMember, BcelWorld, boolean),True
#####
AspectJ
43194
fc0d2af02cc6b6f8a4d9425e3c1cdd166957dde9
java.lang.VerifyError in generated code See the attached file VerifyBug.jar for the source files. You won't need anything else to compiler and reproduce this bug: ~/bug&gt; ls AbstractCaching.java TreeNode.java VerifyBug.jar ContainerCaching.java TreeNodeFolding.java WorkspaceGroup.java ContainerLoader.java TreePanel.java WorkspaceNode.java Makefile TreeWorkspace.java ~/bug&gt; gmake /cygdrive/c/aspectj1.1.1/bin/ajc -classpath "C:\aspectj1.1.1 \lib\aspectjrt.jar" -version AspectJ Compiler 1.1.1 /cygdrive/c/aspectj1.1.1/bin/ajc -classpath "C:\aspectj1.1.1\lib\aspectjrt.jar" *.java java -classpath "C:\aspectj1.1.1\lib\aspectjrt.jar;." TreeNode java.lang.VerifyError: (class: TreeNode, method: doShowAction signature: ()V) Unable to pop operand off an empty stack Exception in thread "main" make: *** [all] Error 1
in generated code See the attached file for the source files. You won't need anything else to compiler and reproduce this bug: ~/bug&gt; ls ~/bug&gt; gmake -classpath "" -version AspectJ Compiler 1.1.1 " : (class: , method: doShowAction signature: ()V) Unable to pop operand off an empty stack Exception in thread "main" make: *** [all] Error 1
******
tests/bugs/AdviceInteraction.main(String[]),False,test_method
org.aspectj.matcher/src/org/aspectj/weaver/patterns/ReferencePointcut.concretize1(ResolvedTypeX, IntMap),True
#####
AspectJ
43033
53570863fa77364052937376a0ff65ce2fa37842
Compiler crash in ajc head (post 1.1.1 rc1) on erroneous program This must be caused by the fix to concretization... Input sources: package base; public abstract aspect ExceptionHandling { public abstract pointcut scope(); declare soft: Exception: scope(); } package model; import base.ExceptionHandling; public aspect ModelExceptionHandling extends ExceptionHandling { public pointcut scope() : within(*); protected RuntimeException convertCheckedException(Throwable t) { return new RuntimeException(t.getMessage(), t } Compiler output: C:\eclipse\workspace\atrack&gt;ajc -d debug @narrow.lst java.lang.NullPointerException at org.aspectj.weaver.patterns.ReferencePointcut.concretize1 (ReferencePo intcut.java:243) at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:127) at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:110) at org.aspectj.weaver.CrosscuttingMembers.addDeclare (CrosscuttingMembers .java:111) at org.aspectj.weaver.CrosscuttingMembers.addDeclares (CrosscuttingMember s.java:92) at org.aspectj.weaver.ResolvedTypeX.collectCrosscuttingMembers (ResolvedT ypeX.java:332) at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect (Crosscut tingMembersSet.java:50) at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTy peAndPerClause(AspectDeclaration.java:754) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildIn terTypeAndPerClause(AjLookupEnvironment.java:124) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.complet eTypeBindings(AjLookupEnvironment.java:91) at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile (Compiler.ja va:310) at org.eclipse.jdt.internal.compiler.Compiler.compile (Compiler.java:324) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilat ion(AjBuildManager.java:373) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild (AjBuild Manager.java:125) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild (AjBu ildManager.java:70) at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:99) at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53) at org.aspectj.tools.ajc.Main.run(Main.java:217) at org.aspectj.tools.ajc.Main.runMain(Main.java:155) at org.aspectj.tools.ajc.Main.main(Main.java:72) C:\eclipse\workspace\atrack\src\org\atrack\model\error\impl\ModelExceptionHandl i ng.java:0 Internal compiler error java.lang.NullPointerException at org.aspectj.weaver.patterns.ReferencePointcut.concretize1 (ReferencePo intcut.java:243) at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:127) at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:110) at org.aspectj.weaver.CrosscuttingMembers.addDeclare (CrosscuttingMembers .java:111) at org.aspectj.weaver.CrosscuttingMembers.addDeclares (CrosscuttingMember s.java:92) at org.aspectj.weaver.ResolvedTypeX.collectCrosscuttingMembers (ResolvedT ypeX.java:332) at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect (Crosscut tingMembersSet.java:50) at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTy peAndPerClause(AspectDeclaration.java:754) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildIn terTypeAndPerClause(AjLookupEnvironment.java:124) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.complet eTypeBindings(AjLookupEnvironment.java:91) at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile (Compiler.ja va:310) at org.eclipse.jdt.internal.compiler.Compiler.compile (Compiler.java:324) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilat ion(AjBuildManager.java:373) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild (AjBuild Manager.java:125) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild (AjBu ildManager.java:70) at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:99) at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53) at org.aspectj.tools.ajc.Main.run(Main.java:217) at org.aspectj.tools.ajc.Main.runMain(Main.java:155) at org.aspectj.tools.ajc.Main.main(Main.java:72) !! no source information available !! C:\eclipse\workspace\atrack\src\org\atrack\model\error\impl\ModelExceptionHandl i ng.java:23 Unmatched bracket return new RuntimeException(t.getMessage(), t ^ ABORT Exception thrown from AspectJ DEVELOPMENT This might be logged as a bug already -- find current bugs at http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler Bugs for exceptions thrown have titles File:line from the top stack, e.g., "SomeFile.java:243" If you don't find the exception below in a bug, please add a new bug at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ To make the bug a priority, please include a test program that can reproduce this exception. null java.lang.NullPointerException at org.aspectj.weaver.patterns.ReferencePointcut.concretize1 (ReferencePo intcut.java:243) at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:127) at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:110) at org.aspectj.weaver.CrosscuttingMembers.addDeclare (CrosscuttingMembers .java:111) at org.aspectj.weaver.CrosscuttingMembers.addDeclares (CrosscuttingMember s.java:92) at org.aspectj.weaver.ResolvedTypeX.collectCrosscuttingMembers (ResolvedT ypeX.java:332) at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect (Crosscut tingMembersSet.java:50) at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTy peAndPerClause(AspectDeclaration.java:754) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildIn terTypeAndPerClause(AjLookupEnvironment.java:124) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.complet eTypeBindings(AjLookupEnvironment.java:91) at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile (Compiler.ja va:310) at org.eclipse.jdt.internal.compiler.Compiler.compile (Compiler.java:324) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilat ion(AjBuildManager.java:373) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild (AjBuild Manager.java:125) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild (AjBu ildManager.java:70) at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:99) at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53) at org.aspectj.tools.ajc.Main.run(Main.java:217) at org.aspectj.tools.ajc.Main.runMain(Main.java:155) at org.aspectj.tools.ajc.Main.main(Main.java:72) 1 fail|abort, 2 errors C:\eclipse\workspace\atrack&gt;cd \devel\test\excHandling\c1 C:\devel\test\excHandling\c1&gt;ajc base\ExceptionHandling.java model\ModelExceptio nHandling.java java.lang.NullPointerException at org.aspectj.weaver.patterns.ReferencePointcut.concretize1 (ReferencePo intcut.java:243) at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:127) at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:110) at org.aspectj.weaver.CrosscuttingMembers.addDeclare (CrosscuttingMembers .java:111) at org.aspectj.weaver.CrosscuttingMembers.addDeclares (CrosscuttingMember s.java:92) at org.aspectj.weaver.ResolvedTypeX.collectCrosscuttingMembers (ResolvedT ypeX.java:332) at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect (Crosscut tingMembersSet.java:50) at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTy peAndPerClause(AspectDeclaration.java:754) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildIn terTypeAndPerClause(AjLookupEnvironment.java:124) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.complet eTypeBindings(AjLookupEnvironment.java:91) at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile (Compiler.ja va:310) at org.eclipse.jdt.internal.compiler.Compiler.compile (Compiler.java:324) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilat ion(AjBuildManager.java:373) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild (AjBuild Manager.java:125) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild (AjBu ildManager.java:70) at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:99) at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53) at org.aspectj.tools.ajc.Main.run(Main.java:217) at org.aspectj.tools.ajc.Main.runMain(Main.java:155) at org.aspectj.tools.ajc.Main.main(Main.java:72) C:\devel\test\excHandling\c1\model\ModelExceptionHandling.java:0 Internal compil er error java.lang.NullPointerException at org.aspectj.weaver.patterns.ReferencePointcut.concretize1 (ReferencePo intcut.java:243) at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:127) at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:110) at org.aspectj.weaver.CrosscuttingMembers.addDeclare (CrosscuttingMembers .java:111) at org.aspectj.weaver.CrosscuttingMembers.addDeclares (CrosscuttingMember s.java:92) at org.aspectj.weaver.ResolvedTypeX.collectCrosscuttingMembers (ResolvedT ypeX.java:332) at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect (Crosscut tingMembersSet.java:50) at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTy peAndPerClause(AspectDeclaration.java:754) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildIn terTypeAndPerClause(AjLookupEnvironment.java:124) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.complet eTypeBindings(AjLookupEnvironment.java:91) at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile (Compiler.ja va:310) at org.eclipse.jdt.internal.compiler.Compiler.compile (Compiler.java:324) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilat ion(AjBuildManager.java:373) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild (AjBuild Manager.java:125) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild (AjBu ildManager.java:70) at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:99) at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53) at org.aspectj.tools.ajc.Main.run(Main.java:217) at org.aspectj.tools.ajc.Main.runMain(Main.java:155) at org.aspectj.tools.ajc.Main.main(Main.java:72) !! no source information available !! C:\devel\test\excHandling\c1\model\ModelExceptionHandling.java:9 Unmatched brack et return new RuntimeException(t.getMessage(), t ^ ABORT Exception thrown from AspectJ DEVELOPMENT This might be logged as a bug already -- find current bugs at http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler Bugs for exceptions thrown have titles File:line from the top stack, e.g., "SomeFile.java:243" If you don't find the exception below in a bug, please add a new bug at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ To make the bug a priority, please include a test program that can reproduce this exception. null java.lang.NullPointerException at org.aspectj.weaver.patterns.ReferencePointcut.concretize1 (ReferencePo intcut.java:243) at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:127) at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:110) at org.aspectj.weaver.CrosscuttingMembers.addDeclare (CrosscuttingMembers .java:111) at org.aspectj.weaver.CrosscuttingMembers.addDeclares (CrosscuttingMember s.java:92) at org.aspectj.weaver.ResolvedTypeX.collectCrosscuttingMembers (ResolvedT ypeX.java:332) at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect (Crosscut tingMembersSet.java:50) at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTy peAndPerClause(AspectDeclaration.java:754) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildIn terTypeAndPerClause(AjLookupEnvironment.java:124) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.complet eTypeBindings(AjLookupEnvironment.java:91) at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile (Compiler.ja va:310) at org.eclipse.jdt.internal.compiler.Compiler.compile (Compiler.java:324) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilat ion(AjBuildManager.java:373) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild (AjBuild Manager.java:125) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild (AjBu ildManager.java:70) at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:99) at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53) at org.aspectj.tools.ajc.Main.run(Main.java:217) at org.aspectj.tools.ajc.Main.runMain(Main.java:155) at org.aspectj.tools.ajc.Main.main(Main.java:72) 1 fail|abort, 2 errors
Compiler crash in ajc head (post 1.1.1 rc1) on erroneous program This must be caused by the fix to concretization... Input sources: package base; -d debug @ no source information available !! :9 Unmatched brack et , t ^ ABORT Exception thrown from AspectJ DEVELOPMENT This might be logged as a bug already -- find current bugs at http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler Bugs for exceptions thrown have titles File:line from the top stack, e.g., ":243" If you don't find the exception below in a bug, please add a new bug at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ To make the bug a priority, please include a test program that can reproduce this exception. null 
******
tests/bugs/concretizeNpe/model/ModelExceptionHandling.convertCheckedException(Throwable),False,test_method,new_method
org.aspectj.matcher/src/org/aspectj/weaver/patterns/ReferencePointcut.concretize1(ResolvedTypeX, IntMap),True
#####
AspectJ
43709
426d89b639c5f64504ff372b849495d75cdc7540
structure view crash when extending library aspects I have an library with an aspect that includes advice, which I compile into an outjar. In my client project I extend it, and make a concrete pointcut that results in the library aspect affecting parts of my system. There is a bug and an enhancement request here: 1) A bug: when you look at the structure view for affected classes, there is a problem if you try to navigate from calls to advice (in AJDT, it results in an NPE). Here is the stack trace in AJDT: java.lang.NullPointerException at org.aspectj.asm.internal.ProgramElement.toLinkLabelString (ProgramElement.java:403) at org.eclipse.ajdt.internal.core.AJDTStructureViewNode.getLabel (AJDTStructureViewNode.java:171) at org.eclipse.ajdt.internal.core.AJDTStructureViewNodeAdapter.getLabel (AJDTStructureViewNodeAdapter.java:89) at org.eclipse.ui.model.WorkbenchLabelProvider.getText (WorkbenchLabelProvider.java:142) at org.eclipse.jface.viewers.TreeViewer.doUpdateItem(TreeViewer.java:95) at org.eclipse.jface.viewers.AbstractTreeViewer$UpdateItemSafeRunnable.run (AbstractTreeViewer.java:87) at org.eclipse.core.internal.runtime.InternalPlatform.run (InternalPlatform.java:1006) at org.eclipse.core.runtime.Platform.run(Platform.java:413) at org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem (AbstractTreeViewer.java:406) at org.eclipse.jface.viewers.StructuredViewer$UpdateItemSafeRunnable.run (StructuredViewer.java:119) at org.eclipse.core.internal.runtime.InternalPlatform.run (InternalPlatform.java:1006) at org.eclipse.core.runtime.Platform.run(Platform.java:413) at org.eclipse.jface.viewers.StructuredViewer.updateItem (StructuredViewer.java:1271) at org.eclipse.jface.viewers.AbstractTreeViewer.createTreeItem (AbstractTreeViewer.java:320) at org.eclipse.jface.viewers.AbstractTreeViewer$1.run (AbstractTreeViewer.java:303) at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69) at org.eclipse.jface.viewers.AbstractTreeViewer.createChildren (AbstractTreeViewer.java:289) at org.eclipse.jface.viewers.AbstractTreeViewer.handleTreeExpand (AbstractTreeViewer.java:697) at org.eclipse.jface.viewers.AbstractTreeViewer$4.treeExpanded (AbstractTreeViewer.java:709) at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:175) at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81) at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840) at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:865) at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:849) at org.eclipse.swt.widgets.Tree.wmNotifyChild(Tree.java:1909) at org.eclipse.swt.widgets.Control.WM_NOTIFY(Control.java:3815) at org.eclipse.swt.widgets.Composite.WM_NOTIFY(Composite.java:642) at org.eclipse.swt.widgets.Control.windowProc(Control.java:2816) at org.eclipse.swt.widgets.Display.windowProc(Display.java:2361) at org.eclipse.swt.internal.win32.OS.CallWindowProcW(Native Method) at org.eclipse.swt.internal.win32.OS.CallWindowProc(OS.java:1236) at org.eclipse.swt.widgets.Tree.callWindowProc(Tree.java:156) at org.eclipse.swt.widgets.Tree.WM_LBUTTONDOWN(Tree.java:1517) at org.eclipse.swt.widgets.Control.windowProc(Control.java:2799) at org.eclipse.swt.widgets.Display.windowProc(Display.java:2361) at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method) at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:1303) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1543) at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1402) at org.eclipse.ui.internal.Workbench.run(Workbench.java:1385) at org.eclipse.core.internal.boot.InternalBootLoader.run (InternalBootLoader.java:858) at org.eclipse.core.boot.BootLoader.run(BootLoader.java:461) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) at java.lang.reflect.Method.invoke(Unknown Source) at org.eclipse.core.launcher.Main.basicRun(Main.java:291) at org.eclipse.core.launcher.Main.run(Main.java:747) at org.eclipse.core.launcher.Main.main(Main.java:583) 2) The enhancement request: the concrete aspect that applies the advice should also show what is affected in the project. Of course, it would also be nice to see how a given concrete library aspect in the aspect path affects your project too.
structure view crash when extending library aspects I have an library with an aspect that includes advice, which I compile into an outjar. In my client project I extend it, and make a concrete pointcut that results in the library aspect affecting parts of my system. There is a bug and an enhancement request here: 1) A bug: when you look at the structure view for affected classes, there is a problem if you try to navigate from calls to advice (in AJDT, it results in an NPE). Here is the stack trace in AJDT:  2) The enhancement request: the concrete aspect that applies the advice should also show what is affected in the project. Of course, it would also be nice to see how a given concrete library aspect in the aspect path affects your project too.
******
asm/src/org/aspectj/asm/internal/ProgramElement.toLinkLabelString(),True
#####
AspectJ
44117
311725549a379f2bd3c0fcce2aaaae50b7a92ddb
NPE on compile java.lang.NullPointerException at org.aspectj.weaver.AsmRelationshipProvider.checkerMunger (AsmRelationshipProvider.java:51) at org.aspectj.weaver.Checker.match(Checker.java:58) at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:985) at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:791) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:291) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:77) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:417) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:390) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:316) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.weaveAndGenerateClassFile s(AjBuildManager.java:256) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild (AjBuildManager.java:156) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild (AjBuildManager.java:70) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:103) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run (AspectJBuildManager.java:165)
NPE on compile
******
weaver/src/org/aspectj/weaver/AsmRelationshipProvider.checkerMunger(IHierarchy, Shadow, Checker),True
asm/src/org/aspectj/asm/IRelationship,True
#####
AspectJ
47318
bdc79f1b42c11fe2bcaa45bbaa5a063173777d28
org.aspectj.asm.IRelationship.Kind.ALL does not contain all kinds org.aspectj.asm.IRelationship.Kind.ALL is an array that should contain all kinds that an IRelationship may have. There are three possible kinds defined in IRelationship.java: ADVICE, DECLARE and DECLARE_INTER_TYPE. The Kind[] ALL does only contain ADVICE and DECLARE. This can lead to an ArrayIndexOutOfBoundsException.
does not contain all kinds is an array that should contain all kinds that an  may have. There are three possible kinds defined in: ,  and . The does only contain  and . This can lead to an.
******
org.aspectj/modules/asm/src/org/aspectj/asm/IRelationship,True
#####
AspectJ
39436
d90acdcedd63f04b906b0efc5e249e93245f5618
[Tasks] No summary shown in status line build I20030625 The old tasks view showed a summary of the number of tasks, errors, warnings and infos in the status line. This is missing in the reworked view.
[Tasks] No summary shown in status line build I20030625 The old tasks view showed a summary of the number of tasks, errors, warnings and infos in the status line. This is missing in the reworked view.
******
weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.unpackLocals(MethodGen),True
weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.packBody(MethodGen),True
#####
AspectJ
41952
97ab1e91dfba52187c14f0f7e5fdf6fafd9966c4
XLint warning for call PCD's using subtype of defining type Some would like an XLint compiler warning when the user in a call PCD specifies a declaring type that is not the defining type, because that constrains the join points to those whose bytecode signature contain the specified type as the declaring type. e.g., ---- class A { void run() {} } class B extends A {} aspect C { before() : call(void B.run()) { } // warn here } public class Main { public static void main(String[] args) { // ok with -1.4; otherwise, becomes A.run in bytecode new B().run(); // never works - compile-time type of reference is A, not B ((A) new B()).run(); } ---- This warning is useful for two reasons. First, the user probably intended that any call to an instance of that object be picked out (regardless of the compile-time type of the reference used to make the call), and thus should use target(B) &amp;&amp; call(void run()) (This suggestion could be in the XLint message.) Second, older compilers (i.e., compilers not using -1.4) would incorrectly specify the declaring type of the method call as the first type in the hierarchy which defined the method, so even if the user meant to constrain the join point by the compile-time reference type, the bytecode signature could be incorrect and the pointcut fail to pick out the join point. One problem with this XLint warning is that is also picks out valid declare warning/error statements enforcing requirements at compile-time about the type of the reference used to invoke a method (e.g., when using a static reference of the wrong type). So perhaps the default level should be ignore. See also bug 41888.
XLint warning for call PCD's using subtype of defining type Some would like an XLint compiler warning when the user in a call PCD specifies a declaring type that is not the defining type, because that constrains the join points to those whose bytecode signature contain the specified type as the declaring type. e.g., ----  ---- This warning is useful for two reasons. First, the user probably intended that any call to an instance of that object be picked out (regardless of the compile-time type of the reference used to make the call), and thus should use target(B) &amp;&amp;  (This suggestion could be in the XLint message.) Second, older compilers (i.e., compilers not using -1.4) would incorrectly specify the declaring type of the method call as the first type in the hierarchy which defined the method, so even if the user meant to constrain the join point by the compile-time reference type, the bytecode signature could be incorrect and the pointcut fail to pick out the join point. One problem with this XLint warning is that is also picks out valid declare warning/error statements enforcing requirements at compile-time about the type of the reference used to invoke a method (e.g., when using a static reference of the wrong type). So perhaps the default level should be ignore. See also bug 41888.
******
tests/new/CallTypesI,False,test
bridge/src/org/aspectj/bridge/IMessage.getExtraSourceLocations(),False,new_method
bridge/src/org/aspectj/bridge/Message.Message(String, String, IMessage.Kind, ISourceLocation),True
bridge/src/org/aspectj/bridge/Message.Message(String, IMessage.Kind, Throwable, ISourceLocation),True
bridge/src/org/aspectj/bridge/Message.toString(),True
bridge/src/org/aspectj/bridge/Message.renderToString(IMessage),True
bridge/src/org/aspectj/bridge/Message.getExtraSourceLocations(),Flase,new_method
bridge/src/org/aspectj/bridge/MessageUtil.renderMessage(IMessage, boolean),True
bridge/src/org/aspectj/bridge/MessageUtil.addExtraSourceLocations(IMessage , String),False,new_method
bridge/src/org/aspectj/bridge/SourceLocation.toString(),True
org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.render(IMessage),True
testing/src/org/aspectj/testing/xml/SoftMessage.getExtraSourceLocations(),False,new_method|test_method
tests/bugs/DeclaringTypeWarning.run(),False,test_method|new_method
weaver/src/org/aspectj/weaver/Checker.match(Shadow, World),True
weaver/src/org/aspectj/weaver/Lint.signal(String, ISourceLocation),True
weaver/src/org/aspectj/weaver/Lint.signal(String[], ISourceLocation, ISourceLocation[]),False,new_method
weaver/src/org/aspectj/weaver/patterns/AndPointcut.concretize1(ResolvedTypeX, IntMap),True
weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.toString(),True
weaver/src/org/aspectj/weaver/patterns/KindedPointcut.KindedPointcut(Shadow.Kind, SignaturePattern),False,refactoring
weaver/src/org/aspectj/weaver/patterns/KindedPointcut.KindedPointcut(Shadow.Kind, SignaturePattern, ShadowMunger),False,new_method
weaver/src/org/aspectj/weaver/patterns/KindedPointcut.match(Shadow),True
weaver/src/org/aspectj/weaver/patterns/KindedPointcut.warnOnConfusingSig(Shadow),False,new_method
weaver/src/org/aspectj/weaver/patterns/KindedPointcut.concretize1(ResolvedTypeX, IntMap),True
weaver/src/org/aspectj/weaver/patterns/NotPointcut.concretize1(ResolvedTypeX, IntMap),True
weaver/src/org/aspectj/weaver/patterns/OrPointcut.concretize1(ResolvedTypeX, IntMap),True
weaver/src/org/aspectj/weaver/patterns/Pointcut.concretize1(ResolvedTypeX, IntMap),True
weaver/src/org/aspectj/weaver/patterns/Pointcut.shouldCopyLocationForConcretize(),False,new_method
weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.concretize1(ResolvedTypeX, IntMap),True
weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.shouldCopyLocationForConcretize(),False,new_method
weaver/src/org/aspectj/weaver/patterns/SignaturePattern.getModifiers(),False,new_method
weaver/src/org/aspectj/weaver/patterns/SignaturePattern.getParameterTypes(),False,new_method
weaver/src/org/aspectj/weaver/patterns/SignaturePattern.getReturnType(),False,new_method
weaver/src/org/aspectj/weaver/patterns/SignaturePattern.getThrowsPattern(),False,new_method
#####
AspectJ
49250
eac16aee966695c8f0d22c4961c63a27e61dd2bf
alias getCause for getWrappedThrowable in SoftException SoftException should implement getCause(): public Throwable getCause() { return inner; } (As pointed out by Ramnivas, misc mail messages, code comments...) Using getCause() means the chain should print as expected in 1.4+, esp. when SoftException is itself wrapped as a RemoteException. Since getCause() replicates getWrappedThrowable(), we could deprecate that, but we must continue to support it to maintain upwards binary compatibility in the runtime classes.
alias for in  should implement (As pointed out by Ramnivas, misc mail messages, code comments...) Using means the chain should print as expected in 1.4+, esp. when is itself wrapped as a. Since replicates , we could deprecate that, but we must continue to support it to maintain upwards binary compatibility in the runtime classes.
******
runtime/src/org/aspectj/lang/SoftException.getCause(),False,new_method
#####
AspectJ
47754
7322131ad6d3c5c14114a6b7945757f45d438112
illegal method modifier the attached example throws this at class load time. please note that this bug results in a different exception when happens in a different setup, and when the class is loaded by JBoss. (more cryptic, talking about generic class format error) Exception in thread "main" java.lang.ClassFormatError: com/netvisor/nvsr/client/InvalidByteCodeBug$Test$ITest (Illegal method modifiers: 0x409) at java.lang.ClassLoader.defineClass0(Native Method) at java.lang.ClassLoader.defineClass(ClassLoader.java:537) at java.security.SecureClassLoader.defineClass(SecureClassLoader.java: 123) at java.net.URLClassLoader.defineClass(URLClassLoader.java:251) at java.net.URLClassLoader.access$100(URLClassLoader.java:55) at java.net.URLClassLoader$1.run(URLClassLoader.java:194) at java.security.AccessController.doPrivileged(Native Method) at java.net.URLClassLoader.findClass(URLClassLoader.java:187) at java.lang.ClassLoader.loadClass(ClassLoader.java:289) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:274) at java.lang.ClassLoader.loadClass(ClassLoader.java:235) at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:302) at java.lang.ClassLoader.defineClass0(Native Method) at java.lang.ClassLoader.defineClass(ClassLoader.java:537) at java.security.SecureClassLoader.defineClass(SecureClassLoader.java: 123) at java.net.URLClassLoader.defineClass(URLClassLoader.java:251) at java.net.URLClassLoader.access$100(URLClassLoader.java:55) at java.net.URLClassLoader$1.run(URLClassLoader.java:194) at java.security.AccessController.doPrivileged(Native Method) at java.net.URLClassLoader.findClass(URLClassLoader.java:187) at java.lang.ClassLoader.loadClass(ClassLoader.java:289) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:274) at java.lang.ClassLoader.loadClass(ClassLoader.java:235) at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:302) at com.netvisor.nvsr.client.InvalidByteCodeBug.run(InvalidByteCodeBug. java:15) at com.netvisor.nvsr.client.InvalidByteCodeBug.main(InvalidByteCodeBug. java:8)
illegal method modifier the attached example throws this at class load time. please note that this bug results in a different exception when happens in a different setup, and when the class is loaded by JBoss. (more cryptic, talking about generic class format error) Exception in thread "main" 
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.resolveStatements(),True
#####
AspectJ
49638
7b081f2e0bece3414ac4f385cde75d7b54981099
exception logging: after() throwing advice can't convert Throwable obj to string and ajc aborts The problem is found by the example in Listing 5.15 from Laddad's AspectJ in Action book. It looks like an exception object in after() throwing(Throwable ex) advice has a problem being converted to string in a _logger.logp() call. Environment ----------- OS: Solaris 8 kernel patch level 108528-27 plus j2se recommended patches Java version: java -version java version "1.4.2" Java(TM) 2 Runtime Environment, Standard Edition (build 1.4.2-b28) Java HotSpot(TM) Client VM (build 1.4.2-b28, mixed mode) The problem has also been reproduced with AspectJ 1.1.1 on Windows 2000 5.00.2195, SP 4. Description ----------- ajc aborts with the following output: trouble in: public class TestException extends java.lang.Object: public static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_0 public static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_1 public void &lt;init&gt;(): ALOAD_0 // TestException this (line 1) INVOKESPECIAL java.lang.Object.&lt;init&gt; ()V constructor-execution(void TestException.&lt;init&gt;()) | RETURN constructor-execution(void TestException.&lt;init&gt;()) end public void &lt;init&gt;() public static void main(String[]): method-execution(void TestException.main(java.lang.String[])) | method-call(void TestException.perform()) | | catch java.lang.Throwable -&gt; E0 | | | INVOKESTATIC TestException.perform ()V (line 4) | | catch java.lang.Throwable -&gt; E0 | | GOTO L0 | | E0: ASTORE_1 | | INVOKESTATIC ExceptionLoggerAspectV2.aspectOf ()LExceptionLoggerAspectV2; | | ALOAD_1 | | GETSTATIC TestException.ajc$tjp_0 Lorg/aspectj/lang/JoinPoint$StaticPart; | | INVOKEVIRTUAL ExceptionLoggerAspectV2.ajc$after$ExceptionLoggerAspectV2$14a (Ljava/lang/Throwable;Lorg/aspectj/lang/JoinPoint$StaticPart;)V | | ALOAD_1 | | ATHROW | | L0: NOP | | ACONST_NULL | | ASTORE_2 | | INVOKESTATIC ExceptionLoggerAspectV2.aspectOf ()LExceptionLoggerAspectV2; | | ALOAD_2 | | CHECKCAST java.lang.Throwable | | GETSTATIC TestException.ajc$tjp_0 Lorg/aspectj/lang/JoinPoint$StaticPart; | | INVOKEVIRTUAL ExceptionLoggerAspectV2.ajc$after$ExceptionLoggerAspectV2$14a (Ljava/lang/Throwable;Lorg/aspectj/lang/JoinPoint$StaticPart;)V | | NOP | method-call(void TestException.perform()) | RETURN (line 5) method-execution(void TestException.main(java.lang.String[])) end public static void main(String[]) public static void perform(): method-execution(void TestException.perform()) | ACONST_NULL (line 8) | ASTORE_0 | ALOAD_0 // java.lang.Object nullObj (line 9) | method-call(java.lang.String java.lang.Object.toString()) | | catch java.lang.Throwable -&gt; E0 | | | INVOKEVIRTUAL java.lang.Object.toString ()Ljava/lang/String; | | catch java.lang.Throwable -&gt; E0 | | GOTO L0 | | E0: ASTORE_1 | | INVOKESTATIC ExceptionLoggerAspectV2.aspectOf ()LExceptionLoggerAspectV2; | | ALOAD_1 | | GETSTATIC TestException.ajc$tjp_1 Lorg/aspectj/lang/JoinPoint$StaticPart; | | INVOKEVIRTUAL ExceptionLoggerAspectV2.ajc$after$ExceptionLoggerAspectV2$14a (Ljava/lang/Throwable;Lorg/aspectj/lang/JoinPoint$StaticPart;)V | | ALOAD_1 | | ATHROW | | L0: NOP | method-call(java.lang.String java.lang.Object.toString()) | POP | RETURN (line 10) method-execution(void TestException.perform()) end public static void perform() end public class TestException ABORT Exception thrown from AspectJ 1.1.1 This might be logged as a bug already -- find current bugs at http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler Bugs for exceptions thrown have titles File:line from the top stack, e.g., "SomeFile.java:243" If you don't find the exception below in a bug, please add a new bug at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ To make the bug a priority, please include a test program that can reproduce this exception. can't convert from java.lang.String to java.lang.Throwable can't convert from java.lang.String to java.lang.Throwable org.aspectj.weaver.BCException: can't convert from java.lang.String to java.lang.Throwable at org.aspectj.weaver.bcel.Utility.appendConversion(Utility.java:203) at org.aspectj.weaver.bcel.BcelVar.appendLoadAndConvert(BcelVar.java:57) at org.aspectj.weaver.bcel.BcelAdvice.getAdviceArgSetup(BcelAdvice.java:287) at org.aspectj.weaver.bcel.BcelAdvice.getAdviceInstructions(BcelAdvice.java:244) at org.aspectj.weaver.bcel.BcelShadow.weaveAfterReturning(BcelShadow.java:986) at org.aspectj.weaver.bcel.BcelShadow.weaveAfter(BcelShadow.java:941) at org.aspectj.weaver.bcel.BcelAdvice.implementOn(BcelAdvice.java:126) at org.aspectj.weaver.Shadow.implementMungers(Shadow.java:341) at org.aspectj.weaver.Shadow.implement(Shadow.java:313) at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:1006) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:9) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:77) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:417) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:390) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:327) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.weaveAndGenerateClassFiles(AjBuildManager.java:256) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:156) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:70) at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:99) at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53) at org.aspectj.tools.ajc.Main.run(Main.java:217) at org.aspectj.tools.ajc.Main.runMain(Main.java:155) at org.aspectj.tools.ajc.Main.main(Main.java:72) 1 fail|abort Sample code is two files, TextException.java and ExceptionLoggerAspectV2.java (see below). To reproduce the problem, do $ ajc *.java File 1 - TestException.java ---------------------------- public class TestException { public static void main(String[] args) { perform(); } public static void perform() { Object nullObj = null; nullObj.toString(); } } File 2 - ExceptionLoggerAspectV2.java ------------------------------------- import java.util.logging.*; import org.aspectj.lang.*; public aspect ExceptionLoggerAspectV2 { Logger _logger = Logger.getLogger("exceptions"); ExceptionLoggerAspectV2() { _logger.setLevel(Level.ALL); } pointcut exceptionLogMethods() : call(* *.*(..)) &amp;&amp; !within(ExceptionLoggerAspectV2); after() thowing(Throwable ex) : exceptionLogMethods() { if (_logger.isLoggable(Level.WARNING)) { Signature sig = thisJoinPointStaticPart.getSignature(); _logger.logp(Level.WARNING, sig.getDeclaringType().getName(), sig.getName(), "Exception logger aspect", ex); } } }
exception logging: throwing advice can't convert Throwable obj to string and ajc aborts The problem is found by the example in Listing 5.15 from Laddad's AspectJ in Action book. It looks like an exception object in  advice has a problem being converted to string in a call. Environment ----------- OS: Solaris 8 kernel patch level 108528-27 plus j2se recommended patches Java version: java -version java version "1.4.2" Java(TM) 2 Runtime Environment, Standard Edition (build 1.4.2-b28) Java HotSpot(TM) Client VM (build 1.4.2-b28, mixed mode) The problem has also been reproduced with AspectJ 1.1.1 on Windows 2000 5.00.2195, SP 4. Description ----------- ajc aborts with the following output: trouble in: ------------------------------------- 
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/parser/AjParser.consumeExtraParameterNoFormal(),True
tests/bugs/AfterThrowingAdviceSyntaxError.main(String[]),False,new_method|test_method
tests/bugs/AfterThrowingAdviceSyntaxError.perform(),False,new_method|test_method
tests/bugs/AfterThrowingAdviceSyntaxError.exceptionLogMethods(),False,new_method|test_method
#####
AspectJ
46280
7bbd1f419239dc9e8b46e7fd912b2bc007bbd76a
compiler issues error on inner aspects when privilieged The compiler complains that "inner aspects must be static" whenever I try to qualify an inner (and static) aspect as privileged, no matter what the enclosing type is (aspect, interface or class). I was using j2sdk1.4.0_02, AspectJ 1.1, eclipse 2.1 (with AJDT 1.1.3). Test case: ------------------ BASE CLASS: public class Capsule { private int hidden; public int visible; public Capsule(int priv, int pub) { hidden = priv; visible = pub; } public void doSomething() { System.out.println(""" + hidden + ", " + visible + """); } public static void main(String[] args) { Capsule capsule = new Capsule(1, 1); capsule.doSomething(); } } ------------------ ASPECT: public aspect Outer { static //privileged &lt;== JUST TRY TO UNCOMMENT THIS! aspect Inner { pointcut call2doSomething(Capsule capsule): call(void Capsule.doSomething()) &amp;&amp; target(capsule); before(Capsule capsule): call2doSomething(capsule) { capsule.visible++; //capsule.hidden++; } } } ------------------ INTERFACE: public interface Marker { static //privileged &lt;== JUST TRY TO UNCOMMENT THIS! aspect Inner { pointcut call2doSomething(Capsule capsule): call(void Capsule.doSomething()) &amp;&amp; target(capsule); before(Capsule capsule): call2doSomething(capsule) { capsule.visible++; //capsule.hidden++; } } }
compiler issues error on inner aspects when privilieged The compiler complains that "inner aspects must be static" whenever I try to qualify an inner (and static) aspect as privileged, no matter what the enclosing type is (aspect, interface or class). I was using j2sdk1.4.0_02, AspectJ 1.1, eclipse 2.1 (with AJDT 1.1.3). Test case: ------------------ BASE CLASS: public class ------------------ ASPECT:  //privileged &lt;== JUST TRY TO UNCOMMENT THIS! aspect 
******
tests/bugs/PrivilegedParsing.doSomething(),False,new_method|test_method
tests/bugs/PrivilegedParsing.PrivilegedParsing(int, int),False,new_method|test_method
tests/bugs/PrivilegedParsing.main(String[]),False,new_method|test_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/parser/AjParser.consumeAspectHeaderName(boolean),True
#####
AspectJ
50570
19bac866e44563dad29b6bebefa31c4e354ee96c
CatchClauseSignature has broken operation It looks like the getParameterName() operation on org.aspectj.lang.reflect. CatchClauseSignature is not working. Instead of returning the name of the exception as declared in the matched handler, returns the string value "&lt;missing&gt;". Here is a test case that shows the problem :- ------START OF TEST CASE CODE----------- public class MyApp { public void doSomething() { // Get around "unreachable code error... if (true) { throw new BusinessException("Surprise!!"); } System.out.println("Busy doing something."); } public static void main(String[] args) { try { MyApp m = new MyApp(); m.doSomething(); } catch (BusinessException be) { System.out.println("Exception caught : " + be.getMessage()); } } } class BusinessException extends RuntimeException { BusinessException(String message) { super(message); } } aspect AppMonitor { pointcut problemHandling() : handler(Throwable+); before() : problemHandling() { CatchClauseSignature cSig = (CatchClauseSignature) thisJoinPointStaticPart.getSignature(); System.out.println( "MONITOR::\tCaught a " + cSig.getParameterType().getName() + " called " + cSig.getParameterName()); } } ------END OF TEST CASE CODE----------- The output from running the above was ... MONITOR:: Caught a BusinessException called &lt;missing&gt; Exception caught : Surprise !!!! Operating system : Windows XP AspectJ : 1.1.1 final and also on latest from CVS HEAD
CatchClauseSignature has broken operation It looks like the getParameterName() operation on org.aspectj.lang.reflect. CatchClauseSignature is not working. Instead of returning the name of the exception as declared in the matched handler, returns the string value "&lt;missing&gt;". Here is a test case that shows the problem :- ------START OF TEST CASE CODE-----------  ------END OF TEST CASE CODE----------- The output from running the above was ... MONITOR:: Caught a BusinessException called &lt;missing&gt; Exception caught : Surprise !!!! Operating system : Windows XP AspectJ : 1.1.1 final and also on latest from CVS HEAD
******
weaver/src/org/aspectj/weaver/ResolvedMember,True
tests/bugs/HandlerSig.doSomething(),False,new_method|test_method
tests/bugs/HandlerSig.main(String[]),False,new_method|test_method
tests/bugs/HandlerSig.BusinessException(String),False,new_method|test_method
weaver/src/org/aspectj/weaver/Member.makeExceptionHandlerSignature(TypeX, TypeX),True
weaver/src/org/aspectj/weaver/Member.getHandlerSignatureString(World),True
weaver/src/org/aspectj/weaver/bcel/BcelShadow.makeExceptionHandler(BcelWorld, ExceptionRange, LazyMethodGen, InstructionHandle, BcelShadow),True
weaver/src/org/aspectj/weaver/bcel/BcelShadow.findHandlerParamName(InstructionHandle),False,new_method
#####
AspectJ
49457
c517e8507cbc0be482d3eb1be2694e3f6486a4e3
No error on overloaded pointcuts unless binding variables The compiler might not be detecting overloaded pointcut names when parameters are not bound, and/or might not be implementing the pointcut correctly. Below is the context from my reply to Ron Bodkin on aspectj-dev "Proper behavior of overloaded pointcut definitions". (I have not checked this code recently or submitted a test case, nor have I evaluated whether my code below actually replicates Ron's bug.) ---- context from the email The programming guide says, It is an error for two pointcuts to be named with the same name in the same class or aspect declaration. When I compile with overloaded pointcut names, I do get an error. pointcut pc(Runnable r) : target(r) &amp;&amp; call(void run()); pointcut pc(SubRunnable r) : target(r) &amp;&amp; call(void run()); $ aspectj-1.1.1 -classpath $ajrt11 OverloadedPointcut.java ...\OverloadedPointcut.java:14 duplicate pointcut name: pc ...\OverloadedPointcut.java:15 duplicate pointcut name: pc ... When I use these pointcuts with bound parameters, I get an error. before(Runnable r) : pc(r) { log("pc(Runnable r)"); } before(SubRunnable r) : pc(r) { log("pc(SubRunnable r)"); } When I use these pointcuts with type parameters, I get no errors. before() : pc(Runnable) { log("pc(Runnable)"); } before() : pc(SubRunnable) { log("pc(SubRunnable)"); } before() : pc(*) { log("pc(*)"); } [...] ---- my code public class OverloadedPointcut { public static void main(String[] args) { new C().run(); } } class C { public void run() {} } aspect A { declare parents: C implements Runnable; declare parents: C implements SubRunnable; interface SubRunnable extends Runnable {} pointcut pc(Runnable r) : target(r) &amp;&amp; call(void run()); pointcut pc(SubRunnable r) : target(r) &amp;&amp; call(void run()); before(Runnable r) : pc(r) { log("pc(Runnable r)"); } before(SubRunnable r) : pc(r) { log("pc(SubRunnable r)"); } before() : pc(Runnable) { log("pc(Runnable)"); } before() : pc(SubRunnable) { log("pc(SubRunnable)"); } before() : pc(*) { log("pc(*)"); } void log(String s) { System.out.println(s); } } ---- Ron's code [...] the following program compiles with no warnings, produces no output when run under AspectJ 1.1.1. It appears to behave as if the more specific definition is the only definition of the pointcut [...] Here is a simple program that illustrates the question and odd behavior: package lib; public class RunnablePointcuts { public pointcut runnableCalls(Runnable runnable, Object caller) : call(* run(..)) &amp;&amp; target(runnable) &amp;&amp; this(caller); //public pointcut specialRunnableCalls(SpecialRunnable runnable, Object caller) : public pointcut runnableCalls(SpecialRunnable runnable, Object caller) : call(* run(..)) &amp;&amp; target(runnable) &amp;&amp; this(caller); } --- package lib; public interface SpecialRunnable extends Runnable { } --- package client; import lib.RunnablePointcuts; import lib.SpecialRunnable; public aspect Use { before(Object caller) : RunnablePointcuts.runnableCalls(*, caller) &amp;&amp; target(MyRunnable) { System.out.println("my runnable called from "+caller); } public static void main(String args[]) { Use.aspectOf().doIt(); } public void doIt() { new MyRunnable().run(); } } // the advice will run if you make this implement SpecialRunnable //class MyRunnable implements SpecialRunnable { class MyRunnable implements Runnable { public void run() {} }
No error on overloaded pointcuts unless binding variables The compiler might not be detecting overloaded pointcut names when parameters are not bound, and/or might not be implementing the pointcut correctly. Below is the context from my reply to Ron Bodkin on aspectj-dev "Proper behavior of overloaded pointcut definitions". (I have not checked this code recently or submitted a test case, nor have I evaluated whether my code below actually replicates Ron's bug.) ---- context from the email The programming guide says, It is an error for two pointcuts to be named with the same name in the same class or aspect declaration. When I compile with overloaded pointcut names, I do get an error. ... When I use these pointcuts with bound parameters, I get an error.  ---- Ron's code [...] the following program compiles with no warnings, produces no output when run under AspectJ 1.1.1. It appears to behave as if the more specific definition is the only definition of the pointcut [...] Here is a simple program that illustrates the question and odd behavior: 
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.resolve(),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.resolvePointcutDeclarations(ClassScope),True
tests/bugs/OverloadedPointcutsInAspect.main(String[]),False,new_method|test_method
tests/bugs/OverloadedPointcutsInAspect.run(),False,new_method|test_method
#####
AspectJ
48091
0c833438dadeeb26659cd901870d18d2c103658b
Lazy instantiation of thisJoinPoint In cases where the body of advice refers to a non-statically evaluable portion of thisJoinPoint (so that it can't be optimized by the compiler to thisJoinPointStaticPart), the JoinPoint object is currently always created before entering the advice body - even if the JoinPoint object would never actually be accessed (because of a test within the advice for example). Since a) thisJoinPoint is often used in tracing applications b) tracing applications tend to be very pervasive, c) they must have low overhead when tracing is disabled, and d) creation of thisJoinPoint objects is expensive (v. expensive compared to just testing a flag) it would be nice if there was a way to create JoinPoint objects lazily on first actual reference within the advice body.
Lazy instantiation of thisJoinPoint In cases where the body of advice refers to a non-statically evaluable portion of thisJoinPoint (so that it can't be optimized by the compiler to thisJoinPointStaticPart), the JoinPoint object is currently always created before entering the advice body - even if the JoinPoint object would never actually be accessed (because of a test within the advice for example). Since a) thisJoinPoint is often used in tracing applications b) tracing applications tend to be very pervasive, c) they must have low overhead when tracing is disabled, and d) creation of thisJoinPoint objects is expensive (v. expensive compared to just testing a flag) it would be nice if there was a way to create JoinPoint objects lazily on first actual reference within the advice body.
******
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests,False,test
weaver/src/org/aspectj/weaver/Lint,True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.parseOption(String, LinkedList),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.isXlazyTjp(),False,new_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.setXlazyTjp(boolean),False,new_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.initBcelWorld(IMessageHandler),True
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/CommandTestCase.checkCompile(String, int[]),False,test_method
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/CommandTestCase.checkCompile(String, String[], int[]),False,test_method|new_method
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/PerformanceTestCase.PerformanceTestCase(String),False,test_method
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/PerformanceTestCase.xxx_testLazyTjpOff(),False,test_method|new_method
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/PerformanceTestCase.testLazyTjp(),False,test_method|new_method
runtime/src/org/aspectj/runtime/reflect/Factory.makeJP(JoinPoint.StaticPart, Object, Object, Object[]),True
runtime/src/org/aspectj/runtime/reflect/Factory.makeJP(JoinPoint.StaticPart, Object, Object, Object)False,test_method|new_method
runtime/src/org/aspectj/runtime/reflect/Factory.makeJP(JoinPoint.StaticPart, Object, Object, Object, Object)False,test_method|new_method
weaver/src/org/aspectj/weaver/World.isXlazyTjp(),False,new_method
weaver/src/org/aspectj/weaver/World.setXlazyTjp(boolean),False,new_method
weaver/src/org/aspectj/weaver/bcel/BcelAdvice.specializeOn(Shadow),True
weaver/src/org/aspectj/weaver/bcel/BcelAdvice.getAdviceArgSetup(BcelShadow, BcelVar, InstructionList),True
weaver/src/org/aspectj/weaver/bcel/BcelShadow.prepareForMungers(),True
weaver/src/org/aspectj/weaver/bcel/BcelShadow.getThisJoinPointVar(),True
weaver/src/org/aspectj/weaver/bcel/BcelShadow.getThisJoinPointBcelVar(),True
weaver/src/org/aspectj/weaver/bcel/BcelShadow.initializeThisJoinPoint(),False,new_method
weaver/src/org/aspectj/weaver/bcel/BcelShadow.checkLazyTjp(),False,new_method
weaver/src/org/aspectj/weaver/bcel/BcelShadow.loadThisJoinPoint(),False,new_method
weaver/src/org/aspectj/weaver/bcel/BcelShadow.createThisJoinPoint(),False,new_method
#####
AspectJ
51929
6ddae42579ceb781831e08f0fcf77a4ff4ffb5c0
Advice calling protected super method causing java.lang.VerifyError 'Bad access to protected data' A java.lang.VerifyError is thrown at runtime complaining about 'Bad access to protected data' when advice, on a sub-aspect, that calls a protected method, on the super-aspect, is woven into a class. However another call to the same method woven into the same class but due to advice declared in the super-aspect works fine. The aspects were woven into precompiled (by sun's 1.4 javac) classes. The verify error occurs under both sun's 1.4 and blackdowns 1.3 VMs, and presumably all VMs. Workaround: Making the protected method public fixes the verify error. A test case is available in CVS: tests/bugs/protectedvf/... tests/ajcTestFailing.xml
Advice calling protected super method causing 'Bad access to protected data' A is thrown at runtime complaining about 'Bad access to protected data' when advice, on a sub-aspect, that calls a protected method, on the super-aspect, is woven into a class. However another call to the same method woven into the same class but due to advice declared in the super-aspect works fine. The aspects were woven into precompiled (by sun's 1.4 javac) classes. The verify error occurs under both sun's 1.4 and blackdowns 1.3 VMs, and presumably all VMs. Workaround: Making the protected method public fixes the verify error. A test case is available in CVS: 
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.endVisit(SingleNameReference, BlockScope),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.endVisit(QualifiedNameReference, BlockScope),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.endVisit(FieldReference, BlockScope),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.getAccessibleField(FieldBinding),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.getAccessibleMethod(MethodBinding),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.visit(localTypeDeclaration, BlockScope),False,new_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.makeResolvedMember(MethodBinding),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.makeResolvedMember(MethodBinding binding, TypeBinding),False,new_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InlineAccessFieldBinding.InlineAccessFieldBinding(AspectDeclaration, FieldBinding),True
tests/bugs/protectedvf/main/Driver.doOtherStuff(),False,comments
tests/bugs/protectedvf/main/Driver.doStuff(),False,comments
#####
AspectJ
36430
16a0abd70e5fe2538c32994de05f52b6bf939ef5
Support -Xreweavable option Adding a RFE as Wes suggested... Wes' reply: There are some issues with the -Xnoweave option that we won't have the time to carefully resolve for 1.1, even though, as you suggest, there may be times when it would be useful. The workaround at present is to weave tracing into transactions when the transactions jar is compiled. e.g., -- do the build ajc @tracing.lst -outjar tracing.jar ajc @transactions.lst -aspectpath tracing.jar \ -outjar transactions.jar ajc @app.lst -aspectpath "tracing.jar;transactions.jar" \ -outjar app.jar -- build the jar mkdir final cd final jar xf ../tracing.jar jar xf ../transactions.jar jar xf ../app.jar # fixup manifest, etc? jar cf ../final.jar * What if you don't have the sources for the transactions.jar? This is a case of getting binary transactions aspects from a vendor who won't provide source and wanting to weave your tracing into it. I would hope that by the time that problem becomes prevalent, we will have a solution for it. If you'd like to keep this on the radar, please submit this discussion as an RFE for the compiler at http://dev.eclipse.org/bugs/enter_bug.cgi?product=AspectJ Thank you - Wes P.S. - Personally, I think this case &gt; &gt; ajc -injars app.jar;transaction.jar &gt; -aspectpath transaction.jar;tracing.jar doesn't make sense. Things on the aspectpath are defined, whereas things in injars will be woven into and redefined. It's not clear from this command which variant the user expects when refering to a type in transactions.jar. Ramnivas Laddad wrote: &gt; &gt; Hello, &gt; &gt; I think I have a use case that cannot be implemented &gt; (at least elegantly, anyway) without noweave/XnoWeave &gt; option (and thus I request to make it a regular option &gt; instead of experimental -X). &gt; &gt; Basically, I want to have my tracing.jar ( &gt; contains tracing aspect) weave into transaction.jar &gt; (contains abstract transaction mangement aspects, &gt; concrete policy enforcement aspects, and supporting &gt; classes). Assume app.jar contain business classes &gt; and interfaces. Each of the jar is created using &gt; -ourjar (but not -noweave or -XnoWeave). &gt; &gt; To build the final system I issue the following &gt; command: &gt; &gt; ajc -injars app.jar;transaction.jar &gt; -aspectpath transaction.jar;tracing.jar &gt; &gt; Now compiler gives me error due to multiply woven &gt; classes and aspects in transaction.jar. &gt; &gt; Everything works fine if I create the original jar &gt; files using -noweave. &gt; &gt; I could workaround by creating multiple jars, but &gt; I hink -noweave is the right approach as &gt; I really don't want to ship multiple jars that are &gt; needed to implement a single concern and expect the &gt; users to correctly specify jar files in -injars &gt; and -aspectpath. &gt; &gt; -Ramnivas
Support -Xreweavable option Adding a RFE as Wes suggested... Wes' reply: There are some issues with the -Xnoweave option that we won't have the time to carefully resolve for 1.1, even though, as you suggest, there may be times when it would be useful. The workaround at present is to weave tracing into transactions when the transactions jar is compiled. e.g., -- do the build ajc -- build the jar mkdir final cd final jar xf ../ jar xf ../jar xf ../ # fixup manifest, etc? jar cf ../ * What if you don't have the sources for the ? This is a case of getting binary transactions aspects from a vendor who won't provide source and wanting to weave your tracing into it. I would hope that by the time that problem becomes prevalent, we will have a solution for it. If you'd like to keep this on the radar, please submit this discussion as an RFE for the compiler at http://dev.eclipse.org/bugs/enter_bug.cgi?product=AspectJ Thank you - Wes P.S. - Personally, I think this case &gt; &gt; ajc -injars ; &gt; -aspectpath ; doesn't make sense. Things on the aspectpath are defined, whereas things in injars will be woven into and redefined. It's not clear from this command which variant the user expects when refering to a type in. Ramnivas Laddad wrote: &gt; &gt; Hello, &gt; &gt; I think I have a use case that cannot be implemented &gt; (at least elegantly, anyway) without noweave/XnoWeave &gt; option (and thus I request to make it a regular option &gt; instead of experimental -X). &gt; &gt; Basically, I want to have my ( &gt; contains tracing aspect) weave into &gt; (contains abstract transaction mangement aspects, &gt; concrete policy enforcement aspects, and supporting &gt; classes). Assume contain business classes &gt; and interfaces. Each of the jar is created using &gt; -ourjar (but not -noweave or -XnoWeave). &gt; &gt; To build the final system I issue the following &gt; command: &gt; &gt; ajc -injars ; &gt; -aspectpath  &gt; &gt; Now compiler gives me error due to multiply woven &gt; classes and aspects in . &gt; &gt; Everything works fine if I create the original jar &gt; files using -noweave. &gt; &gt; I could workaround by creating multiple jars, but &gt; I hink -noweave is the right approach as &gt; I really don't want to ship multiple jars that are &gt; needed to implement a single concern and expect the &gt; users to correctly specify jar files in -injars &gt; and -aspectpath. &gt; &gt; -Ramnivas
******
ajde/testsrc/org/aspectj/ajde/AjdeTests,True
ajde.core/testdata/ReweavableTest/CalculatePI.main(String[]),False,test_method,new_method
ajde.core/testdata/ReweavableTest/CalculatePI.approximate(),False,test_method,new_method
ajde/testdata/ReweavableTest/tjp/Demo.main(String[]),False,test_method,new_method
ajde/testdata/ReweavableTest/tjp/Demo.go(),False,test_method,new_method
ajde/testdata/ReweavableTest/tjp/Demo.foo(int, Object),False,test_method,new_method
ajde/testdata/ReweavableTest/tjp/Demo.bar(Integer),False,test_method,new_method
ajde/testdata/ReweavableTest/tjp/GetInfo.println(String),False,test_method,new_method
ajde/testdata/ReweavableTest/tjp/GetInfo.printParameters(JoinPoint),False,test_method,new_method
ajde/testsrc/org/aspectj/ajde/AjdeTests.ReweavableTestCase(String),False,test_method,new_method
ajde/testsrc/org/aspectj/ajde/AjdeTests.setUp(),False,test_method,new_method
ajde/testsrc/org/aspectj/ajde/AjdeTests.testNonReweavableCompile(),False,test_method,new_method
ajde/testsrc/org/aspectj/ajde/AjdeTests.testReweavableCompile(),False,test_method,new_method
ajde/testsrc/org/aspectj/ajde/AjdeTests.testReweavableCompressCompile(),False,test_method,new_method
ajde/testsrc/org/aspectj/ajde/AjdeTests.testReweavableSimpleCompile(),False,test_method,new_method
ajde/testsrc/org/aspectj/ajde/AjdeTests.testForReweavableSimpleErrorCompile(),False,test_method,new_method
ajde/testsrc/org/aspectj/ajde/AjdeTests.testErrorScenario2Compile(),False,test_method,new_method
ajde/testsrc/org/aspectj/ajde/AjdeTests.testWorkingScenario2Compile(),False,test_method,new_method
ajde/testsrc/org/aspectj/ajde/AjdeTests.start(String),False,test_method,new_method
ajde/testsrc/org/aspectj/ajde/AjdeTests.setProgressText(String),False,test_method,new_method
ajde/testsrc/org/aspectj/ajde/AjdeTests.setProgressBarVal(int),False,test_method,new_method
ajde/testsrc/org/aspectj/ajde/AjdeTests.incrementProgressBarVal(),False,test_method,new_method
ajde/testsrc/org/aspectj/ajde/AjdeTests.setProgressBarMax(int),False,test_method,new_method
ajde/testsrc/org/aspectj/ajde/AjdeTests.getProgressBarMax(),False,test_method,new_method
ajde/testsrc/org/aspectj/ajde/AjdeTests.finish(),False,test_method,new_method
ajde/testsrc/org/aspectj/ajde/AjdeTests.checkFor(String),False,test_method,new_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.arseOption(String arg, LinkedList),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.setInPath(List),False,new_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.setXreweavable(boolean),False,new_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.isXreweavable(),False,new_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.setXreweavableCompressClasses(boolean),False,new_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.getXreweavableCompressClasses(),False,new_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.initBcelWorld(IMessageHandler),True
taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.setXReweavable(boolean),False,new_method
taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.readArguments(String[]),True
testing/src/org/aspectj/testing/harness/bridge/CompilerRun.CRSOptions.CRSOptions(),True
weaver/src/org/aspectj/weaver/Advice.makeCflowEntry(World, Pointcut, boolean, Member, int, List),True
weaver/src/org/aspectj/weaver/Advice.makeSoftener(World, Pointcut, TypePattern),True
weaver/src/org/aspectj/weaver/CrosscuttingMembers.addDeclare(Declare),True
weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.findAspectDeclaringParents(DeclareParents),False,new_method
weaver/src/org/aspectj/weaver/Shadow.getMungers(),False,new_method
weaver/src/org/aspectj/weaver/WeaverStateInfo.WeaverStateInfo(),True
weaver/src/org/aspectj/weaver/WeaverStateInfo.WeaverStateInfo(List, boolean),True
weaver/src/org/aspectj/weaver/WeaverStateInfo.setReweavableModeDefaults(boolean, boolean),False,new_method
weaver/src/org/aspectj/weaver/WeaverStateInfo.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/WeaverStateInfo.write(DataOutputStream),True
weaver/src/org/aspectj/weaver/WeaverStateInfo.getUnwovenClassFileData(),False,new_method
weaver/src/org/aspectj/weaver/WeaverStateInfo.setUnwovenClassFileData(byte[]),False,new_method
weaver/src/org/aspectj/weaver/WeaverStateInfo.public boolean isReweavable(),False,new_method
weaver/src/org/aspectj/weaver/WeaverStateInfo.setReweavable(boolean,boolean),False,new_method
weaver/src/org/aspectj/weaver/WeaverStateInfo.addAspectsAffectingType(Collection),False,new_method
weaver/src/org/aspectj/weaver/WeaverStateInfo.addAspectAffectingType(String),False,new_method
weaver/src/org/aspectj/weaver/WeaverStateInfo.getAspectsAffectingType(),False,new_method
weaver/src/org/aspectj/weaver/WeaverStateInfo.weaver/src/org/aspectj/weaver/WeaverStateInfo.readAnyReweavableData(WeaverStateInfo,DataInputStream),False,new_method
weaver/src/org/aspectj/weaver/WeaverStateInfo.writeAnyReweavableData(WeaverStateInfo wsi,DataOutputStream),False,new_method
weaver/src/org/aspectj/weaver/bcel/BcelCflowStackFieldAdder.BcelCflowStackFieldAdder(ResolvedMember),True
weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.weave(),True
weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.signaturesMatch(LazyMethodGen, LazyMethodGen),True
weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.setReweavableMode(boolean,boolean),False,new_method
weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.findAspectsForMungers(LazyMethodGen),False,new_method
weaver/src/org/aspectj/weaver/bcel/BcelObjectType.setJavaClass(JavaClass),False,new_method
weaver/src/org/aspectj/weaver/bcel/BcelWeaver.weave(ResolvedTypeX),True
weaver/src/org/aspectj/weaver/bcel/BcelWeaver.weave(),True
weaver/src/org/aspectj/weaver/bcel/BcelWeaver.setReweavableMode(boolean,boolean),False,new_method
weaver/src/org/aspectj/weaver/bcel/LazyClassGen.isReweavable(),False,new_method
weaver/src/org/aspectj/weaver/bcel/LazyClassGen.getAspectsAffectingType(),False,new_method
weaver/src/org/aspectj/weaver/patterns/CflowPointcut.concretize1(ResolvedTypeX, IntMap),True
#####
AspectJ
51320
fbc0aa305ea367e5fbeb99acf9907ae3a155f16a
ClasscastException on concretization of if(false) I get the following exception when weaving the attached aspect on the dev build. java.lang.ClassCastException at org.aspectj.weaver.patterns.IfPointcut.concretize1(IfPointcut.java:156) at org.aspectj.weaver.patterns.IfPointcut.concretize(IfPointcut.java:143) at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:119) at org.aspectj.weaver.Checker.concretize(Checker.java:35) at org.aspectj.weaver.CrosscuttingMembers. addShadowMunger(CrosscuttingMembers.java:78) at org.aspectj.weaver.CrosscuttingMembers.addDeclare(CrosscuttingMembers. java:102) at org.aspectj.weaver.CrosscuttingMembers.addDeclares(CrosscuttingMembers. java:92) at org.aspectj.weaver.CrosscuttingMembersSet. addAdviceLikeDeclares(CrosscuttingMembersSet.java:65) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment. addAdviceLikeDeclares(AjLookupEnvironment.java:147) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment. completeTypeBindings(AjLookupEnvironment.java:122) at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java: 300) at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:314) at org.aspectj.ajdt.internal.core.builder.AjBuildManager. performCompilation(AjBuildManager.java:384) at org.aspectj.ajdt.internal.core.builder.AjBuildManager. doBuild(AjBuildManager.java:125) at org.aspectj.ajdt.internal.core.builder.AjBuildManager. batchBuild(AjBuildManager.java:70) at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:104) at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53) at org.aspectj.tools.ajc.Main.run(Main.java:234) at org.aspectj.tools.ajc.Main.runMain(Main.java:170) at org.aspectj.tools.ajc.Main.main(Main.java:81)
on concretization of if(false) I get the following exception when weaving the attached aspect on the dev build.
******
tests/bugs/DecwClassCastException.main(String[]),False,new_method|test_method
weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.concretize1(ResolvedTypeX, IntMap),True
weaver/src/org/aspectj/weaver/patterns/CflowPointcut.concretize1(ResolvedTypeX, IntMap),True
weaver/src/org/aspectj/weaver/patterns/IfPointcut.concretize1(ResolvedTypeX, IntMap),True
weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.concretize1(ResolvedTypeX, IntMap),True
#####
AspectJ
48080
087842e53c2f60333d1114f8781fa77f619175e8;81f46417ee1a681422598479eaf01bf544098f76
Context information in declare warning/error messages *** to be discussed on aspectj-dev / users before implementing *** We have found it useful to be able to include contextual information in the messages produced by declare warning /error. We want to be able to write something like: declare warning: call(* com.ibm.ws..*(..)) : "Call to protected WAS API: %s"; and get the compiler message: "Call to protected WAS API: void com.ibm.ws.SomeClass.someMethod(boolean)" We prototyped a solution using substitution variables as follows: %% inserts a % character %k inserts the joinpoint kind %s inserts the signature at the joinpoint %t inserts the name of the declaring type at the joinpoint %i inserts the name of the identifier at the joinpoint %j inserts a string representation of the joinpoint %f inserts the filename where the match was found %l inserts the line number where the match was found %a inserts the file and line number of the declare error/warning definition (this may not be the perfect set...) Here's a complete mini-example showing all the subsitutions in action : Hello.java ========= public class Hello { public static void main(String[] args) { System.out.println("Hello"); new Hello().sayItToo(); } private void sayItToo() { System.out.println("me too"); } } Warn.java ========= public aspect Warn { declare warning : execution(* Hello.*(..)) : "My warning:\n%%k=%k\n%%s=%s\n%%t=%t\n%%i=%i\n%%j=%j\n%%f=%f\n%%l=% l\n%%a=%a"; declare warning : call(* Hello.*(..)) : "Illegal call to %t.%i(..)"; } To get the following output: C:\ColyerRoot\Data\AspectJDev\eclipse\workspace\Notes\decwtest\Hello.java:4 Illegal call to Hello.sayItToo(..) C:\ColyerRoot\Data\AspectJDev\eclipse\workspace\Notes\decwtest\Hello.java:3 My warning: %k=method-execution %s=void Hello.main(java.lang.String[]) %t=Hello %i=main %j=method-execution(void Hello.main(java.lang.String[])) %f=C:\ColyerRoot\Data\AspectJDev\eclipse\workspace\Notes\decwtest\Hello.java %l=3 %a=C:\ColyerRoot\Data\AspectJDev\eclipse\workspace\Notes\decwtest\Warn.java:3 C:\ColyerRoot\Data\AspectJDev\eclipse\workspace\Notes\decwtest\Hello.java:8 My warning: %k=method-execution %s=void Hello.sayItToo() %t=Hello %i=sayItToo %j=method-execution(void Hello.sayItToo()) %f=C:\ColyerRoot\Data\AspectJDev\eclipse\workspace\Notes\decwtest\Hello.java %l=8 %a=C:\ColyerRoot\Data\AspectJDev\eclipse\workspace\Notes\decwtest\Warn.java:3 3 warnings The following patch implements the extension (warning - based on a version of Checker.java from a while back). Index: Checker.java =================================================================== RCS file: /home/technology/org. aspectj/modules/weaver/src/org/aspectj/weaver/Checker.java,v retrieving revision 1.5 diff -u -r1.5 Checker.java --- Checker.java 12 Mar 2003 19:51:43 -0000 1.5 +++ Checker.java 19 Jul 2003 12:34:12 -0000 @@ -17,6 +17,7 @@ import java.util.Collections; import org.aspectj.bridge.IMessage; +import org.aspectj.bridge.ISourceLocation; import org.aspectj.bridge.Message; import org.aspectj.weaver.patterns.DeclareErrorOrWarning; import org.aspectj.weaver.patterns.PerClause; @@ -49,7 +50,7 @@ public boolean match(Shadow shadow, World world) { if (super.match(shadow, world)) { world.getMessageHandler().handleMessage( - new Message(msg, + new Message(format(msg,shadow), isError ? IMessage.ERROR : IMessage.WARNING, null, shadow.getSourceLocation())); @@ -63,5 +64,85 @@ } public Collection getThrownExceptions() { return Collections.EMPTY_LIST; } + +// %% inserts a % character +// %k inserts the joinpoint kind +// %s inserts the signature at the joinpoint +// %t inserts the name of the declaring type at the joinpoint +// %i inserts the name of the identifier at the joinpoint +// %j inserts a string representation of the joinpoint +// %J inserts an extended string representation of the joinpoint +// %f inserts the filename where the match was found +// %l inserts the line number where the match was found +// %a inserts the name of the aspect where the declare was defined + private String format(String msg, Shadow shadow) { + StringBuffer ret = new StringBuffer(); + for(int i = 0; i &lt; msg.length(); i++) { + if (msg.charAt(i) != '%') { + ret.append(msg.charAt(i)); + } else { + // its a substitution character + int subCharPos = i+1; + if (subCharPos &lt; msg.length()) { + i++; // consume it + substitute(ret,shadow,msg.charAt(i)); + } + } + } + return ret.toString(); + } + + /** + * @param buf the buffer in which to insert the substitution + * @param shadow shadow from which to draw context info + * @param c the substitution character + */ + private void substitute(StringBuffer ret, Shadow shadow, char c) { + ISourceLocation loc; + switch(c) { + case '%': + ret.append('%'); + break; + case 'k': // kind + ret.append(shadow.getKind().getName()); + break; + case 's': + ret.append(shadow.getSignature()); + break; + case 't': + ret.append(shadow.getEnclosingType()); + break; + case 'i': + ret.append(shadow.getSignature().getName()); + break; + case 'j': + case 'J': + ret.append(shadow.toString()); + break; + case 'f': // file name + loc = shadow.getSourceLocation(); + if ((loc != null) &amp;&amp; (loc.getSourceFile() != null)) { + ret.append(loc.getSourceFile().toString()); + } + break; + case 'l': // line number + loc = shadow.getSourceLocation(); + if (loc != null) { + ret.append(loc.getLine()); + } + break; + case 'a': // aspect file and line number + loc = getSourceLocation(); + if ((loc != null) &amp;&amp; (loc.getSourceFile() != null)) { + ret.append(loc.getSourceFile().toString()); + ret.append(':'); + ret.append(loc.getLine()); + } + break; + default: // unknown substitution character, leave alone + ret.append('%'); + ret.append(c); + } + } }
Context information in declare warning/error messages *** to be discussed on aspectj-dev / users before implementing *** We have found it useful to be able to include contextual information in the messages produced by declare warning /error. We want to be able to write something like: declare warning: : "Call to protected WAS API: %s"; and get the compiler message: "Call to protected WAS API: void " We prototyped a solution using substitution variables as follows: %% inserts a % character %k inserts the joinpoint kind %s inserts the signature at the joinpoint %t inserts the name of the declaring type at the joinpoint %i inserts the name of the identifier at the joinpoint %j inserts a string representation of the joinpoint %f inserts the filename where the match was found %l inserts the line number where the match was found %a inserts the file and line number of the declare error/warning definition (this may not be the perfect set...) Here's a complete mini-example showing all the subsitutions in action : Hello.java ============================================================================ RCS file: ,v retrieving revision 1.5 diff -u -r1.5 ---  12 Mar 2003 19:51:43 -0000 1.5 +++ 19 Jul 2003 12:34:12 -0000 @@ -17,6 +17,7 @@  + +// %% inserts a % character +// %k inserts the joinpoint kind +// %s inserts the signature at the joinpoint +// %t inserts the name of the declaring type at the joinpoint +// %i inserts the name of the identifier at the joinpoint +// %j inserts a string representation of the joinpoint +// %J inserts an extended string representation of the joinpoint +// %f inserts the filename where the match was found +// %l inserts the line number where the match was found +// %a inserts the name of the aspect where the declare was defined +
******
org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.render(IMessage),True
org.aspectj.matcher/src/org/aspectj/weaver/Checker.getMessage(),True
org.aspectj.matcher/src/org/aspectj/weaver/Checker.nextCurly(String, int),False,new_method
org.aspectj.matcher/src/org/aspectj/weaver/Checker.format(String, Shadow),False,new_method
org.aspectj.matcher/src/org/aspectj/weaver/Checker.getValue(String, Shadow),False,new_method
weaver/src/org/aspectj/weaver/bcel/BcelWorld.reportCheckerMatch(Checker, Shadow),True
tests/bugs169/pr48080/A.m(),false,new_method|test_method
tests/src/org/aspectj/systemtest/ajc169/Ajc169Tests.testAmbiguousMethod(),false,new_method|test_method
tests/src/org/aspectj/systemtest/ajc169/Ajc169Tests.testChecker(),false,new_method|test_method
tests/src/org/aspectj/systemtest/ajc169/Ajc169Tests.testVerifyError(),false,new_method|test_method
tests/src/org/aspectj/systemtest/ajc169/Ajc169Tests.testDeclareTypeWarning2(),false,new_method|test_method
tests/src/org/aspectj/systemtest/ajc169/Ajc169Tests.testDeclareTypeWarning3(),false,new_method|test_method
tests/src/org/aspectj/systemtest/ajc169/Ajc169Tests.testDeclareTypeError1(),false,new_method|test_method
#####
AspectJ
44272
01095341153b24fcf5ab5f537ecc77077819b1f1
"retitle warning to ""circular {advice} dependency at ...""" When writing aspects with cycles in the advice precedence, get warning "circular dependency at {join point}" -- should be "circular advice dependency..." or "circular advice precedences at {join point} -- reorder the advice in the aspect". FWIW, here's an example of circularity in advice precedence: ---- aspect A { pointcut crun() : execution (void run()) ; before() : crun() {} after() returning : crun() {} void around() : crun() { proceed(); } } ---- See programming guide for more discussion of circularity in advice precedence.
"retitle warning to ""circular {advice} dependency at ...""" When writing aspects with cycles in the advice precedence, get warning "circular dependency at {join point}" -- should be "circular advice dependency..." or "circular advice precedences at {join point} -- reorder the advice in the aspect". FWIW, here's an example of circularity in advice precedence: ---- aspect A  ---- See programming guide for more discussion of circularity in advice precedence.
******
tests/bugs/CircularAdvicePrecedence.run(),False,new_method|test_method
weaver/src/org/aspectj/weaver/Shadow.sortMungers(),True
weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.resolve(IScope),True
#####
AspectJ
51322
5c67166488df998bc208567c2fd27f21b52592c5
Introduce Unknown Type to class causes Null pointer exception Introduce method with an unknown type as an arguement as follows: class A {} public abstract aspect B { public void A.someMethod(WCharType a) { //blah } } WCharType is an unknown type or is forgotten to be imported (in my case). This shall cause ajc to puke the following: java.lang.NullPointerException at org.aspectj.ajdt.internal.compiler.ast.InterTypeMethodDeclaration.build(InterTypeMethodDeclaration .java:87) at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTypeAndPerClause(AspectDeclarat ion.java:744) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildInterTypeAndPerClause(AjLookupE nvironment.java:206) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnviron ment.java:94) at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:310) at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:324) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:373) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:125) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:70) at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:99) at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53) at org.aspectj.tools.ajc.Main.run(Main.java:217) at org.aspectj.tools.ajc.Main.runMain(Main.java:155) at org.aspectj.tools.ajc.Main.main(Main.java:72) /home/czhang/eclipse/workspace/lib/libajob/org/omg/PortableServer/portable/Delegate.java:0 Internal compiler error java.lang.NullPointerException at org.aspectj.ajdt.internal.compiler.ast.InterTypeMethodDeclaration.build(InterTypeMethodDeclaration .java:87) at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTypeAndPerClause(AspectDeclarat ion.java:744) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildInterTypeAndPerClause(AjLookupE nvironment.java:206) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnviron ment.java:94) at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:310) at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:324) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:373) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:125) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:70) at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:99) at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53) at org.aspectj.tools.ajc.Main.run(Main.java:217) at org.aspectj.tools.ajc.Main.runMain(Main.java:155) at org.aspectj.tools.ajc.Main.main(Main.java:72) !! no source information available !! !! no source information available !! ABORT Exception thrown from AspectJ 1.1.1 This might be logged as a bug already -- find current bugs at http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler Bugs for exceptions thrown have titles File:line from the top stack, e.g., "SomeFile.java:243" If you don't find the exception below in a bug, please add a new bug at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ To make the bug a priority, please include a test program that can reproduce this exception. null java.lang.NullPointerException at org.aspectj.ajdt.internal.compiler.ast.InterTypeMethodDeclaration.build(InterTypeMethodDeclaration .java:87) at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTypeAndPerClause(AspectDeclarat ion.java:744) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildInterTypeAndPerClause(AjLookupE nvironment.java:206) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnviron ment.java:94) at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:310) at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:324) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:373) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:125) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:70) at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:99) at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53) at org.aspectj.tools.ajc.Main.run(Main.java:217) at org.aspectj.tools.ajc.Main.runMain(Main.java:155) at org.aspectj.tools.ajc.Main.main(Main.java:72) 1 fail|abort, 1 error
Introduce Unknown Type to class causes Null pointer exception Introduce method with an unknown type as an arguement as follows: is an unknown type or is forgotten to be imported (in my case). This shall cause ajc to puke the following: !! no source information available !! !! no source information available !! ABORT Exception thrown from AspectJ 1.1.1 This might be logged as a bug already -- find current bugs at http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler Bugs for exceptions thrown have titles File:line from the top stack, e.g., "" If you don't find the exception below in a bug, please add a new bug at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ To make the bug a priority, please include a test program that can reproduce this exception. 1 fail|abort, 1 error
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.build(ClassScope),True
#####
AspectJ
54965
41c6f6d0a10e881ac705a108cdd59f31d160e1c7
Incremental compilation does twice as much work as necessary When I added support for -outjar in the test harness, I was surprised to find duplicate entry exceptions coming from the output file writing to the outjar. I traced it through, and found that every source file passed to an incremental compile is in fact compiled twice! The first time round we note the references, and of course each file has a reference to itself. Then we call "AjState.getFilesToCompile" looking to see if there are any further files to compile in another iteration. This method does not remember the set of files it just compiled, so since we have referenced each type we just compiled, and we have no reord of that fact, we compile them again. Second time around, the bytecodes are identical to the previous go, so recordClassFile doesn't note their dependents - and thus this time we terminate.
Incremental compilation does twice as much work as necessary When I added support for - in the test harness, I was surprised to find duplicate entry exceptions coming from the output file writing to the outjar. I traced it through, and found that every source file passed to an incremental compile is in fact compiled twice! The first time round we note the references, and of course each file has a reference to itself. Then we call "" looking to see if there are any further files to compile in another iteration. This method does not remember the set of files it just compiled, so since we have referenced each type we just compiled, and we have no reord of that fact, we compile them again. Second time around, the bytecodes are identical to the previous go, so doesn't note their dependents - and thus this time we terminate.
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.getFilesToCompile(boolean),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.prepareForNextBuild(AjBuildConfig),False,comments
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.addAffectedSourceFiles(List),True
#####
AspectJ
47910
34dbb0c41b3e324e3c7fc5a150c314fbecfd5e6e
ajc -outjar jarfile does not contain MANIFEST.MF I call ajc -sourceroots &lt;mydir&gt; -outjar &lt;my.jar&gt; and an output file is created with a .jar extension, but it is not a valid jar file because there is no MANIFEST.MF file. I see that the text for ajc says: -outjar &lt;file&gt; put output classes in zip file &lt;file&gt; which might imply that it is supposed to be a zip file, but a parameter called - outjar which creates a zip file doesn't really make sense. If -outjar is used, the resulting file should be a valid jar file, i.e. with a META-INF/MANIFEST.MF file inside.
ajc  does not contain  I call  and an output file is created with a .jar extension, but it is not a valid jar file because there is no file. I see that the text for ajc says:  put output classes in zip file  which might imply that it is supposed to be a zip file, but a parameter called  which creates a zip file doesn't really make sense. If is used, the resulting file should be a valid jar file, i.e. with a file inside.
******
ajde/testdata/JarManifestTest/src/Main.println(),False,test_method|new_method
ajde/testdata/JarManifestTest/src/Main.main(String[]),False,test_method|new_method
ajde/testsrc/org/aspectj/ajde/AjdeTests.suite(),False,test_method
ajde/testsrc/org/aspectj/ajde/InpathTestcase.fetchFromJar(File, String),True
ajde/testsrc/org/aspectj/ajde/InpathTestcase.compareJars(File, String, File, Set),True
ajde/testsrc/org/aspectj/ajde/InpathTestcase.compareSourceToOutjar(String, File),True
ajde/testsrc/org/aspectj/ajde/JarManifestTest.JarManifestTest(String),False,test_method,new_method
ajde/testsrc/org/aspectj/ajde/JarManifestTest.setUp(),False,test_method,new_method
ajde/testsrc/org/aspectj/ajde/JarManifestTest.testWeave(),False,test_method,new_method
ajde/testsrc/org/aspectj/ajde/JarManifestTest.testNoweave(),False,test_method,new_method
ajde/testsrc/org/aspectj/ajde/JarManifestTest.checkManifest(File),False,test_method,new_method
ajde/testsrc/org/aspectj/ajde/ResourceCopyTestCase.compareSourceToOutjar(String, File),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.openOutputStream(File),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.copyResourcesFromJarFile(File),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.writeManifest(),False,new_method
weaver/src/org/aspectj/weaver/bcel/BcelWeaver.addJarFile(File, File, boolean),True
weaver/src/org/aspectj/weaver/bcel/BcelWeaver.addManifest(Manifest),False,new_method
weaver/src/org/aspectj/weaver/bcel/BcelWeaver.getManifest(boolean),False,new_method
#####
AspectJ
52394
5d73494d7d222b92cdbb19f860f9215a07430681
inter-type declarations cause JRockit Crash BEA's JRockit JVM (version: 8.1sp2-1.4.1_05-Load10-viking-win32-sthqa29-20031105-1554) crashes on simple inter-type declarations. (Obviously I have also submitted this bug to BEA, but the AJ team may be able to shed some light on what is going on and where (if anywhere) BEA's JVM is behaving wrong.) The cannonical example lies below: public class SimpleClass { public static void main(String[] args) { SimpleClass simple = new SimpleClass(); } } public aspect SimpleAspect { public int SimpleClass.foo; } When running SimpleClass I get a JVM crash with the following thread stack trace. Thread Stack Trace: at _exprPush+112 ()@0082FF70 at COM.jrockit.vm.RNI.toNative(Native Method)@32520000 at COM.jrockit.vm.RNI.clinitTrampoline(Native Method)@325200FA at com.vms.adbase.jvmcrashtest.SimpleClass.&lt;init&gt;(SimpleClass.java:4)@344B0055 at com.vms.adbase.jvmcrashtest.SimpleClass.main(SimpleClass.java:6)@344B0034 --- End of stack trace Feel free to ask me for further details. JRockit can be downloaded at: http://commerce.bea.com/showallversions.jsp?family=WLJR. I reproduced this error on Windows XP, but it also happend on RedHat. Is it worth adding JRockit to AspectJ's compatibility test suite?
inter-type declarations cause JRockit Crash BEA's JRockit JVM (version: 8.1sp2-1.4.1_05-Load10-viking-win32-sthqa29-20031105-1554) crashes on simple inter-type declarations. (Obviously I have also submitted this bug to BEA, but the AJ team may be able to shed some light on what is going on and where (if anywhere) BEA's JVM is behaving wrong.) The cannonical example lies below:  When running I get a JVM crash with the following thread stack trace. --- End of stack trace Feel free to ask me for further details. JRockit can be downloaded at: http://commerce.bea.com/showallversions.jsp?family=WLJR. I reproduced this error on Windows XP, but it also happend on RedHat. Is it worth adding JRockit to AspectJ's compatibility test suite?
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectClinit.generatePostSyntheticCode(ClassScope, CodeStream),True
weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.isInitFailureHandler(InstructionHandle),True
#####
AspectJ
54625
1a4c02c986332c37aa1d1e86867b2434892eb11f
Incremental support does not work with outjar Either fix the class file deleting etc. to work with jars, or always do a batch build when working with outjars.
Incremental support does not work with outjar Either fix the class file deleting etc. to work with jars, or always do a batch build when working with outjars.
******
asm/src/org/aspectj/asm/IProgramElement,False,formatting
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.prepareForNextBuild(AjBuildConfig),True
#####
AspectJ
45489
669cd7ce8634623c004cca5732c94a20fd7f57f7
Structure model is wrong when re-opened Some elements have the wrong kinds when a saved structure model is loaded. E.g. if I close then re-open the eclipse workbench classes are shown as interface in the outline view. Also if I traverse the tree with the code below I get the wrong kinds assigned to classed, interfaces, aspects and import declarations. List list = StructureModelUtil.getPackagesInModel(); for(Iterator i = list.iterator(); i.hasNext();){ Object[] o = (Object[])i.next(); IProgramElement node = (IProgramElement)o[0]; List files = StructureModelUtil.getFilesInPackage(node); for(Iterator i2 = files.iterator(); i2.hasNext();){ IProgramElement file = (IProgramElement)i2.next (); System.out.println("file " + file.getKind ().toString() + ", " + file.getName()); boolean added2 = false; List file_children = file.getChildren(); // file children can be classes, aspects or other things for(Iterator i3 = file_children.iterator(); i3.hasNext();){ IProgramElement file_child = (IProgramElement)i3.next(); System.out.println("kind: " + file_child.getKind().toString() +", " + file_child.getName());
Structure model is wrong when re-opened Some elements have the wrong kinds when a saved structure model is loaded. E.g. if I close then re-open the eclipse workbench classes are shown as interface in the outline view. Also if I traverse the tree with the code below I get the wrong kinds assigned to classed, interfaces, aspects and import declarations. // file children can be classes, aspects or other things 
******
ajde/testsrc/org/aspectj/ajde/AjdeTests.suite(),True
ajde/testsrc/org/aspectj/ajde/SavedModelConsistencyTest.SavedModelConsistencyTest(String),False,new_method|test_method
ajde/testsrc/org/aspectj/ajde/SavedModelConsistencyTest.main(String[]),False,new_method|test_method
ajde/testsrc/org/aspectj/ajde/SavedModelConsistencyTest.testInterfaceIsSameInBoth(),False,new_method|test_method
ajde/testsrc/org/aspectj/ajde/SavedModelConsistencyTest.testModelIsSamePreAndPostBuild(),False,new_method|test_method
ajde/testsrc/org/aspectj/ajde/SavedModelConsistencyTest.setUp(),False,new_method|test_method
ajde/testsrc/org/aspectj/ajde/SavedModelConsistencyTest.tearDown(),False,new_method|test_method
#####
AspectJ
50200
6f099df282f6d4994e09e457132677de7194c471
aspectjrt.jar manifest file name needs changing to upper case The name of the aspectjrt.jar's manifest file should be changed from META-INF/manifest.mf to META-INF/MANIFEST.MF According to the Jar file specification (see http://java.sun.com/products/jdk/1. 2/docs/guide/jar/manifest.html) the name of the manifest file needs to be all upper case. It's beyond trivial, I know, but it does cause an unnecessary warning in at least one popular IDE for J2EE development (IBM WebSphere Studio) when the aspectjrt.jar is packaged in an EAR file. If there was an option to assign this a "very, very trivial" severity level I would.
manifest file name needs changing to upper case The name of the aspectjrt.jar's manifest file should be changed from to According to the Jar file specification (see http://java.sun.com/products/jdk/1. 2/docs/guide/jar/manifest.html) the name of the manifest file needs to be all upper case. It's beyond trivial, I know, but it does cause an unnecessary warning in at least one popular IDE for J2EE development (IBM WebSphere Studio) when the is packaged in an EAR file. If there was an option to assign this a "very, very trivial" severity level I would.
******
build/src/org/aspectj/internal/tools/ant/taskdefs/AntBuilder.assemble(Module, File, List),True
#####
AspectJ
50776
c79892369fa4225ee5eb71b42c96e289f2eb4fc9
fail in compiling aspect with overriding method introduction with different throws clause A first class (class A) declares only one method with some exceptions in the throws clause ( void m() throws Exception ). A second class (class B) extends it without redefinig the method. An aspect declares a method introduction in the class B, with the same name, signature and return type of the one in class A, but without throws clause; this is a legal override. In the second class (class B) each invocation to the overriden method doesn't need a try-catch block, because it refers to his hown method that raises no exception. This code compiles using ajc version 1.0.6 (built Jul 24, 2002 6:21 PM PST) running on java 1.4.0 But not using AspectJ Compiler 1.1.1 AspectJ Compiler 1.1.0 class A{ public A(){} public void m() throws Exception{} } class B extends A{ public B(){} public void some_code(){ m();} } aspect C{ public void B.m(){} }
fail in compiling aspect with overriding method introduction with different throws clause A first class (class A) declares only one method with some exceptions in the throws clause . A second class (class B) extends it without redefinig the method. An aspect declares a method introduction in the class B, with the same name, signature and return type of the one in class A, but without throws clause; this is a legal override. In the second class (class B) each invocation to the overriden method doesn't need a try-catch block, because it refers to his hown method that raises no exception. This code compiles using ajc version 1.0.6 (built Jul 24, 2002 6:21 PM PST) running on java 1.4.0 But not using AspectJ Compiler 1.1.1 AspectJ Compiler 1.1.0
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMemberFinder.getExactMethod(SourceTypeBinding, char[], TypeBinding[]),True
tests/bugs/IntertypeDifferentThrows.A(),False,new_method|test_method
tests/bugs/IntertypeDifferentThrows.m(),False,new_method|test_method
tests/bugs/IntertypeDifferentThrows.B(),False,new_method|test_method
tests/bugs/IntertypeDifferentThrows.some_code(),False,new_method|test_method
tests/bugs/IntertypeDifferentThrows.B.m(),False,new_method|test_method
#####
AspectJ
53012
0a017593dcbeab409c1634da87b3f500b848e903
declare precedence on a class should be a compile-time error The compiler silently accepts ---- public class DeclarePrecedence { public static void main(String[] args) { System.out.println("hello"); } } aspect DP { declare precedence: DeclarePrecedence, DP; before() : staticinitialization(DeclarePrecedence) { System.out.println("ok"); } } ---- Since this is likely to be a mistake, an error would be nice. However, that would mean saying (!TargetClass &amp;&amp; TargetClass+) to pick out the aspect subtypes of TargetClass.
declare precedence on a class should be a compile-time error The compiler silently accepts ---- ---- Since this is likely to be a mistake, an error would be nice. However, that would mean saying (! &amp;&amp; +) to pick out the aspect subtypes of .
******
tests/bugs/declarePrecedenceWithClasses/DeclarePrecedenceTestClass.main(String[]),False,new_method|test_method
weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.resolve(IScope),True
#####
AspectJ
36234
b3b1eecf938fdc9d0bd8f954bc05ec38763299fb
out of memory error when compiling Getting an out of memory error when compiling with Ajc 1.1 RC1. I know this is not very descriptive, but maybe you can point me into a direction of getting more output. here some additional information though: Code base is medium size (about 1500 classfiles) I removed all my aspects and still receive the error. Running it from the command line: ajc -classpath whateveritis -sourceroots whateveritis -d whateveritis
out of memory error when compiling Getting an out of memory error when compiling with Ajc 1.1 RC1. I know this is not very descriptive, but maybe you can point me into a direction of getting more output. here some additional information though: Code base is medium size (about 1500 classfiles) I removed all my aspects and still receive the error. Running it from the command line: ajc -classpath whateveritis -sourceroots whateveritis -d whateveritis
******
org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.runMain(String[], boolean),True
#####
AspectJ
47952
ad2fb7a583f7451f3101f8101b090999d6a43341
SoftException.printStackTrace(..) should print wrapped throwable too SoftExceptions should print not only their trace but also that of the wrapped throwable. We should be able to set a flag on class initialization whether we are running under 1.4 and then implement it under 1.4 using initCause() and otherwise by direct delegation. I can do this fix if we're agreed.
SoftException.printStackTrace(..) should print wrapped throwable too SoftExceptions should print not only their trace but also that of the wrapped throwable. We should be able to set a flag on class initialization whether we are running under 1.4 and then implement it under 1.4 using initCause() and otherwise by direct delegation. I can do this fix if we're agreed.
******
runtime/src/org/aspectj/lang/SoftException.printStackTrace(),False,new_method
runtime/src/org/aspectj/lang/SoftException.printStackTrace(PrintStream stream),False,new_method
runtime/src/org/aspectj/lang/SoftException.printStackTrace(PrintWriter),False,new_method
runtime/testsrc/RuntimeModuleTests.testNothing(),False,test_method
runtime/testsrc/RuntimeModuleTests.testSoftExceptionPrintStackTrace(),False,test_method|new_method
runtime/testsrc/RuntimeModuleTests.checkSoftExceptionString(String),False,test_method|new_method
#####
AspectJ
40192
183fc23883289ae42854ce9afcf2d3b0d29b7599
build cancel during weaving The build can not be cancelled during the bytecode weaving stage.
build cancel during weaving The build can not be cancelled during the bytecode weaving stage.
******
ajde/src/org/aspectj/ajde/internal/BuildNotifierAdapter.setCancelledRequested(boolean),False,new_method
ajde/src/org/aspectj/ajde/internal/BuildNotifierAdapter.isCancelledRequested(),False,new_method
ajde/testdata/BuildCancelling/Cl1.main(String[]),False,test_method|new_method
ajde/testdata/BuildCancelling/Cl2.main(String[]),False,test_method|new_method
ajde/testdata/BuildCancelling/Cl3.main(String[]),False,test_method|new_method
ajde/testdata/BuildCancelling/HW.main(String[]),False,test_method|new_method
ajde/testdata/BuildCancelling/HW.callPrint(String),False,test_method|new_method
ajde/testsrc/org/aspectj/ajde/AjdeTests.suite(),True
ajde/testsrc/org/aspectj/ajde/BuildCancellingTest.BuildCancellingTest(String),False,test_method|new_method
ajde/testsrc/org/aspectj/ajde/BuildCancellingTest.setUp(),False,test_method|new_method
ajde/testsrc/org/aspectj/ajde/BuildCancellingTest.testCancelFirstCompile(),False,test_method|new_method
ajde/testsrc/org/aspectj/ajde/BuildCancellingTest.testCancelThirdCompile(),False,test_method|new_method
ajde/testsrc/org/aspectj/ajde/BuildCancellingTest.testCancelFirstAspectWeave(),False,test_method|new_method
ajde/testsrc/org/aspectj/ajde/BuildCancellingTest.testCancelThirdAspectWeave(),False,test_method|new_method
ajde/testsrc/org/aspectj/ajde/BuildCancellingTest.testCancelFirstClassWeave(),False,test_method|new_method
ajde/testsrc/org/aspectj/ajde/BuildCancellingTest.testCancelSecondClassWeave(),False,test_method|new_method
ajde/testsrc/org/aspectj/ajde/BuildCancellingTest.start(String),False,test_method|new_method
ajde/testsrc/org/aspectj/ajde/BuildCancellingTest.cancelOn(String,int),False,test_method|new_method
ajde/testsrc/org/aspectj/ajde/BuildCancellingTest.setProgressText(String),False,test_method|new_method
ajde/testsrc/org/aspectj/ajde/BuildCancellingTest.containsMessage(String,String),False,test_method|new_method
ajde/testsrc/org/aspectj/ajde/BuildCancellingTest.dumpMessages(),False,test_method|new_method
ajde/testsrc/org/aspectj/ajde/BuildCancellingTest.setProgressBarVal(int),False,test_method|new_method
ajde/testsrc/org/aspectj/ajde/BuildCancellingTest.incrementProgressBarVal(),False,test_method|new_method
ajde/testsrc/org/aspectj/ajde/BuildCancellingTest.setProgressBarMax(int),False,test_method|new_method
ajde/testsrc/org/aspectj/ajde/BuildCancellingTest.getProgressBarMax(),False,test_method|new_method
ajde/testsrc/org/aspectj/ajde/BuildCancellingTest.finish(),False,test_method|new_method
ajde/testsrc/org/aspectj/ajde/BuildCancellingTest.diskContents(String),False,test_method|new_method
ajde/testsrc/org/aspectj/ajde/BuildCancellingTest.wovenClassesFound(),False,test_method|new_method
ajde/testsrc/org/aspectj/ajde/BuildCancellingTest.checkFor(String),False,test_method|new_method
ajde/testsrc/org/aspectj/ajde/BuildCancellingTest.dumpTaskData(),False,test_method|new_method
bridge/src/org/aspectj/bridge/IProgressListener.setCancelledRequested(boolean),False,new_method
bridge/src/org/aspectj/bridge/IProgressListener.isCancelledRequested(),False,new_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.AjCompilerAdapter(Compiler, boolean, BcelWorld, BcelWeaver, EclipseFactory, IIntermediateResultsRequestor, IProgressListener, IOutputClassFileNameProvider, Map, Collection, boolean),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.afterProcessing(CompilationUnitDeclaration, int),False,formatting
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.weave(),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverAdapter.WeaverAdapter(AjCompilerAdapter, WeaverMessageHandler),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverAdapter.getClassFileIterator(),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverAdapter.processingReweavableState(),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverAdapter.addingTypeMungers(),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverAdapter.weavingAspects(),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverAdapter.weavingClasses(),True
acceptResult(UnwovenClassFile),True
recordProgress(String),False,new_method
recordProgress(double,String),False,new_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.doBuild(AjBuildConfig, IMessageHandler, boolean),True
performCompilation(List),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.getAdapter(org.eclipse.jdt.internal.compiler.Compiler),True
#####
AspectJ
31460
33d8ee9eededcd1219a6cbd1d063af005d40a3f7
Weaving class loader Hi! As discussed on the mailing list a few days ago I implemented a weaving class loader to enable bytecode based weaving at class loading time. The class loader is based on the URLClassLoader and can be used like any other URLClassLoader. In addition to that you can add aspects to the weaving loader. These aspects got woven into each class that is loaded. The test cases for the class loader aren't implemented yet, I am still thinking about how to implement them. I will contribute them later, okay? -Martin
Weaving class loader Hi! As discussed on the mailing list a few days ago I implemented a weaving class loader to enable bytecode based weaving at class loading time. The class loader is based on the and can be used like any other . In addition to that you can add aspects to the weaving loader. These aspects got woven into each class that is loaded. The test cases for the class loader aren't implemented yet, I am still thinking about how to implement them. I will contribute them later, okay? -Martin
******
org.aspectj.ajdt.core/testdata/src1/LTWHelloWorld.println(),False,new_method|text_method
main(String[]),False,new_method|text_method
org.aspectj.ajdt.core/testdata/src1/ltw/LTWPackageTest.main(String[]),False,new_method|text_method
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.main(String[]),True
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.makeURLWeavingClassLoaderJars(),False,new_method
util/src/org/aspectj/util/FileUtil.makeClasspath(URL[]),False,new_method
weaver/src/org/aspectj/weaver/ExtensibleURLClassLoader.ExtensibleURLClassLoader(URL[], ClassLoader),True
weaver/src/org/aspectj/weaver/ExtensibleURLClassLoader.addURL(URL),False,new_method
weaver/src/org/aspectj/weaver/ExtensibleURLClassLoader.findClass(String),False,new_method
weaver/src/org/aspectj/weaver/ExtensibleURLClassLoader.defineClass(String, byte[], CodeSource),False,new_method
weaver/src/org/aspectj/weaver/ExtensibleURLClassLoader.defineClass(String, byte[]),False,new_method
weaver/src/org/aspectj/weaver/ExtensibleURLClassLoader.getPackageName(String),False,new_method
weaver/src/org/aspectj/weaver/WeavingURLClassLoader.WeavingURLClassLoader(ClassLoader),False,new_method
weaver/src/org/aspectj/weaver/WeavingURLClassLoader.WeavingURLClassLoader(URL[], URL[], ClassLoader),False,new_method
weaver/src/org/aspectj/weaver/WeavingURLClassLoader.getAspectPath(),False,new_method
weaver/src/org/aspectj/weaver/WeavingURLClassLoader.getClassPath(),False,new_method
weaver/src/org/aspectj/weaver/WeavingURLClassLoader.getURLs(String),False,new_method
weaver/src/org/aspectj/weaver/WeavingURLClassLoader.addURL(URL),False,new_method
weaver/src/org/aspectj/weaver/WeavingURLClassLoader.defineClass(String, byte[], CodeSource),False,new_method
weaver/src/org/aspectj/weaver/WeavingURLClassLoader.getBytes(String),False,new_method
weaver/src/org/aspectj/weaver/WeavingURLClassLoader.getAspectURLs(),False,new_method
weaver/src/org/aspectj/weaver/WeavingURLClassLoader.acceptClass(String, byte[]),False,new_method
weaver/src/org/aspectj/weaver/tools/GeneratedClassHandler.acceptClass(String, byte[]),False,new_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.WeavingAdaptor(WeavingClassLoader),False,new_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.WeavingAdaptor(GeneratedClassHandler, URL[], URL[]),False,new_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.getFullClassPath(ClassLoader),False,new_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.getFullAspectPath(ClassLoader),False,new_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.getVerbose(),False,new_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.init(List, List),False,new_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.addURL(URL),False,new_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.weaveClass(String, byte[]),False,new_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.shouldWeave(String),False,new_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.shouldWeaveName(String),False,new_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.shouldWeaveAspect(String),False,new_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.getWovenBytes(String, byte[]),False,new_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.registerAspectLibraries(List),False,new_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.addAspectLibrary(File),False,new_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.makeClasspath(String),False,new_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.handleMessage(IMessage),False,new_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.WeavingClassFileProvider(String, byte[]),False,new_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.getBytes(),False,new_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.getClassFileIterator(),False,new_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.getRequestor(),False,new_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.processingReweavableState(),False,new_method
weaver/src/org/aspectj/weaver/tools/weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.WeavingAdaptor.addingTypeMungers(),False,new_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.weavingAspects(),False,new_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.weavingClasses(),False,new_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.weaveCompleted(),False,new_method
weaver/src/org/aspectj/weaver/tools/WeavingClassLoader.getAspectURLs(),False,new_method
weaver/testsrc/org/aspectj/weaver/BcweaverTests.suite(),True
weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.WeavingURLClassLoaderTest(String),False,test_class
weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.testLoadClass(),False,new_method|test_method
weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.testLoadWovenClass(),False,new_method|test_method
weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.testWeaveWovenClass(),False,new_method|test_method
weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.testWeavingURLClassLoader(),False,new_method|test_method
weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.testWeaveAdvice(),False,new_method|test_method
weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.testWeaveAroundClosure(),False,new_method|test_method
weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.testWeavingITD(),False,new_method|test_method
weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.testWeavingPer(),False,new_method|test_method
weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.testWeavingAspects(),False,new_method|test_method
weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.testJunkJar(),False,new_method|test_method
weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.testAddURL(),False,new_method|test_method
weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.testParentChild(),False,new_method|test_method
weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.testIncompletePath(),False,new_method|test_method
weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.testPackage(),False,new_method|test_method
weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.invokeMain(Class, String[],False,new_method|test_method
#####
AspectJ
55341
0521e79aea0550b1357a7ccc6a5050f8ce27ce9b
error Type mismatch: cannot convert from java.lang.String to java.lang.String When compiling a binary concrete aspect library (for later LTW) consisting of more than one aspect that performs an ITD on a target class not exposed to the weaver I get the following error: error Type mismatch: cannot convert from java.lang.String to java.lang.String The error does not oocur if a complete build &amp; weave is performed. Testcase attached.
error Type mismatch: cannot convert from to When compiling a binary concrete aspect library (for later LTW) consisting of more than one aspect that performs an ITD on a target class not exposed to the weaver I get the following error: error Type mismatch: cannot convert from to The error does not oocur if a complete build &amp; weave is performed. Testcase attached.
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMemberFinder.getField(SourceTypeBinding, char[], InvocationSite, Scope),False,comment
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.makeTestJars(),False,test_method
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.makeURLWeavingClassLoaderJars(),False,test_method
tests/bugs/StringToString/HW.check(String),False,test_method|new_method
tests/bugs/StringToString/HW.println(),False,test_method|new_method
tests/bugs/StringToString/HW.main(String[]),False,test_method|new_method
tests/bugs/StringToString/X.HW.getMessage(),False,test_method|new_method
weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.testWeavingITD(),False,test_method
weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.testWeavingAspects(),False,test_method
#####
AspectJ
57430
e7ac54fae25b797a0d3609350a27330bea302fb9
exception printing Exceptions thrown from the compiler used to be printed once, with the submit-bug header. Now they are printed twice, without and with the header. True of CVS version.
exception printing Exceptions thrown from the compiler used to be printed once, with the submit-bug header. Now they are printed twice, without and with the header. True of CVS version.
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.afterCompiling(),True
#####
AspectJ
57436
b0d32cafba6241023d1efdc343a2744a5e25a00d
Java 1.5 fails to run classes produced by ajc Java 1.5 beta reports a ClassFormatError when running programs (e.g., spacewar) compiled by ajc 1.1.1 and the latest CVS head. Sun's Java 1.5 beta binary-compatibility docs say that some obfuscators violated the .class format specification, so those .class files will fail when run under 1.5. (The docs also say they are still incomplete.) Although 1.5 is still beta, we would want to submit a bug to Sun if our implementation techniques are valid, so we don't have to change those techniques. For 1.2, we should at document if we don't fix, since many people are using 1.5.
Java 1.5 fails to run classes produced by ajc Java 1.5 beta reports a  when running programs (e.g., spacewar) compiled by ajc 1.1.1 and the latest CVS head. Sun's Java 1.5 beta binary-compatibility docs say that some obfuscators violated the .class format specification, so those .class files will fail when run under 1.5. (The docs also say they are still incomplete.) Although 1.5 is still beta, we would want to submit a bug to Sun if our implementation techniques are valid, so we don't have to change those techniques. For 1.2, we should at document if we don't fix, since many people are using 1.5.
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.generateMethod(ClassFile, MethodBinding, BodyGenerator),True
#####
AspectJ
59909
5f6b18be7a143c961ae1de5ffbf1aef3d249a55e
CFlowStack removesThreads to late Problem: The current implementation of CFlowStack (Version 1.1-till 1.2 rc1) stores all threads in a hashtable. These Threads are removes after several calls to the methods getThreadStack(). (In our cases &gt;70 calls.) In our project, this cycle is much to long. We have soveral long running threads, which grap quite a lot of lot of memory. This memory can only be freed after the threads have been removed from the CFlowStack. In our production code we sum up to more than 300 Threads stored in different CFlowStack Varaibles. Often this results in out of memory Errors. Added patch provides an improved freeing scheme. It checks if the size of the table has grown, if it has, it checks if it can remove some threads.
to late Problem: The current implementation of  (Version 1.1-till 1.2 rc1) stores all threads in a . These Threads are removes after several calls to the methods . (In our cases &gt;70 calls.) In our project, this cycle is much to long. We have soveral long running threads, which grap quite a lot of lot of memory. This memory can only be freed after the threads have been removed from the . In our production code we sum up to more than 300 Threads stored in different  Varaibles. Often this results in out of memory Errors. Added patch provides an improved freeing scheme. It checks if the size of the table has grown, if it has, it checks if it can remove some threads.
******
runtime/src/org/aspectj/runtime/internal/CFlowStack.getThreadStack(),True
runtime/src/org/aspectj/runtime/internal/CFlowStack.CFlowStack(),False,new_method
runtime/src/org/aspectj/runtime/internal/CFlowStack.CFlowStack(),False,new_method
runtime/src/org/aspectj/runtime/internal/CFlowStack.getThreadLocalStackFactory(),False,new_method
runtime/src/org/aspectj/runtime/internal/CFlowStack.getThreadLocalStackFactoryFor11(),False,new_method
runtime/src/org/aspectj/runtime/internal/CFlowStack.selectFactoryForVMVersion(),False,new_method
runtime/src/org/aspectj/runtime/internal/CFlowStack.getThreadStackFactoryClassName(),False,new_method
runtime/src/org/aspectj/runtime/internal/cflowstack/ThreadStack.getThreadStack(),False,new_method
runtime/src/org/aspectj/runtime/internal/cflowstack/ThreadStackFactory.getNewThreadStack(),False,new_method
runtime/src/org/aspectj/runtime/internal/cflowstack/ThreadStackFactoryImpl.initialValue(),False,new_method
runtime/src/org/aspectj/runtime/internal/cflowstack/ThreadStackFactoryImpl.getThreadStack(),False,new_method
runtime/src/org/aspectj/runtime/internal/cflowstack/ThreadStackFactoryImpl.getNewThreadStack(),False,new_method
runtime/src/org/aspectj/runtime/internal/cflowstack/ThreadStackFactoryImpl11.getNewThreadStack(),False,new_method
runtime/src/org/aspectj/runtime/internal/cflowstack/ThreadStackImpl11.getThreadStack(),False,new_method
#####
AspectJ
59596
a97f3b6758f778e9a19843ef984085b34be8e7d0
Null pointer exception while weaving java.awt.Label I tried to add an Aspect to java.awt.Label. I compile the aspect via: ajc -inpath /usr/local/j2sdk_nb/j2sdk1.4.2/jre/lib/rt.jar Timestamp.java Here is the aspect Timestamp.java: aspect Timestamp { private int java.awt.Label._ts_read = 0; private int java.awt.Label._ts_write = 0; pointcut writeOp(): call (void java.awt.Label.setText (String)); pointcut readOp(): call (String java.awt.Label.getText()); after (java.awt.Label b) returning: readOp() &amp;&amp; target (b) { b._ts_read++; } after (java.awt.Label b) returning: writeOp() &amp;&amp; target (b) { b._ts_write++; System.out.println (b._ts_write); } public static void main (String[] args) { java.awt.Label b1 = new java.awt.Label(); b1.setText ("abc"); } } Here is the error message I get from ajc: null java.lang.NullPointerException at org.aspectj.ajdt.internal.core.builder.EclipseAdapterUtils.makeLocationContext(EclipseAdapterUtils.java:50) at org.aspectj.ajdt.internal.core.builder.EclipseAdapterUtils.makeSourceLocation(EclipseAdapterUtils.java:120) at org.aspectj.ajdt.internal.core.builder.EclipseAdapterUtils.makeMessage(EclipseAdapterUtils.java:129) at org.aspectj.ajdt.internal.core.builder.AjBuildManager$4.acceptResult(AjBuildManager.java:663) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.acceptResult(AjCompilerAdapter.java:178) at org.aspectj.ajdt.internal.compiler.WeaverAdapter.finishedWith(WeaverAdapter.java:203) at org.aspectj.ajdt.internal.compiler.WeaverAdapter.weaveCompleted(WeaverAdapter.java:167) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:570) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:239) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:114) at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:376) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:600) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:160) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:94) at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:102) at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53) at org.aspectj.tools.ajc.Main.run(Main.java:280) at org.aspectj.tools.ajc.Main.runMain(Main.java:217) at org.aspectj.tools.ajc.Main.main(Main.java:79) 1 fail|abort
Null pointer exception while weaving I tried to add an Aspect to  I compile the aspect via: ajc -inpath Here is the aspect Here is the error message I get from ajc: null 1 fail|abort
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.makeLocationContext(ICompilationUnit, IProblem),True
#####
AspectJ
59895
a4fef441489604938a313b2beac300df315c1709
NPE updating an aspect in incremental mode NPE when updating an aspect in incremental mode. Find test case in incremental/full-rebuild. AjBuildManager.java:208 finally clause runs after every iteration: ret = !handler.hasErrors(); handler = null; But at AjBuildManager.java:124, handler is only set if there is not a complete rebuild: if (!canIncremental &amp;&amp; !batch) { // retry as batch? return doBuild(buildConfig, baseHandler, true); } this.handler = ... Since result is set by return doBuild..), could say if (null != handler) { ret = !handler.hasErrors(); } (Seems to have been introduced in a month ago in 1.44. Our test coverage of incremental mode is awful.)
NPE updating an aspect in incremental mode NPE when updating an aspect in incremental mode. Find test case in finally clause runs after every iteration:, handler is only set if there is not a complete rebuild:  Since result is set by , could say (Seems to have been introduced in a month ago in 1.44. Our test coverage of incremental mode is awful.)
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.doBuild(AjBuildConfig, IMessageHandler, boolean),True
#####
AspectJ
62227
9ebfc84930fde3f56a0166a5abb671029d457ea4
Load Time Weaving aborts on any kind of warning (declare/xlint) The message handler in the weaving adapter for load time weaving says: public boolean handleMessage(IMessage message) throws AbortException { if (!isIgnoring(message.getKind())) { if (verbose) System.err.println(message.getMessage()); throw new AbortException(message); } return true; } This means for warnings it goes bang. So, even a declare warning that is meant to tell the user something informational during a LTW will cause the code to blow up. The fix is straightforward and simply to log warning messages and only fail for error messages. I am waiting for a testcase from Matthew before checking in the fix.
Load Time Weaving aborts on any kind of warning (declare/xlint) The message handler in the weaving adapter for load time weaving says: This means for warnings it goes bang. So, even a declare warning that is meant to tell the user something informational during a LTW will cause the code to blow up. The fix is straightforward and simply to log warning messages and only fail for error messages. I am waiting for a testcase from Matthew before checking in the fix.
******
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.makeURLWeavingClassLoaderJars(),False,test_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.handleMessage(IMessage),True
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.isIgnoring(Kind),True
weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.testWeaveDeclareWarningAdvice(),False,new_method|test_method
weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.testWeaveDeclareErrorAdvice(),False,new_method|test_method
eaver/src/org/aspectj/weaver/WeavingURLClassLoader,True
#####
AspectJ
72671
d1551bda9b14c6c2035e0c8df6f09bf4634041de
Bootclasspath specification for compiling is not possible I have following bug running eclipse 3.0 and ajdt 1.1.12 I have following class: import java.io.FileNotFoundException; import java.io.FileOutputStream; import org.w3c.dom.DOMConfiguration; import org.w3c.dom.DOMError; import org.w3c.dom.DOMErrorHandler; import org.w3c.dom.Document; import org.w3c.dom.DocumentFragment; import org.w3c.dom.NodeList; import org.w3c.dom.ls.DOMImplementationLS; import org.w3c.dom.ls.LSInput; import org.w3c.dom.ls.LSOutput; import org.w3c.dom.ls.LSParser; import com.dcbank.common.DOMImplementationLSSingleton; public class DOMHelper { public static final String CLASS_ID = "%full_filespec: DOMHelper.java~1:java:1 %"; public static void save(Document document, String filename) throws ClassNotFoundException, InstantiationException, IllegalAccessException, FileNotFoundException { document.normalizeDocument(); } } which compiles very fine with JDK 1.4.2_02 on Windows XP, as soon as the dom2-xml-apis.jar and dom3-xercesImpl.jar are added at the beginning of the jre container, or are included in the jar-library list before the system jar. As soon as I convert this project to an AspectJ project, the code does not compile anymore. The aspectJ compiler does not find the normalizeDocument, which is included in the one of the two additional jars. method any more. kind regards Arno Schmidmeier
specification for compiling is not possible I have following bug running eclipse 3.0 and ajdt 1.1.12 I have following class: which compiles very fine with JDK 1.4.2_02 on Windows XP, as soon as the are added at the beginning of the jre container, or are included in the jar-library list before the system jar. As soon as I convert this project to an AspectJ project, the code does not compile anymore. The aspectJ compiler does not find the , which is included in the one of the two additional jars. method any more. kind regards Arno Schmidmeier
******
ajde/src/org/aspectj/ajde/internal/CompilerAdapter.configureProjectOptions(AjBuildConfig, ProjectPropertiesAdapter),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.populateBuildConfig(AjBuildConfig, String[], boolean, File),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.getBootclasspath(AjcConfigParser),False,new_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.getClasspath(AjcConfigParser),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.getClasspath(),False,comments
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.getBootclasspath(),False,new_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.setBootclasspath(List),False,new_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.getFullClasspath(),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.initBcelWorld(IMessageHandler),True
makeClasspathString(),True
checkRtJar(AjBuildConfig),True
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.testPathResolutionFromConfigArgs(),True
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.testBootclasspath(),True
#####
AspectJ
76096
6beb43faeecff249a33e7d7e2489c6a92a4700fd
Anonymous classes unaware of introductions into abstract classes (error can't find type $Local$) The example below generates a compiler error, on both Linux and Windows. The error occurs for ajdt (eclipse) as well. The compiler error: $ ajc -version &gt; AspectJ Compiler 1.2 built on Friday May 21, 2004 at &gt; 15:06:22 GMT &gt; $ ajc ConcreteClassA.java &gt; error can't find type $Local$ &gt; &gt; /home/marin/tests/ConcreteClassA.java:18 error Class &gt; must implement the inherited abstract method &gt; InterfaceA.a2() &gt; InterfaceA a = new AbstractClassA() { &gt; ^^^^^^^^^^^^^ &gt; &gt; 2 errors &gt; -------- &gt; The example (in ConcreteClassA.java): interface InterfaceA { public void a1(); public void a2(); } abstract class AbstractClassA implements InterfaceA { public void a1() { System.out.println("AbstractClassA.a()"); } } public class ConcreteClassA extends AbstractClassA { public void someMethod() { InterfaceA a = new AbstractClassA() { }; } } aspect IntroAspectA { public void AbstractClassA.a2() { System.out.println("AbstractClassA.a2() from IntroAspectA"); } } ------------ If you comment out the body of someMethod() (the anonymous class), the code compiles without errors.
Anonymous classes unaware of introductions into abstract classes (error can't find type $Local$) The example below generates a compiler error, on both Linux and Windows. The error occurs for ajdt (eclipse) as well. The compiler error: $ ajc -version &gt; AspectJ Compiler 1.2 built on Friday May 21, 2004 at &gt; 15:06:22 GMT &gt; ------------ If you comment out the body of (the anonymous class), the code compiles without errors.
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.abstractMethodMustBeImplemented(SourceTypeBinding, MethodBinding),True
tests/bugs/pr76096/ConcreteClassA.someMethod(),False,new_method|test_method
tests/bugs/pr76096/ConcreteClassA.a1(),False,new_method|test_method
tests/bugs/pr76096/ConcreteClassA.a2(),False,new_method|test_method
tests/bugs/pr76096/ConcreteClassA.main(String[]),False,new_method|test_method
tests/bugs/pr76096/ConcreteClassA.m1(),False,new_method|test_method
tests/bugs/pr76096/ConcreteClassA.m2(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.test064(),False,new_method|test_method
#####
AspectJ
73433
8e4d8980e45ba054e7d8e3e5e7ac3aca940d0758
AspectJ does not correctly support -cp Discovered by Andy Brodie. -cp is a shorthand for -classpath supported by the JDT compiler. AspectJ does not correctly support -cp option. Look at this example: C:\aspectj1.2&gt;ajc -inpath injar.jar -outjar outjar.jar -cp lib\aspectjrt.jar [error] can't find type org.aspectj.lang.JoinPoint 1 error C:\aspectj1.2&gt;ajc -inpath injar.jar -outjar outjar.jar -classpath lib\aspectjrt.jar This is due to the arg parser in AspectJ only recognizing -classpath. It doesn't fail when it encounters -cp, it just ignores it and passes it down to JDT for processing. The fix is to recognize -cp too.
AspectJ does not correctly support -cp Discovered by Andy Brodie. -cp is a shorthand for -classpath supported by the JDT compiler. AspectJ does not correctly support -cp option. Look at this example: C\[error] can't find type org.aspectj.lang.JoinPoint 1 error -classpath This is due to the arg parser in AspectJ only recognizing -classpath. It doesn't fail when it encounters -cp, it just ignores it and passes it down to JDT for processing. The fix is to recognize -cp too.
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.parseOption(String, LinkedList),True
#####
AspectJ
42573
648c0f4d15d9ab6bac9deef010a1b66824cd8da1
".lst file entries not resolved relative to list file: {boot}classpath, extdirs," My -classpath entry in a config/.lst file was resolved relative to the working directory rather than to the config/.lst file. BuildArgParser.java looks like this would also be true for bootclasspath and extdirs, but not for injars, aspectpath, or sourceroots.
".lst file entries not resolved relative to list file: {boot}classpath, extdirs," My -classpath entry in a file was resolved relative to the working directory rather than to the file. looks like this would also be true for bootclasspath and extdirs, but not for injars, aspectpath, or sourceroots.
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.parseOption(String, LinkedList),True
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.testDefaultClasspathAndTargetCombo(),False,test_method
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.testPathResolutionFromConfigArgs(),False,new_method|test_method
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.testExtDirs(),False,test_method
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.testBootclasspath(),False,test_method
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.testClasspathSetting(),False,test_method
util/src/org/aspectj/util/ConfigParser.parseConfigFileHelper(File),True
util/src/org/aspectj/util/ConfigParser.makeFile(String),True
#####
AspectJ
70008
8dc08453232f9b4c1572ad0feb60979fb07336fe
problem with ajdoc -public Using the spacewar example, the following works fine: ajdoc -private -d doc spacewar coordination but the following breaks: ajdoc -public -d doc spacewar coordination The end of the failing output is below. Display.html and Display.DisplayAspect.html were not generated as the types are not public, so presumably the decorator shouldn't be looking for them in this case. &gt; Decorating html files... &gt; Decorating C:\aspectj1.2\doc\examples\doc\spacewar\Debug.html... &gt; Decorating C:\aspectj1.2\doc\examples\doc\spacewar\Display.DisplayAspect.html. .. An internal error occured in ajdoc Please copy the following text into an email message and send it, along with any additional information you can add to: aspectj-dev@eclipse.org java.io.FileNotFoundException: C:\aspectj1.2\doc\examples\doc\spacewar\Display.D isplayAspect.html (The system cannot find the file specified) java.io.FileNotFoundException: C:\aspectj1.2\doc\examples\doc\spacewar\Display.D isplayAspect.html (The system cannot find the file specified) at java.io.FileInputStream.open(Native Method) at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:106) at java.io.FileReader.&lt;init&gt;(FileReader.java:55) at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFile(HtmlDecorator. java:142) at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromDecl(HtmlDecora tor.java:115) at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromDecls(HtmlDecor ator.java:54) at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromInputFiles(Html Decorator.java:43) at org.aspectj.tools.ajdoc.Main.main(Main.java:210)
problem with ajdoc -public Using the spacewar example, the following works fine: ajdoc -private -d doc spacewar coordination but the following breaks: ajdoc -public -d doc spacewar coordination The end of the failing output is below. and were not generated as the types are not public, so presumably the decorator shouldn't be looking for them in this case. &gt; Decorating html files... &gt; Decorating ... &gt; Decorating . .. An internal error occured in ajdoc Please copy the following text into an email message and send it, along with any additional information you can add to:  (The system cannot find the file specified)(The system cannot find the file specified)
******
ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.decorateHTMLFile(File),True
decorateHTMLFromDecl(Declaration, String base, String, boolean),False,formatting
ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.testCoverage(),False,test_method
ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.testCoveragePublicMode(),False,test_method|new_method
ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.testPlainJava(),False,test_method
ajdoc/testsrc/org/aspectj/tools/ajdoc/SpacewarTestCase.setUp(),False,test_method|new_method
ajdoc/testsrc/org/aspectj/tools/ajdoc/SpacewarTestCase.testSimpleExample(),False,test_method
ajdoc/testsrc/org/aspectj/tools/ajdoc/SpacewarTestCase.testPublicModeExample(),False,test_method|new_method
#####
AspectJ
71811
5f80c8cd8de6ab532fbe3e267cca45b749331d98
AJDoc: should be able to set encoding like javadoc ajdoc doesn't support the -encoding -docencoding and -charset options of javadoc. Especially, it doesn't pass on the -encoding to ajc. If your project uses a source file encoding (e.g. UTF-8) differing form the platform standard, and some java identifiers use characters byond the standard ASCII range, you won't be able to use ajdoc at all.
AJDoc: should be able to set encoding like javadoc ajdoc doesn't support the -encoding -docencoding and -charset options of javadoc. Especially, it doesn't pass on the -encoding to ajc. If your project uses a source file encoding (e.g. UTF-8) differing form the platform standard, and some java identifiers use characters byond the standard ASCII range, you won't be able to use ajdoc at all.
******
ajdoc/src/org/aspectj/tools/ajdoc/Main.parseArgs(List, File),True
ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.testOptions(),False,test_method
#####
AspectJ
72699
5e0876580b0e95dd06ca4342e233f9a5dceb33a5
Bogus error message: The abstract method ajc$pointcut$$tracingScope$a2 in type Tracing can only be defined by an abstract class When attempting to compile the following aspect the resulting error message should say something like "The abstract method pointcut tracingScope in type Tracing can only be defined by an abstract aspect" public aspect Tracing { public abstract pointcut tracingScope(); }
Bogus error message: The abstract method in type Tracing can only be defined by an abstract class When attempting to compile the following aspect the resulting error message should say something like "The abstract method  in type Tracing can only be defined by an abstract aspect" 
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDeclaration.postParse(TypeDeclaration),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.abstractMethodInAbstractClass(SourceTypeBinding, AbstractMethodDeclaration),False,new_method
tests/bugs/BogusMessage.tracingScope(),False,new_method|test_method
tests/bugs/BogusMessage2.tracingScope(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.test052_bogusMessage1(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.test053_bogusMessage2(),False,new_method|test_method
#####
AspectJ
74238
6e155a6b9b78ec64f2fd4dc08152698277f1e7b7
Applet which uses cflow pointcut gets AccessControlException When I used cflow pointcut for my applet, I couldn't launch the Applet. java.lang.ExceptionInInitializerError at SandAspect.ajc$preClinit(SandAspect.aj) at SandAspect.&lt;clinit&gt;(SandAspect.aj) at SandApplet.init(SandApplet.java) at sun.applet.AppletPanel.run(AppletPanel.java:353) at java.lang.Thread.run(Thread.java:534) Caused by: java.security.AccessControlException: access denied (java.util.Proper tyPermission aspectj.runtime.cflowstack.usethreadlocal read) at java.security.AccessControlContext.checkPermission(AccessControlConte xt.java:269) at java.security.AccessController.checkPermission(AccessController.java: 401) at java.lang.SecurityManager.checkPermission(SecurityManager.java:524) at java.lang.SecurityManager.checkPropertyAccess(SecurityManager.java:12 76) at java.lang.System.getProperty(System.java:612) at org.aspectj.runtime.internal.CFlowStack.selectFactoryForVMVersion(CFl owStack.java:124) at org.aspectj.runtime.internal.CFlowStack.&lt;clinit&gt;(CFlowStack.java:59) ... 5 more It because CFlowStack uses System.getProperty method with no try..catch block. Applet doesn't have permission to read system property: "aspectj.runtime.cflowstack.usethreadlocal". workaround: modify CFlowStack.java(1.5) line 123,124 like this ----- private static String getSystemPropertyWithNoSecurityException( String aPropertyName, String aDefaultValue){ try{ return System.getProperty(aPropertyName, aDefaultValue); } catch(java.lang.SecurityException e){ return aDefaultValue; } } private static void selectFactoryForVMVersion() { String override = getSystemPropertyWithNoSecurityException( "aspectj.runtime.cflowstack.usethreadlocal" , "unspecified" ); ----- I think defining getSystemPropertyWithNoSecurityException(or more simple name :-)) method in some utility class and using it where you call System.getProperty are better way.
Applet which uses cflow pointcut gets When I used cflow pointcut for my applet, I couldn't launch the Applet. more It because uses method with no try..catch block. Applet doesn't have permission to read system property:  workaround: modify  ----- I think defining (or more simple name :-)) method in some utility class and using it where you call are better way.
******
ajde/testdata/SecurityManagerTest/src/HelloWorld.println (),False,new_method|test_method
ajde/testdata/SecurityManagerTest/src/HelloWorld.main(String[]),False,new_method|test_method
runtime/src/org/aspectj/runtime/internal/CFlowCounter.selectFactoryForVMVersion(),True
runtime/src/org/aspectj/runtime/internal/CFlowCounter.getSystemPropertyWithoutSecurityException(String, String),False,new_method
runtime/src/org/aspectj/runtime/internal/CFlowStack.selectFactoryForVMVersion(),True
runtime/src/org/aspectj/runtime/internal/CFlowStack.getSystemPropertyWithoutSecurityException(String, String),False,new_method
#####
AspectJ
59208
44a92e1a04f8f2f1a862f15f9d0b9ed761d05fd4
Weaver fails in BCEL for large classes This problem was first observed when weaving large binary legacy classes with the ajc 1.2 rc1 candidate. It turns out that BCEL fails with different error messages dependent on whether we are doing a binary weave or a straight ajc compile. In the latter case, the error message is rather confusing. To reproduce: 1. Compile and run the following code to produce Foo.java // File FooProducer.java public class FooProducer { public static final int N_METHODS = 50; public static final int N_STATEMENTS = Short.MAX_VALUE/(2 * N_METHODS); public static void main(String[] args) { System.out.println("public class Foo {"); System.out.println("static java.util.Set hs = new java.util.HashSet ();"); for (int i = 0; i &lt; N_METHODS; i++) { System.out.println("public void test" + i + "() { "); for (int j = 0; j &lt; N_STATEMENTS; j++) { System.out.println("hs.add(new Object());"); } System.out.println("}"); } System.out.println("}"); } }// End of FooProducer.java 2. Create the following Aspect: // File a.aj aspect a { boolean around() : (target(java.util.HashSet) &amp;&amp; call(boolean add(..) ) ) { return false; } } // End of a.aj *** 3.a - straight compile and weave: ajc - sourceroots . ABORT Exception thrown from AspectJ 1.2rc1 This might be logged as a bug already -- find current bugs at http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler Bugs for exceptions thrown have titles File:line from the top stack, e.g., "SomeFile.java:243" If you don't find the exception below in a bug, please add a new bug at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ To make the bug a priority, please include a test program that can reproduce this exception. Expected class `CONSTANT_Utf8' at index 25700 and got CONSTANT_NameAndType[12] (name_index = 25696, signature_index = 81) Expected class `CONSTANT_Utf8' at index 25700 and got CONSTANT_NameAndType[12] (name_index = 25696, signature_index = 81) org.apache.bcel.classfile.ClassFormatException: Expected class `CONSTANT_Utf8' at index 25700 and got CONSTANT_NameAndType[12](name_index = 25696, signature_index = 81) at org.apache.bcel.classfile.ConstantPool.getConstant (ConstantPool.java:271) at org.apache.bcel.classfile.Attribute.readAttribute(Attribute.java:163) at org.apache.bcel.classfile.FieldOrMethod.&lt;init&gt;(FieldOrMethod.java:98) at org.apache.bcel.classfile.Field.&lt;init&gt;(Field.java:83) at org.apache.bcel.classfile.ClassParser.readFields (ClassParser.java:270) at org.apache.bcel.classfile.ClassParser.parse(ClassParser.java:172) at org.aspectj.weaver.bcel.Utility.makeJavaClass(Utility.java:358) at org.aspectj.weaver.bcel.UnwovenClassFile.getJavaClass (UnwovenClassFile.java:63) at org.aspectj.weaver.bcel.UnwovenClassFile.getClassName (UnwovenClassFile.java:147) at org.aspectj.ajdt.internal.compiler.WeaverAdapter.acceptResult (WeaverAdapter.java:177) at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify (BcelWeaver.java:621) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:563) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave (AjCompilerAdapter.java:239) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling (AjCompilerAdapter.java:114) at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:376) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation (AjBuildManager.java:600) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild (AjBuildManager.java:160) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild (AjBuildManager.java:94) at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:102) at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53) at org.aspectj.tools.ajc.Main.run(Main.java:280) at org.aspectj.tools.ajc.Main.runMain(Main.java:217) at org.aspectj.tools.ajc.Main.main(Main.java:79) 1 fail|abort Signal 127 *** 3b - binary weave ajc -noweave -outjar test.jar a.aj javac -d classes Foo.java ajc -aspectpath test.jar -inpath classes ABORT Exception thrown from AspectJ 1.2rc1 This might be logged as a bug already -- find current bugs at http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler Bugs for exceptions thrown have titles File:line from the top stack, e.g., "SomeFile.java:243" If you don't find the exception below in a bug, please add a new bug at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ To make the bug a priority, please include a test program that can reproduce this exception. Class can't be both final and abstract Class can't be both final and abstract org.apache.bcel.classfile.ClassFormatException: Class can't be both final and abstract at org.apache.bcel.classfile.ClassParser.readClassInfo (ClassParser.java:242) at org.apache.bcel.classfile.ClassParser.parse(ClassParser.java:165) at org.aspectj.weaver.bcel.Utility.makeJavaClass(Utility.java:358) at org.aspectj.weaver.bcel.UnwovenClassFile.getJavaClass (UnwovenClassFile.java:63) at org.aspectj.weaver.bcel.UnwovenClassFile.getClassName (UnwovenClassFile.java:147) at org.aspectj.ajdt.internal.compiler.WeaverAdapter.acceptResult (WeaverAdapter.java:177) at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify (BcelWeaver.java:621) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:563) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave (AjCompilerAdapter.java:239) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling (AjCompilerAdapter.java:114) at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:376) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation (AjBuildManager.java:600) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild (AjBuildManager.java:160) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild (AjBuildManager.java:94) at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:102) at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53) at org.aspectj.tools.ajc.Main.run(Main.java:280) at org.aspectj.tools.ajc.Main.runMain(Main.java:217) at org.aspectj.tools.ajc.Main.main(Main.java:79) 1 fail|abort Signal 127
Weaver fails in BCEL for large classes This problem was first observed when weaving large binary legacy classes with the ajc 1.2 rc1 candidate. It turns out that BCEL fails with different error messages dependent on whether we are doing a binary weave or a straight ajc compile. In the latter case, the error message is rather confusing. To reproduce: 1. Compile and run the following code to produce  //  End of  *** 3.a - straight compile and weave: ajc - sourceroots . ABORT Exception thrown from AspectJ 1.2rc1 This might be logged as a bug already -- find current bugs at http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler Bugs for exceptions thrown have titles File:line from the top stack, e.g.,  If you don't find the exception below in a bug, please add a new bug at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ To make the bug a priority, please include a test program that can reproduce this exception. 1 fail|abort Signal 127 *** 3b - binary weave ajc -noweave -outjar test.jar a.aj javac -d classes Foo.java ajc -aspectpath test.jar -inpath classes ABORT Exception thrown from AspectJ 1.2rc1 This might be logged as a bug already -- find current bugs at http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler Bugs for exceptions thrown have titles File:line from the top stack, e.g., "SomeFile.java:243" If you don't find the exception below in a bug, please add a new bug at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ To make the bug a priority, please include a test program that can reproduce this exception. Class can't be both final and abstract Class can't be both final and abstract  1 fail|abort Signal 127
******
weaver/src/org/aspectj/weaver/WeaverMessages,True
tests/bugs/pr59208/Foo.test0(),False,test_method|new_method
tests/bugs/pr59208/FooProducer.main(String[]),False,test_method|new_method
tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.test020_branchTargetOffsetTooLargeForShort(),False,test_method|new_method
tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.test021_BcelFailureWithVeryLargeClasses(),False,test_method|new_method
tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.test022_BcelFailureWithVeryLargeClasses_Binary(),False,test_method|new_method
weaver/src/org/aspectj/weaver/bcel/LazyClassGen.writeBack(BcelWorld),True
#####
AspectJ
49743
438e61c998298b48830d5be76668df45629a1eb0
performance improvements for runtime library I am heavily using the runtime signature information from thisJoinPoint.getSignature() and the toString() method of it. This causes heavy String operations each time the toString method is called. Would it be possible to cache the resulting string for example in MethodSignatureImpl and similar classes for other signatures?
performance improvements for runtime library I am heavily using the runtime signature information from and the method of it. This causes heavy String operations each time the method is called. Would it be possible to cache the resulting string for example in and similar classes for other signatures?
******
runtime/src/org/aspectj/runtime/reflect/StringMaker,True
runtime/src/org/aspectj/runtime/reflect/AdviceSignatureImpl.toString(StringMaker),False,refactoring
runtime/src/org/aspectj/runtime/reflect/CatchClauseSignatureImpl.toString(StringMaker),False,refactoring
runtime/src/org/aspectj/runtime/reflect/ConstructorSignatureImpl.toString(StringMaker),False,refactoring
runtime/src/org/aspectj/runtime/reflect/Factory.makeSourceLoc(int, int),True
runtime/src/org/aspectj/runtime/reflect/FieldSignatureImpl.toString(StringMaker),False,refactoring
runtime/src/org/aspectj/runtime/reflect/InitializerSignatureImpl.toString(StringMaker),False,refactoring
runtime/src/org/aspectj/runtime/reflect/MethodSignatureImpl.toString(StringMaker),False,refactoring
runtime/src/org/aspectj/runtime/reflect/SignatureImpl.toString(StringMaker),True
runtime/src/org/aspectj/runtime/reflect/SignatureImpl.createToString(StringMaker),False,new_method
runtime/src/org/aspectj/runtime/reflect/SignatureImpl.setUseCache(boolean),False,new_method
runtime/src/org/aspectj/runtime/reflect/SignatureImpl.getUseCache(),False,new_method
runtime/src/org/aspectj/runtime/reflect/SourceLocationImpl.SourceLocationImpl(Class withinType, String fileName, int line, int column),True
runtime/src/org/aspectj/runtime/reflect/SourceLocationImpl.getColumn(),True
runtime/src/org/aspectj/runtime/reflect/SourceLocationImpl.toString(),True
runtime/testsrc/RuntimeModuleTests.suite(),False,new_method|test_method
runtime/testsrc/org/aspectj/runtime/reflect/RuntimePerformanceTest.RuntimePerformanceTest(String),False,new_method|test_method
runtime/testsrc/org/aspectj/runtime/reflect/RuntimePerformanceTest.setUp(),False,new_method|test_method
runtime/testsrc/org/aspectj/runtime/reflect/RuntimePerformanceTest.tearDown(),False,new_method|test_method
runtime/testsrc/org/aspectj/runtime/reflect/RuntimePerformanceTest.testToString(),False,new_method|test_method
runtime/testsrc/org/aspectj/runtime/reflect/RuntimePerformanceTest.invokeSignatureToString(Signature, long),False,new_method|test_method
runtime/testsrc/org/aspectj/runtime/reflect/RuntimePerformanceTest.warmUp(Signature),False,new_method|test_method
runtime/testsrc/org/aspectj/runtime/reflect/RuntimePerformanceTest.makeMethodSig(String),False,new_method|test_method
runtime/testsrc/org/aspectj/runtime/reflect/SignatureTest.testToShortMiddleLongString(),False,new_method|test_method
#####
AspectJ
53981
05dabd1821fffd9f353d1e965a56658b962c82d7
proceed used as method name in around advice Using a method named proceed(..) in around advice confuses the compiler (in at least the 2-3 ways shown below). True of the current tree (untested in 1.1.1). Workaround for now is to rename the method. ---- first problem: NPE in compiler java.lang.NullPointerException at org.aspectj.ajdt.internal.compiler.ast.MakeDeclsPublicVisitor.endVisit(MakeDeclsPublicVisitor.java:44) public class Proceeding { public static void main(String[] args) { } static aspect A { interface IProceed { void proceed(Runnable next); } IProceed decorator; void around() : execution(void main(String[])) { decorator.proceed(new Runnable() { public void run() { proceed(); } }); } } } ---- second problem: incorrect error wrt number of arguments public class Proceeding { public static void main(String[] args) { } static aspect A { void around() : execution(void main(String[])) { Proceeding.proceed(null); // BUG: treated as proceed(Object); } } static void proceed(Object o) {} } ---- third hypothetical: we should document how ambiguity is resolved public class Proceeding { public static void main(String[] args) { } static aspect A { void around() : execution(void main(String[])) { proceed(); // special form or Proceeding.proceed()? } } void proceed() {} }
proceed used as method name in around advice Using a method named in around advice confuses the compiler (in at least the 2-3 ways shown below). True of the current tree (untested in 1.1.1). Workaround for now is to rename the method. ---- first problem: NPE in compiler ---- second problem: incorrect error wrt number of arguments ---- third hypothetical: we should document how ambiguity is resolved
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/Proceed.findEnclosingAround(Scope),True
tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.test023_proceedInAround1(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.test024_proceedInAround2(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.test025_proceedInAround3(),False,new_method|test_method
#####
AspectJ
60015
ef7885fd1269261aec9cb1265f0e15472fdb03bb
"NPE, Incorrect XLint:unmatchedSuperTypeInCall warning" (This is an incomplete bug report -- sorry no time not to further isolate.) Running AJDT 1.1.6, I get dozens of these warnings: ---------- Warning does not match because declaring type is java.lang.Object, if match desired use target(st.ata.mc.exim.DatastoreReader) [Xlint:unmatchedSuperTypeInCall] Blah.aj project/src/package/dir line 22 ---------- for something like this code: ---------- import pack.Interface; ... pointcut dsrCall() : call(* Interface.*(..)); // WARNING HERE ... ---------- Each warning points to the pointcut (not the join point shadow). NPE running from the command-line with the latest tree (will attach).
"NPE, Incorrect XLint: warning" (This is an incomplete bug report -- sorry no time not to further isolate.) Running AJDT 1.1.6, I get dozens of these warnings: ---------- Warning does not match because declaring type is , if match desired use target() [Xlint:] line 22 ---------- for something like this code: ---------- // WARNING HERE ... ---------- Each warning points to the pointcut (not the join point shadow). NPE running from the command-line with the latest tree (will attach).
******
tests/bugs/IncorrectXlintOnInterface.run(),False,new_method|test_method
tests/bugs/IncorrectXlintOnInterface.main(String[]),False,new_method|test_method
weaver/src/org/aspectj/weaver/patterns/KindedPointcut.warnOnConfusingSig(Shadow),True
#####
AspectJ
61411
39c3a3bb4a0c939c1dfbc33b0ba560614b43d8a2
AJDoc launch script on Windows can lose arguments Using AspectJ 1.2rc1 on Windows XP This report highlights a problem that I've seen using ajdoc.bat on Windows but the issue applies equally to the ajc.bat and ajbrowser.bat files as well. The %ASPECTJ_HOME%\bin\ajdoc.bat file that users run to launch the ajdoc tool imposes a limit of only 9 command line arguments that may be passed to the class org.aspectj.tools.ajdoc.Main. In scenarios where there the -sourcepath, -classpath, -d etc options are used it is easy for these to "eat up" the list of arguments that are passed into the JVM. A long list of packages entered at the end of the ajdoc.bat command can be truncated or possibly even ignored (in which case an error message will be output telling the user that no classes or packages have been specified). In order to prevent a limit being put on the number of arguments passed to the launched JVM, the invocation line needs to end with %* rather than the %1 %2 %3 %4 %5 %6 %7 %8 %9 list it currently uses. The proposed fix also *seems* (could somebody else confirm this ?) to sort out another problem regarding the ajdoc.bat file which is this : long semi- colon delimited paths supplied as the arguments for the -sourcepath and -classpath options seem to get split apart and passed into the JVM as separate arguments unless the entire path list is supplied inside quotes. This should not be necessary. It seems that the batch file processor interprets the semi-colons in a path list as delimiters between arguments. Consequently each element in the path list is treated as a separate argument instead of being part of one big string representing the sourcepath or classpath.
AJDoc launch script on Windows can lose arguments Using AspectJ 1.2rc1 on Windows XP This report highlights a problem that I've seen using on Windows but the issue applies equally to the and files as well. The file that users run to launch the ajdoc tool imposes a limit of only 9 command line arguments that may be passed to the class In scenarios where there the -sourcepath, -classpath, -d etc options are used it is easy for these to "eat up" the list of arguments that are passed into the JVM. A long list of packages entered at the end of the command can be truncated or possibly even ignored (in which case an error message will be output telling the user that no classes or packages have been specified). In order to prevent a limit being put on the number of arguments passed to the launched JVM, the invocation line needs to end with %* rather than the %1 %2 %3 %4 %5 %6 %7 %8 %9 list it currently uses. The proposed fix also *seems* (could somebody else confirm this ?) to sort out another problem regarding the file which is this : long semi- colon delimited paths supplied as the arguments for the -sourcepath and -classpath options seem to get split apart and passed into the JVM as separate arguments unless the entire path list is supplied inside quotes. This should not be necessary. It seems that the batch file processor interprets the semi-colons in a path list as delimiters between arguments. Consequently each element in the path list is treated as a separate argument instead of being part of one big string representing the sourcepath or classpath.
******
build/src/$installer$/org/aspectj/Main.onWindowsPro(),True
#####
AspectJ
61536
45bce91f642a86ca3db7238d9e4cfb81d85e4f5b
"Front-end bug, shouldn't allow patterns of the form foo.., should be foo..*"See following code: public class Test2 { public static void main(String args[]) { System.out.println("Hi"); } } aspect Aspect2 { // shouldn't one have to say, java..* instead of java.. in the following?? // Note that the first advice (incorrect one) passes the front-end, but does // not match, whereas the second one does match. I believe the front-end // should reject the first one. before () : call( * java..(..)) &amp;&amp; within(Test2) { System.out.println( "Incorrect One: Before a call of method in a java package "); } before () : call( * java..*(..)) &amp;&amp; within(Test2) { System.out.println( "Correct One: Before a call of method in a java package "); } }
"Front-end bug, shouldn't allow patterns of the form foo.., should be foo..*"See following code:  // shouldn't one have to say, instead of java.. in the following?? // Note that the first advice (incorrect one) passes the front-end, but does // not match, whereas the second one does match. I believe the front-end // should reject the first one.  "Incorrect One: Before a call of method in a java package  "Correct One: Before a call of method in a java package
******
weaver/src/org/aspectj/weaver/patterns/PatternParser.parseDottedNamePattern(),True
#####
AspectJ
53999
936459c28229321deb0b09d076193be32cd9754e
"""can't bind type"" message has $ for . in type name for declare soft" cosmetic mistake in error message... expected: can't bind type name 'unknown.Error' actual: can't bind type name 'unknown$Error' (not sure why it would ever be munged with $) 
"""can't bind type"" message has $ for . in type name for declare soft" cosmetic mistake in error message... expected: can't bind type name '' actual: can't bind type name '' (not sure why it would ever be munged with $)
******
tests/bugs/Cosmetic.main(String[]),False,new_method|test_method
tests/bugs/Cosmetic.test(),False,new_method|test_method
weaver/src/org/aspectj/weaver/patterns/WildTypePattern.resolveBindings(IScope, Bindings, boolean, boolean),True
#####
AspectJ
65319
b75cd93e0de66996397e9f18809973abec91fe46
ajc crashes when compiling the following program (binding this() and target()) class Test { public static void main(String args[]) { new Test().method(); } public void method() { new Test2().method2(); } } class Test2 { public void method2() {} } aspect Plain { before(Test x): call(void *.* (..)) &amp;&amp; (this(x) || target(x)) { } }
ajc crashes when compiling the following program (binding  and )
******
tests/bugs/oxford/PR65319.main(String),False,new_method|test_method
tests/bugs/oxford/PR65319.method(),False,new_method|test_method
tests/bugs/oxford/PR65319.method3(),False,new_method|test_method
tests/bugs/oxford/PR65319.method4(Test),False,new_method|test_method
tests/bugs/oxford/PR65319.method2(),False,new_method|test_method
tests/bugs/oxford/PR65319.method3(Test),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.test026_bindingThisAndTargetToTheSameFormal(),False,new_method|test_method
weaver/src/org/aspectj/weaver/bcel/BcelAdvice.getAdviceArgSetup(BcelShadow, BcelVar, InstructionList),True
weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.findResidueNoEllipsis(Shadow, ExposedState, TypePattern[]),True
weaver/src/org/aspectj/weaver/patterns/ExposedState.ExposedState(int),True
weaver/src/org/aspectj/weaver/patterns/ExposedState.set(int, Var),True
weaver/src/org/aspectj/weaver/patterns/ExposedState.setErroneousVar(int formalIndex),False,new_method
weaver/src/org/aspectj/weaver/patterns/ExposedState.isErroneousVar(int),False,new_method
weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.findResidue(Shadow, ExposedState),True
#####
AspectJ
68991
64183c38266114bce7aa60ff743b4b9eda5cbe2d
intertype initialisers should match field set pointcuts /* initialisers of intertype fields should match field set pointcuts. In the example below, the output should be set field set(int C.n) set field set(int C.m) get field get(int C.n) set field set(int C.n) but the first field set (of C.n) is not picked up. */ aspect Aspect { private int C.n = 13; before() : get(* C.*) { System.out.println("get field "+thisJoinPointStaticPart); } before() : set(* C.*) { System.out.println("set field "+thisJoinPointStaticPart); } public void C.foo() { n++; } } class C { int m = 20; } public class ITFieldsAdvice { public static void main(String[] args) { C c = new C(); c.foo(); } }
intertype initialisers should match field set pointcuts /* initialisers of intertype fields should match field set pointcuts. In the example below, the output should be set field set field get field set field but the first field set is not picked up.
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeFieldDeclaration.resolve(ClassScope),True
tests/bugs/PR68991/Oxford.main(String[]),False,new_method|test_method
tests/bugs/PR68991/Simple.main(String[]),False,new_method|test_method
tests/bugs/PR68991/Simple.chkNext(List,String),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.test026_bindingThisAndTargetToTheSameFormal(),False,formatting|test_method
tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.test030_privateITDinitialisersBeingMatched(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.test031_privateITDinitialisersBeingMatched_OxfordTest(),False,new_method|test_method
#####
AspectJ
69011
2cc4826419d8c08e3879e600b82354fac2596241
ajdoc fails when using default package When trying to document classes that are in the default package, the following error occurs: &gt; Calling ajc... &gt; Building signature files... &gt; Calling javadoc... Loading source file C:\eclipse_RC3\eclipse\ajdocworkingdir\A.java... C:\eclipse_RC3\eclipse\ajdocworkingdir\A.java:1: &lt;identifier&gt; expected package ; ^ 1 error &gt; Decorating html files... &gt; Decorating C:\doc\classX.html... An internal error occured in ajdoc Please copy the following text into an email message and send it, along with any additional information you can add to: aspectj-dev@eclipse.org java.io.FileNotFoundException: C:\doc\classX.html (The system cannot find the file specified) java.io.FileNotFoundException: C:\doc\classX.html (The system cannot find the file specified) at java.io.FileInputStream.open(Native Method) at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:106) at java.io.FileReader.&lt;init&gt;(FileReader.java:55) at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFile (HtmlDecorator.java:142) at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromDecl (HtmlDecorator.java:115) at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromDecls (HtmlDecorator.java:54) at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromInputFiles (HtmlDecorator.java:43) at org.aspectj.tools.ajdoc.Main.main(Main.java:210)
ajdoc fails when using default package When trying to document classes that are in the default package, the following error occurs: &gt; Calling ajc... &gt; Building signature files... &gt; Calling javadoc... Loading source file :1: &lt;identifier&gt; expected package ; ^ 1 error &gt; Decorating html files... &gt; Decorating ... An internal error occured in Please copy the following text into an email message and send it, along with any additional information you can add to: aspectj-dev@eclipse.org : (The system cannot find the file specified)
******
ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.processFile(SymbolManager, File, File),True
ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.testCoverage(),False,test_method
#####
AspectJ
46298
4921f0c8f03353385d709bc79a7dd301c2caa5df
Aspectj generate code does not de-compile cleanly. Under certain condition you can not cleanly decompile code generated by the aspectj compiler/byte code weaver. package com.regular; public class ExceptionCatcher { public ExceptionCatcher() { super(); } public void catchException() { try { ExceptionThrower throwUp = new ExceptionThrower(); throwUp.throwException(); } catch(Exception e) { System.out.println("Inside my catch block"); } } public static void main(String[] args) { ExceptionCatcher catcher = new ExceptionCatcher(); catcher.catchException(); } } package com.aop; import org.aspectj.lang.JoinPoint; public aspect ExceptionHandler { pointcut classList() : within(com.regular..*); before(Throwable e) : classList() &amp;&amp; handler(*) &amp;&amp; args(e) { System.out.println("Starting before block"); log(thisJoinPointStaticPart, e); System.out.println("End of before block"); } private void log(JoinPoint.StaticPart jp, Throwable e) { System.out.println("Class Name: " + jp.getSignature ().getDeclaringType()); System.out.println("Error Message" + e.getMessage() ); } } Runing JAD: jad ExceptionCatcher.class Parsing ExceptionCatcher.class... Generating ExceptionCatcher.jad Couldn't fully decompile method catchException Couldn't resolve all exception handlers in method catchException Now the JAD Output: // Decompiled by Jad v1.5.7. Copyright 1997-99 Pavel Kouznetsov. // Jad home page: http://www.geocities.com/SiliconValley/Bridge/8617/jad.html // Decompiler options: packimports(3) // Source File Name: ExceptionCatcher.java package com.regular; import com.aop.ExceptionHandler; import com.capitalone.risk.aop.ITestInterface; import com.capitalone.risk.aop.ITestInterfaceAspect; import java.io.PrintStream; import org.aspectj.runtime.reflect.Factory; // Referenced classes of package com.regular: // ExceptionThrower public class ExceptionCatcher implements com.aop.IntroductionPointCut.IPhilipsTarget { public ExceptionCatcher() { } public void catchException() { if(this instanceof ITestInterface) ITestInterfaceAspect.aspectOf ().ajc$before$com_capitalone_risk_aop_ITestInterfaceAspect$113((ITestInterface) this); ExceptionThrower throwUp = new ExceptionThrower(); throwUp.throwException(); break MISSING_BLOCK_LABEL_77; Exception exception; exception; ExceptionHandler.aspectOf().ajc$before$com_aop_ExceptionHandler$1f8 (exception, ajc$tjp_0); Exception e = exception; System.out.println("Inside my catch block"); break MISSING_BLOCK_LABEL_77; Throwable throwable; throwable; if(this instanceof ITestInterface) ITestInterfaceAspect.aspectOf ().ajc$after$com_capitalone_risk_aop_ITestInterfaceAspect$172((ITestInterface) this); throw throwable; if(this instanceof ITestInterface) ITestInterfaceAspect.aspectOf ().ajc$after$com_capitalone_risk_aop_ITestInterfaceAspect$172((ITestInterface) this); return; } public static void main(String args[]) { ExceptionCatcher catcher = new ExceptionCatcher(); catcher.catchException(); } public static final org.aspectj.lang.JoinPoint.StaticPart ajc$tjp_0; static { Factory factory = new Factory("ExceptionCatcher.java", Class.forName ("com.regular.ExceptionCatcher")); ajc$tjp_0 = factory.makeSJP("exception-handler", factory.makeCatchClauseSig("0--com.regular.ExceptionCatcher- java.lang.Exception-&lt;missing&gt;-"), 33); } } The aspect class: jad ExceptionHandler.class Parsing ExceptionHandler.class... Generating ExceptionHandler.jad Couldn't fully decompile method aspectOf // Decompiled by Jad v1.5.7. Copyright 1997-99 Pavel Kouznetsov. // Jad home page: http://www.geocities.com/SiliconValley/Bridge/8617/jad.html // Decompiler options: packimports(3) // Source File Name: ExceptionHandler.java package com.aop; import java.io.PrintStream; import org.aspectj.lang.NoAspectBoundException; import org.aspectj.lang.Signature; public class ExceptionHandler { public ExceptionHandler() { } public void ajc$before$com_aop_ExceptionHandler$1f8(Throwable e, org.aspectj.lang.JoinPoint.StaticPart thisJoinPointStaticPart) { System.out.println("Starting before block"); log(thisJoinPointStaticPart, e); System.out.println("End of before block"); } private void log(org.aspectj.lang.JoinPoint.StaticPart jp, Throwable e) { System.out.println("Class Name: " + jp.getSignature().getDeclaringType ()); System.out.println("Error Message" + e.getMessage()); } public static ExceptionHandler aspectOf() { ajc$perSingletonInstance; JVM INSTR dup ; JVM INSTR ifnull 8; goto _L1 _L2 _L1: return; _L2: throw new NoAspectBoundException(); } public static boolean hasAspect() { return ajc$perSingletonInstance != null; } private static void ajc$postClinit() { ajc$perSingletonInstance = new ExceptionHandler(); } public static final ExceptionHandler ajc$perSingletonInstance; static { ajc$postClinit(); } } Enjoy! Ron
Aspectj generate code does not de-compile cleanly. Under certain condition you can not cleanly decompile code generated by the aspectj compiler/byte code weaver. package com.regular; Runing JAD: jad ...  Couldn't fully decompile method Couldn't resolve all exception handlers in method Now the JAD Output: // Decompiled by Jad v1.5.7. Copyright 1997-99 Pavel Kouznetsov. // Jad home page: // Decompiler options:  // Source File Name: // Referenced classes of package : // The aspect class: jad Parsing ... Generating Couldn't fully decompile method  // Decompiled by Jad v1.5.7. Copyright 1997-99 Pavel Kouznetsov. // Jad home page:// Decompiler options: // Source File Name:Starting before block End of before blockError Message JVM INSTR dup ; JVM INSTR  8; goto Enjoy! Ron
******
weaver/src/org/aspectj/weaver/bcel/BcelShadow.prepareForMungers(),True
#####
AspectJ
70773
9aed31d18e3848c72c6963dc3a6ee4661a79add9
AspectJ Error: ConncurrentModificationException thrown: null In AspectJ 1.1.11 for Eclipse, build ID 1.2.0 (and also in the previous 1.1.10) on Eclipse version 3.0.0, build ID 200406351208: If I enable incremental compilation and make a change to a file (typing a space and deleting it, or editing a comment), I get a "ConncurrentModificationException thrown: null" error.
AspectJ Error: thrown: null In AspectJ 1.1.11 for Eclipse, build ID 1.2.0 (and also in the previous 1.1.10) on Eclipse version 3.0.0, build ID 200406351208: If I enable incremental compilation and make a change to a file (typing a space and deleting it, or editing a comment), I get a " thrown: null" error.
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.createBinaryTypeFrom(IBinaryType, PackageBinding, boolean),True
#####
AspectJ
71723
dfb15c1777ab6995528a0a0d49faf0ef74578db6
Inconsistency in scoping of protected members in ITDs When introducing new member functions to existing classes via inter-type declarations, the scoping rules that apply to the ITD bodies are the same as for the aspect - for example, private members of the target class cannot be accessed unless the aspect is privileged. Similarly, protected members of classes in different packages should not be visible in ITDs unless the aspect is privileged. This rule is only enforced for protected members declared in the target class - protected members that are inherited are visible from ITDs in aspects in different packages. The following is an example of this: ---------------------- package foo; public class Foo extends AncientFoo { protected int i() { return 42; } public static void main(String[] args) { new Foo().doStuff(); } public void doStuff() { } protected int ancientI() { return 42; } } class AncientFoo { protected int ancientI() { return -42; } protected int ancientJ() { return 0; } } ---------- package bar; import foo.Foo; aspect Bar { public void Foo.doing() { try { System.out.println(i()); // fails in ajc System.out.println(ancientI()); // fails in ajc System.out.println(ancientJ()); // succeeds System.out.println(clone()); // succeeds } catch(Throwable t) { } } before(Foo f) : call(* doStuff(..)) &amp;&amp; target(f) { f.doing(); } } ------------------- All four calls in Foo.doing() should fail, as they refer to protected members of foo.Foo from package bar. However, only the first 2 - the ones directly declared/overridden in foo.Foo - are detected as errors, and removing them makes the rest compile and execute. Best wishes, Pavel
Inconsistency in scoping of protected members in ITDs When introducing new member functions to existing classes via inter-type declarations, the scoping rules that apply to the ITD bodies are the same as for the aspect - for example, private members of the target class cannot be accessed unless the aspect is privileged. Similarly, protected members of classes in different packages should not be visible in ITDs unless the aspect is privileged. This rule is only enforced for protected members declared in the target class - protected members that are inherited are visible from ITDs in aspects in different packages. The following is an example of this: ----------------------  ----------  ------------------- All four calls in should fail, as they refer to protected members of from package bar. However, only the first 2 - the ones directly declared/overridden in - are detected as errors, and removing them makes the rest compile and execute. Best wishes, Pavel
******
tests/bugs/pr71723/foo/Foo.i(),False,new_method|test_method
tests/bugs/pr71723/foo/Foo.doStuff(),False,new_method|test_method
tests/bugs/pr71723/foo/Foo.ancientI(),False,new_method|test_method
tests/bugs/pr71723/foo/Foo.ancientJ(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.test045_ITDprotectedVisibility(),False,new_method|test_method
#####
AspectJ
44191
061395c8c7fe681ab40ab53a7d1bfeb8e17c1028
"Need better error message for ""can't find type"""I have experienced situations where IAJC outputs a message like this at the end of compilation. [iajc] can't find type org.xxx.SomeTest In my case this was one time highly confusing since I did not expect the class in question to be referred anywhere in the project (I have to date still not located the reference). For such cases, it would be extremely nice if the error message would display WHY it need the class (i.e. the name of the refering class(es) or aspect(es) possibly with a reasonable cutoff as there is seldom need to list all referals). So I would like a message like this: [iajc] can't find type org.xxx.SomeTest referred by org.yyy.SomeClass,org.yy.SomeOtherClass ...
"Need better error message for ""can't find type"""I have experienced situations where IAJC outputs a message like this at the end of compilation. [iajc] can't find type In my case this was one time highly confusing since I did not expect the class in question to be referred anywhere in the project (I have to date still not located the reference). For such cases, it would be extremely nice if the error message would display WHY it need the class (i.e. the name of the refering class(es) or aspect(es) possibly with a reasonable cutoff as there is seldom need to list all referals). So I would like a message like this: [iajc] can't find referred by ...
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.checkSpec(ClassScope),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.getSuperclass(),True
weaver/src/org/aspectj/weaver/ResolvedTypeX.getDeclaredInterfaces(),True
weaver/src/org/aspectj/weaver/ResolvedTypeX.getSuperclass(),True
weaver/src/org/aspectj/weaver/ResolvedTypeX.addInterTypeMunger(ConcreteTypeMunger),True
weaver/src/org/aspectj/weaver/bcel/BcelAdvice.collectCheckedExceptions(TypeX[]),True
weaver/src/org/aspectj/weaver/bcel/BcelShadow.createThisJoinPoint(),True
getThisJoinPointStaticPartBcelVar(),True
addPreInitializationReturnCode(LazyMethodGen, Type[]),True
weaver/src/org/aspectj/weaver/patterns/DeclareParents.ResolvedTypeX maybeGetNewParent(ResolvedTypeX, TypePattern, World),True
weaver/src/org/aspectj/weaver/patterns/DeclareSoft.resolve(IScope),True
#####
AspectJ
72157
eca1429e79b3dc55c1f93ffbadb3e50eb9808d9c
declare soft can cause programs with invalid exception behaviour to be generated Compiling the program below results in the constructor for the class SCE2 throwing Exception, which it is not declared to throw either in the source code or in the generated bytecode. If the 'declare soft' statement is removed, then the super() call in the SCE2 constructor is correctly reported as throwing an undeclared exception; it seems that the 'declare soft' statement turns off the exception checking of the super() call despite there being no join point which covers this call that would actually soften the exception. I'm using 'DEVELOPMENT built on Monday Aug 16, 2004 at 13:50:47 GMT'. public class SuperConsExc { public SuperConsExc() throws Exception { throw new Exception(); } public static void main(String[] args) { new SCE2(); } } class SCE2 extends SuperConsExc { public SCE2() { super(); } } aspect SCEAspect { declare soft: Exception: within(SCE2); }
declare soft can cause programs with invalid exception behaviour to be generated Compiling the program below results in the constructor for the class throwing Exception, which it is not declared to throw either in the source code or in the generated bytecode. If the 'declare soft' statement is removed, then the call in the constructor is correctly reported as throwing an undeclared exception; it seems that the 'declare soft' statement turns off the exception checking of the call despite there being no join point which covers this call that would actually soften the exception. I'm using 'DEVELOPMENT built on Monday Aug 16, 2004 at 13:50:47 GMT'.
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.unhandledException(TypeBinding, ASTNode),True
tests/bugs/ConvertToUnchecked.Root(String),False,test_method
tests/bugs/PR72157.PR72157(),False,new_method|test_method
tests/bugs/PR72157.main(String[]),False,new_method|test_method
tests/bugs/PR72157.SCE2(),False,new_method|test_method
tests/bugs/PR72157.Foo(),False,new_method|test_method
tests/bugs/PR72157.Goo(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.test057_decSoftWithSuper(),False,new_method|test_method
#####
AspectJ
57666
2b8fa314f21eddf8551715fdd571da2b611411d0
duplicate manifests cause resource-copying to gack (Ah, the joy of build infrastructure...) Mostly self-explanatory trace, from a build Monday Apr 5, 2004 at 08:46:01 GMT: duplicate entry: META-INF/MANIFEST.MF duplicate entry: META-INF/MANIFEST.MF java.util.zip.ZipException: duplicate entry: META-INF/MANIFEST.MF at java.util.zip.ZipOutputStream.putNextEntry(ZipOutputStream.java:163) at java.util.jar.JarOutputStream.putNextEntry(JarOutputStream.java:90) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.writeResource(AjBuildManager.java:344) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.copyResourcesFromJarFile(AjBuildManager.java:288) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.copyResourcesToDestination(AjBuildManager.java:253) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:195) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:94) at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:102) at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53) at org.aspectj.tools.ajc.Main.run(Main.java:280) at org.aspectj.tools.ajc.Main.runMain(Main.java:217) at org.aspectj.tools.ajc.Main.main(Main.java:79)
duplicate manifests cause resource-copying to gack (Ah, the joy of build infrastructure...) Mostly self-explanatory trace, from a build Monday Apr 5, 2004 at 08:46:01 GMT: duplicate entry: duplicate entry:
******
ajde/testsrc/org/aspectj/ajde/AjdeTests.duite(),False,test_method
ajde/testsrc/org/aspectj/ajde/DuplicateManifestTest.setUp(),False,new_method|test_method
ajde/testsrc/org/aspectj/ajde/DuplicateManifestTest.testWeave(),False,new_method|test_method
ajde/testsrc/org/aspectj/ajde/DuplicateManifestTest.compareManifests(File, File),False,new_method|test_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.copyResourcesFromJarFile(File),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.acceptResource(String),True
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.makeDuplicateManifestTestJars(),False,new_method|test_method
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.main(String[]),False,test_method
weaver/src/org/aspectj/weaver/bcel/BcelWeaver.addJarFile(File, File, boolean),True
weaver/src/org/aspectj/weaver/bcel/BcelWeaver.addManifest(Manifest),True
#####
AspectJ
58681
6ea830044009af2991178f1833b6386143f2cc1b
NAME? ajc should emit the available -X options on -help or -X request (the latter like java) to get more traffic and feedback on the experimental options.
NAME? ajc should emit the available -X options on -help or -X request (the latter like java) to get more traffic and feedback on the experimental options.
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.runCommand(String[], IMessageHandler),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.getXOptionUsage(),False,new_method
org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.run(String[], IMessageHolder),True
org.aspectj.ajdt.core/testsrc/EajcModuleTests.suite(),False,test_method
org.aspectj.ajdt.core/testsrc/org/aspectj/tools/ajc/MainTest.testMainbare(),False,test_method
#####
AspectJ
48990
10c6de6fbc8a0b9eb07801f4ac19bea8304a9cb3
Special case if(false) to not require a dynamic test FastMatch, the efficient pattern matching for pointcuts on the constant pool, is currrently only implemented for the within pointcut. I am planning to provide further oimplementations for other pointcuts by release 1.2.
Special case if(false) to not require a dynamic test, the efficient pattern matching for pointcuts on the constant pool, is currrently only implemented for the within pointcut. I am planning to provide further oimplementations for other pointcuts by release 1.2.
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/IfPseudoToken.maybeGetParsedPointcut(),True
weaver/src/org/aspectj/weaver/patterns/IfPointcut.makeIfFalsePointcut(State),False,new_method
weaver/src/org/aspectj/weaver/patterns/IfPointcut.IfFalsePointcut(),False,new_method
weaver/src/org/aspectj/weaver/patterns/IfPointcut.findResidue(Shadow, ExposedState),False,new_method
weaver/src/org/aspectj/weaver/patterns/IfPointcut.fastMatch(FastMatchInfo),False,new_method
weaver/src/org/aspectj/weaver/patterns/IfPointcut.match(Shadow),False,new_method
weaver/src/org/aspectj/weaver/patterns/IfPointcut.match(JoinPoint.StaticPart),False,new_method
weaver/src/org/aspectj/weaver/patterns/IfPointcut.resolveBindings(IScope, Bindings),False,new_method
weaver/src/org/aspectj/weaver/patterns/IfPointcut.resolveBindingsFromRTTI(),False,new_method
weaver/src/org/aspectj/weaver/patterns/IfPointcut.postRead(ResolvedTypeX),False,new_method
weaver/src/org/aspectj/weaver/patterns/IfPointcut.concretize1(ResolvedTypeX, IntMap),False,new_method
weaver/src/org/aspectj/weaver/patterns/IfPointcut.write(DataOutputStream),False,new_method
weaver/src/org/aspectj/weaver/patterns/IfPointcut.hashCode(),False,new_method
weaver/src/org/aspectj/weaver/patterns/IfPointcut.toString(),False,new_method
weaver/src/org/aspectj/weaver/patterns/IfPointcut.makeIfTruePointcut(State),False,new_method
weaver/src/org/aspectj/weaver/patterns/IfPointcut.IfTruePointcut(),False,new_method
weaver/src/org/aspectj/weaver/patterns/IfPointcut.findResidue(Shadow, ExposedState),False,new_method
weaver/src/org/aspectj/weaver/patterns/IfPointcut.fastMatch(FastMatchInfo),False,new_method
weaver/src/org/aspectj/weaver/patterns/IfPointcut.match(Shadow),False,new_method
weaver/src/org/aspectj/weaver/patterns/IfPointcut.match(JoinPoint.StaticPart),False,new_method
weaver/src/org/aspectj/weaver/patterns/IfPointcut.resolveBindings(IScope, Bindings),False,new_method
weaver/src/org/aspectj/weaver/patterns/IfPointcut.resolveBindingsFromRTTI(),False,new_method
weaver/src/org/aspectj/weaver/patterns/IfPointcut.postRead(ResolvedTypeX),False,new_method
weaver/src/org/aspectj/weaver/patterns/IfPointcut.concretize1(ResolvedTypeX, IntMap),False,new_method
weaver/src/org/aspectj/weaver/patterns/IfPointcut.write(DataOutputStream s),False,new_method
weaver/src/org/aspectj/weaver/patterns/IfPointcut.hashCode(),False,new_method
weaver/src/org/aspectj/weaver/patterns/IfPointcut.toString(),False,new_method
weaver/src/org/aspectj/weaver/patterns/Pointcut.read(DataInputStream, ISourceContext),True
#####
AspectJ
64331
573741c8081c6b6b45921cafaae39f37eede2302
java.lang.NullPointerException in WeaverMessageHandler class I've got an java.lang.NullPointerException while running the aspectJ 1.2 compiler. That's the stack trace: [iajc] If you don't find the exception below in a bug, please add a new bug [iajc] at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ [iajc] To make the bug a priority, please include a test program [iajc] that can reproduce this exception. [iajc] null [iajc] java.lang.NullPointerException [iajc] at org.aspectj.ajdt.internal.compiler.WeaverMessageHandler.buildSeeAlsoProblems(WeaverMessageHandler.java:172) [iajc] at org.aspectj.ajdt.internal.compiler.WeaverMessageHandler.handleMessage(WeaverMessageHandler.java:100) [iajc] at org.aspectj.weaver.ResolvedTypeX.checkInterTypeMungers(ResolvedTypeX.java:989) [iajc] at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:716) [iajc] at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:689) [iajc] at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:615) [iajc] at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:563) [iajc] at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:239) [iajc] at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:114) [iajc] at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:376) [iajc] at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:601) [iajc] at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:160) [iajc] at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:94) [iajc] at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:102) [iajc] at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53) [iajc] at org.aspectj.tools.ajc.Main.run(Main.java:280) [iajc] at org.aspectj.tools.ajc.Main.runMain(Main.java:217) [iajc] at org.aspectj.tools.ant.taskdefs.AjcTask.executeInSameVM(AjcTask.java:1157) [iajc] at org.aspectj.tools.ant.taskdefs.AjcTask.execute(AjcTask.java:954) [iajc] at org.apache.tools.ant.Task.perform(Task.java:341) [iajc] at org.apache.tools.ant.taskdefs.Sequential.execute(Sequential.java:117) [iajc] at org.apache.tools.ant.Task.perform(Task.java:341) [iajc] at net.sf.antcontrib.logic.IfTask.execute(Unknown Source) [iajc] at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) [iajc] at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) [iajc] at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) [iajc] at java.lang.reflect.Method.invoke(Method.java:324) [iajc] at org.apache.tools.ant.TaskAdapter.execute(TaskAdapter.java:147) [iajc] at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:193) [iajc] at org.apache.tools.ant.Task.perform(Task.java:341) [iajc] at org.apache.tools.ant.Target.execute(Target.java:309) [iajc] at org.apache.tools.ant.Target.performTasks(Target.java:336) [iajc] at org.apache.tools.ant.Project.executeTarget(Project.java:1339) [iajc] at org.apache.tools.ant.Project.executeTargets(Project.java:1255) [iajc] at org.apache.tools.ant.Main.runBuild(Main.java:609) [iajc] at org.apache.tools.ant.Main.start(Main.java:196) [iajc] at org.apache.tools.ant.Main.main(Main.java:235) [if] Error in class net.sf.antcontrib.logic.IfTask Sorry, i have no simple test case for that problem...
in class I've got an while running the aspectJ 1.2 compiler. That's the stack trace: [iajc] If you don't find the exception below in a bug, please add a new bug [iajc] at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ [iajc] To make the bug a priority, please include a test program [iajc] that can reproduce this exception. [iajc] null [iajc] Sorry, i have no simple test case for that problem...
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverMessageHandler.buildSeeAlsoProblems(List, CompilationResult, boolean),True
weaver/src/org/aspectj/weaver/ResolvedTypeX.checkInterTypeMungers(),True
#####
AspectJ
70241
a2469c733c9f65514c3949cb1cc7254495011894
outline view shows anonymous inner classes in different way than jdt outline See screenshots.
outline view shows anonymous inner classes in different way than jdt outline See screenshots.
******
ajde/testdata/extensions/InnerClasses.main(String[]),False,test_method
ajde/testdata/extensions/InnerClasses.toString(),False,test_method
ajde/testdata/extensions/InnerClasses.run(),False,test_method
ajde/testdata/extensions/InnerClasses.method(),False,test_method
ajde/testsrc/org/aspectj/ajde/ExtensionTests.testInnerClassesInASM(),False,new_method
ajde/testsrc/org/aspectj/ajde/ExtensionTests.getChild(IProgramElement,String),False,new_method
ajde/testsrc/org/aspectj/ajde/ExtensionTests.findChild(String,IProgramElement),False,new_method
ajde/testsrc/org/aspectj/ajde/ExtensionTests.walkit(IProgramElement,int),False,new_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.visit(TypeDeclaration, BlockScope),True
#####
AspectJ
69459
b18436307ecfed63c8995fd35013ffa07e5116e7
Hiding of Instance Methods by static methods Using Introduction it is possible to hide instance methods by static methods. Example: class Super { public void m(){}; } class Sub {} aspect A { public static void Sub.m(){} } Acccording to the Java Language Specification this is not allowed. Is this behaviour desired ?? It is also possible to override static methods by instance methods, wich causes a compile time error in java.
Hiding of Instance Methods by static methods Using Introduction it is possible to hide instance methods by static methods. Example: class Super { public void m(){}; } class Sub {} aspect A { public static void Sub.m(){} } Acccording to the Java Language Specification this is not allowed. Is this behaviour desired ?? It is also possible to override static methods by instance methods, wich causes a compile time error in java.
******
tests/bugs/intertypeOverrides/Aspect1.Subclass.staticMethod(),False,new_method|test_method
tests/bugs/intertypeOverrides/Aspect2.Subclass.nonstaticMethod(),False,new_method|test_method
tests/bugs/intertypeOverrides/IntertypeOverrides.m(),False,new_method|test_method
tests/bugs/intertypeOverrides/IntertypeOverrides2.m(),False,new_method|test_method
tests/bugs/intertypeOverrides/Superclass.staticMethod(),False,new_method|test_method
tests/bugs/intertypeOverrides/Superclass.nonstaticMethod(),False,new_method|test_method
weaver/src/org/aspectj/weaver/ResolvedTypeX.compareToExistingMembers(ConcreteTypeMunger, Iterator),False,comments
weaver/src/org/aspectj/weaver/ResolvedTypeX.checkLegalOverride(ResolvedMember parent, ResolvedMember),True
#####
AspectJ
30439
4feb835a5339c3f63d73fbd6db2fe307e1f08ed1
"spurious ""circular dependency"" error" AspectJ Compiler 1.1beta4 This program: aspect Foo { pointcut p1(): execution(void f()) &amp;&amp; cflow(execution(void f1())); pointcut p2(): execution(void f()) &amp;&amp; cflow(execution(void f2())); before(): p1() { } after(): p1() { } before(): p2() { } after(): p2() { } } class A { void f1() { f(); } void f2() { f(); } void f() { } } results in these errors: circular dependency at method-execution(void A.f()) circular dependency at method-execution(void A.f()) circular dependency at method-execution(void A.f()) circular dependency at method-execution(void A.f()) 4 errors If I comment out any one of the four pieces of advice, all the errors go away. Also, assuming that there is a valid reason for printing this error sometimes, how come there's no line number? --Doug
"spurious ""circular dependency"" error" AspectJ Compiler 1.1beta4 This program: results in these errors: circular dependency at  circular dependency at method circular dependency at method circular dependency at method 4 errors If I comment out any one of the four pieces of advice, all the errors go away. Also, assuming that there is a valid reason for printing this error sometimes, how come there's no line number? --Doug
******
weaver/src/org/aspectj/weaver/Advice.match(Shadow, World),True
weaver/src/org/aspectj/weaver/Lint.setFromProperties(File),True
weaver/src/org/aspectj/weaver/Lint.loadDefaultProperties(),True
weaver/src/org/aspectj/weaver/Lint.setFromProperties(Properties),True
weaver/src/org/aspectj/weaver/Lint.getMessageKind(String),True
weaver/src/org/aspectj/weaver/ResolvedTypeX.compareToExistingMembers(weaver/src/org/aspectj/weaver/ResolvedTypeX.ConcreteTypeMunger, Iterator),True
weaver/src/org/aspectj/weaver/ResolvedTypeX.checkLegalOverride(ResolvedMember, ResolvedMember),True
weaver/src/org/aspectj/weaver/ResolvedTypeX.interTypeConflictError(ConcreteTypeMunger, ConcreteTypeMunger),True
weaver/src/org/aspectj/weaver/NewConstructorTypeMunger.check(World),True
weaver/src/org/aspectj/weaver/NewConstructorTypeMunger.getExposedPointcuts(),True
weaver/src/org/aspectj/weaver/NewConstructorTypeMunger.addPointcutsResolvingConflicts(List, List, boolean),True
weaver/src/org/aspectj/weaver/Shadow.checkCanThrow(ShadowMunger, ResolvedTypeX),True
weaver/src/org/aspectj/weaver/Shadow.sortMungers(),True
weaver/src/org/aspectj/weaver/WeaverMessages.format(String),False,new_method
weaver/src/org/aspectj/weaver/WeaverMessages.format(String, Object),False,new_method
weaver/src/org/aspectj/weaver/WeaverMessages.format(String, Object, Object),False,new_method
weaver/src/org/aspectj/weaver/WeaverMessages.format(String, Object, Object, Object),False,new_method
weaver/src/org/aspectj/weaver/WeaverStateInfo.getTypeMungers(ResolvedTypeX),True
weaver/src/org/aspectj/weaver/World.resolve(TypeX, boolean),True
weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.weave(),True
weaver/src/org/aspectj/weaver/bcel/BcelWeaver.prepareToProcessReweavableState(),True
weaver/src/org/aspectj/weaver/bcel/BcelWeaver.processReweavableStateIfPresent(String, BcelObjectType),True
weaver/src/org/aspectj/weaver/bcel/BcelWeaver.weave(ResolvedTypeX),True
weaver/src/org/aspectj/weaver/bcel/ClassPathManager.addPath (String name, IMessageHandler),True
weaver/src/org/aspectj/weaver/bcel/LazyClassGen.writeBack(BcelWorld),True
weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.getMethod(),True
weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.concretize1(ResolvedTypeX inAspect, IntMap),True
weaver/src/org/aspectj/weaver/patterns/CflowPointcut.concretize1(ResolvedTypeX inAspect, IntMap),True
weaver/src/org/aspectj/weaver/patterns/DeclareParents.maybeGetNewParent(ResolvedTypeX, TypePattern, World),True
weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.resolve(IScope),True
matchingIndex(ResolvedTypeX),True

weaver/src/org/aspectj/weaver/patterns/DeclareSoft.resolve(IScope),True

weaver/src/org/aspectj/weaver/patterns/IfPointcut.concretize(ResolvedTypeX, IntMap),True
weaver/src/org/aspectj/weaver/patterns/IfPointcut.concretize1(inAspect, IntMap),True
weaver/src/org/aspectj/weaver/patterns/PerFromSuper.concretize(ResolvedTypeX),True
weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.concretize1(ResolvedTypeX, IntMap),True
weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.concretize1(ResolvedTypeX, IntMap),True
weaver/src/org/aspectj/weaver/patterns/TypePattern.notExactType(IScope),True
weaver/src/org/aspectj/weaver/patterns/WildTypePattern.resolveBindings(IScope, Bindings, boolean, boolean),True
weaver/testsrc/org/aspectj/weaver/BcweaverTests.suite(),False,test_method
weaver/testsrc/org/aspectj/weaver/WeaverMessagesTestCase.testAllMessagesDefined(),False,new_method|test_method
#####
AspectJ
71377
851da68a07bcbfac4414fadc1b9f3bc02fa810a5
Cannot advise private method call in around advice Pointcuts should match call joint points in advice. However AspectJ does not match calls to _private_ methods in around advice. The same applies to get/set pointcuts for _private fields. This is probably because in the testcase below a call to "privateMethod()" in the body of the around advice is a call to an accessor method: ajc$inlineAccessMethod$bug_nnnn_JoinPointInAroundAdvice$bug_nnnn_JoinPointInAro undAdvice$privateMethod("around"); public aspect JoinPointInAroundAdvice { private static Set privateCalls = new HashSet(); private static Set publicCalls = new HashSet(); pointcut internalCall () : call(* JoinPointInAroundAdvice.privateMethod(..)); before () : internalCall () { privateCalls.add(thisJoinPoint); } pointcut externalCall () : call(* JoinPointInAroundAdvice.publicMethod(..)); before () : externalCall () { publicCalls.add(thisJoinPoint); } pointcut execTest () : execution(* JoinPointInAroundAdvice.test()); before () : execTest () { privateMethod("before"); publicMethod("before"); } void around () : execTest () { privateMethod("around"); publicMethod("around"); proceed(); } // void around () : execTest () { // Runnable runnable = new Runnable () { // public void run () { // privateMethod("around closure"); // publicMethod; // proceed(); // } // }; // runnable.run(); // } after () : execTest () { privateMethod("after"); publicMethod("after"); } private static void privateMethod (String from) { System.out.println("? privateMethod() " + from); } public static void publicMethod (String from) { System.out.println("? publicMethod() " + from); } public static void test () { System.out.println("? test()"); privateMethod("test"); publicMethod("test"); } public static void main (String[] args) { test(); if (privateCalls.size() != publicCalls.size()) { throw new RuntimeException("Missing join point"); } else { System.out.println("Success."); } } }
Cannot advise private method call in around advice  should match call joint points in advice. However AspectJ does not match calls to _private_ methods in around advice. The same applies to get/set pointcuts for _private fields. This is probably because in the testcase below a call to "" in the body of the around advice is a call to an accessor method: Missing join point Success.
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.generateMethod(ClassFile, MethodBinding, BodyGenerator),True
makeEffectiveSignatureAttribute(ResolvedMember, Shadow.Kind, boolean),false,new_method
generateMethod(ClassFile, MethodBinding, List, BodyGenerator),False,new_method
generateInlineAccessors(ClassFile, InlineAccessFieldBinding, ResolvedMember),True
tests/bugs/AroundAdviceJPs/FieldGetJoinPointsInAroundAdvice.main(String[]),False,new_method|test_method
test(),False,new_method|test_method
tests/bugs/AroundAdviceJPs/FieldJoinPointsInAroundAdvice.test(),False,new_method|test_method
main(String[]),False,new_method|test_method
tests/bugs/AroundAdviceJPs/JoinPointInAroundAdvice.privateMethod(String),False,new_method|test_method
tests/bugs/AroundAdviceJPs/JoinPointInAroundAdvice.publicMethod(String),False,new_method|test_method
tests/bugs/AroundAdviceJPs/JoinPointInAroundAdvice.test(),False,new_method|test_method
tests/bugs/AroundAdviceJPs/JoinPointInAroundAdvice.main(String[]),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.test001(),False,test_method|formatting
tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.test017_PrivateMethodCallsInAroundAdvice(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.test018_PrivateFieldSetsInAroundAdvice(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.test019_PrivateFieldGetsInAroundAdvice(),False,new_method|test_method
weaver/src/org/aspectj/weaver/bcel/LazyClassGen.getTjpField(BcelShadow),True
#####
AspectJ
67592
f6436e3fc84f7e140acb3a250a29fe38f9c20c35
value in the args[] array of thisjoinpoint can be changed by one advice decl and updated values seen in another advice decl In ajc a use of thisJoinPoint corresponds to an object of type JoinPoint, where a JoinPoint object has four components, which can be retrieved using accessor methods. this getThis() target getTarget() args getArgs() staticJoinPoint getStaticPart() In the case of args, the object returned is an Object array. This means that an advice decl can overwrite the args, and then another advice which shares the same JoinPoint will see the changed args. Here is a small example. In this aspect the before advice changes arg[0] to always be "Laurie" and then the after advice will always say that "Laurie won a million pounds". Is this the behaviour that is intended? I would have thought that the interface to args[] should be such that the values can only be read. Otherwise very strange interactions between advice decls could occur. --------------------------------------------------------------------- public class Main { public static Main v = new Main(); void lottery ( String arg ) { System.out.println("The arg in lottery is " + arg); } public static void main (String args[]) { v.lottery("Oege"); v.lottery("Ganesh"); } } --------------------------------------------------------------------- public aspect Aspect { // This pair of advice decls demonstrates that an advice can change to // the args of a join point. before () : call(* lottery(java.lang.String)) &amp;&amp; !within(Aspect) { System.out.println("BEFORE " + thisJoinPoint + " at " + thisJoinPointStaticPart.getSourceLocation()); Object args[] = thisJoinPoint.getArgs(); System.out.println("arg[0] is " + args[0]); args[0] = "Laurie"; System.out.println("... now it is " + thisJoinPoint.getArgs()[0]); } after () : call(* lottery(java.lang.String)) &amp;&amp; !within(Aspect) { System.out.println("AFTER " + thisJoinPoint + " at " + thisJoinPointStaticPart.getSourceLocation()); if (thisJoinPoint.getArgs()[0].equals("Laurie")) System.out.println("Laurie wins 1 million pounds!"); } }
value in the array of can be changed by one advice decl and updated values seen in another advice decl In ajc a use of corresponds to an object of type, where a object has four components, which can be retrieved using accessor methods. this target args In the case of args, the object returned is an Object array. This means that an advice decl can overwrite the args, and then another advice which shares the same will see the changed args. Here is a small example. In this aspect the before advice changes arg[0] to always be "Laurie" and then the after advice will always say that "Laurie won a million pounds". Is this the behaviour that is intended? I would have thought that the interface to should be such that the values can only be read. Otherwise very strange interactions between advice decls could occur. --------------------------------------------------------------------- The arg in lottery is --------------------------------------------------------------------- // This pair of advice decls demonstrates that an advice can change to // the args of a join point. "... now it is
******
runtime/src/org/aspectj/runtime/reflect/JoinPointImpl.getArgs(),True
runtime/testsrc/RuntimeModuleTests.suite(),False,test_method
runtime/testsrc/org/aspectj/runtime/reflect/JoinPointImplTest.testGetArgs(),False,new_method|test_method
#####
AspectJ
67774
7f19ab47a3df5327c6246420354089d1db1c765f
Nullpointer-exception in pointcuts using withincode() clause Hi, I am getting null-pointer-exceptions whenever I try to specify a pointcut with a "withincode(Signature)" clause. E.g.: public aspect DetectSystemOutErrorUsage { pointcut allSystemOutAndSystemErrAccesses(): (get(* System.out) || get(* System.err)) ; declare warning: allSystemOutAndSystemErrAccesses() &amp;&amp; !adviceexecution() &amp;&amp; !within(com.tivoli.act..Test*) &amp;&amp; !within(com.tivoli.act.log..*) &amp;&amp; !execution(* com.tivoli.act..*.main(..)) &amp;&amp; !execution(* com.tivoli.act..*.usage()) // &amp;&amp; !withincode(* com.tivoli.act..*.main(..)) // &amp;&amp; !withincode(* com.tivoli.act..*.usage()) : "Warning: use of System.out or System.err - consider logging instead!"; } In the above example excluding main() and usage() methods from the pointcut using an execution(...)-clause (shows) works but using a withincode()-clause (as commented) always yields an NPE: trouble in: null java.lang.NullPointerException at org.aspectj.weaver.patterns.SignaturePattern.matches (SignaturePattern.java:87) at org.aspectj.weaver.patterns.WithincodePointcut.match (WithincodePointcut.java:42) at org.aspectj.weaver.patterns.NotPointcut.match(NotPointcut.java:45) at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42) at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42) at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42) at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42) at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42) at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42) at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42) at org.aspectj.weaver.ShadowMunger.match(ShadowMunger.java:62) at org.aspectj.weaver.Checker.match(Checker.java:48) at org.aspectj.weaver.bcel.BcelClassWeaver.match (BcelClassWeaver.java:1121) at org.aspectj.weaver.bcel.BcelClassWeaver.matchInit (BcelClassWeaver.java:895) at org.aspectj.weaver.bcel.BcelClassWeaver.match (BcelClassWeaver.java:793) at org.aspectj.weaver.bcel.BcelClassWeaver.weave (BcelClassWeaver.java:343) at org.aspectj.weaver.bcel.BcelClassWeaver.weave (BcelClassWeaver.java:80) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:724) at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump (BcelWeaver.java:689) at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify (BcelWeaver.java:615) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:563) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave (AjCompilerAdapter.java:239) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling (AjCompilerAdapter.java:114) at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:376) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation (AjBuildManager.java:601) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild (AjBuildManager.java:160) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild (AjBuildManager.java:94) at org.aspectj.ajde.internal.CompilerAdapter.compile (CompilerAdapter.java:108) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run (AspectJBuildManager.java:165) !SESSION Jun 18, 2004 10:49:48.666 --------------------------------------------- eclipse.buildId=I200406110010 java.version=1.4.2_03 java.vendor=Sun Microsystems Inc. BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=de_CH !ENTRY org.eclipse.ajdt.ui 4 0 Jun 18, 2004 10:49:48.666 !MESSAGE NullPointerException thrown: null !STACK 0 java.lang.NullPointerException at org.aspectj.weaver.patterns.SignaturePattern.matches (SignaturePattern.java:87) at org.aspectj.weaver.patterns.WithincodePointcut.match (WithincodePointcut.java:42) at org.aspectj.weaver.patterns.NotPointcut.match(NotPointcut.java:45) at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42) at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42) at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42) at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42) at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42) at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42) at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42) at org.aspectj.weaver.ShadowMunger.match(ShadowMunger.java:62) at org.aspectj.weaver.Checker.match(Checker.java:48) at org.aspectj.weaver.bcel.BcelClassWeaver.match (BcelClassWeaver.java:1121) at org.aspectj.weaver.bcel.BcelClassWeaver.matchInit (BcelClassWeaver.java:895) at org.aspectj.weaver.bcel.BcelClassWeaver.match (BcelClassWeaver.java:793) at org.aspectj.weaver.bcel.BcelClassWeaver.weave (BcelClassWeaver.java:343) at org.aspectj.weaver.bcel.BcelClassWeaver.weave (BcelClassWeaver.java:80) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:724) at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump (BcelWeaver.java:689) at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify (BcelWeaver.java:615) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:563) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave (AjCompilerAdapter.java:239) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling (AjCompilerAdapter.java:114) at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:376) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation (AjBuildManager.java:601) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild (AjBuildManager.java:160) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild (AjBuildManager.java:94) at org.aspectj.ajde.internal.CompilerAdapter.compile (CompilerAdapter.java:108) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run (AspectJBuildManager.java:165) Michael
Nullpointer-exception in pointcuts using clause Hi, I am getting null-pointer-exceptions whenever I try to specify a pointcut with a "" clause. E.g.:  : "Warning: use of or - consider logging instead!"; } In the above example excluding and methods from the pointcut using an execution(...)-clause (shows) works but using a -clause (as commented) always yields an NPE: trouble in: !SESSION Jun 18, 2004 10:49:48.666 --------------------------------------------- eclipse.buildId=I200406110010 java.version=1.4.2_03 java.vendor=Sun Microsystems Inc. BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=de_CH !ENTRY Michael
******
weaver/src/org/aspectj/weaver/bcel/BcelShadow.getEnclosingCodeSignature(),True
#####
AspectJ
71878
2dfc73855a1d7ab7652476729e6575f9116e12b8
Bad injar aspect name on Linux If you checkout the "JarUsingProject" project from "org.eclipse.ajdt.test/manual testing" in the AJDT 1.1.12 tree, and look at the advised-by entries in the outline view and the context menu of the gutter annotation, on Windows you get "injar aspect: AbstractAspect.aj", but on Linux you get "injar aspect: C:\eclipse30AJDTPluginTest\eclipse\workspace\JarGeneratingProject\src\p1\AbstractAspect.aj". The Windows-style path indicates the location of the original class files in the JAR file, which was clearly built on Windows.
Bad injar aspect name on Linux If you checkout the "JarUsingProject" project from "org.eclipse.ajdt.test/manual testing" in the AJDT 1.1.12 tree, and look at the advised-by entries in the outline view and the context menu of the gutter annotation, on Windows you get "injar aspect: AbstractAspect.aj", but on Linux you get "injar aspect: C:\eclipse30AJDTPluginTest\eclipse\workspace\JarGeneratingProject\src\p1\AbstractAspect.aj". The Windows-style path indicates the location of the original class files in the JAR file, which was clearly built on Windows.
******
asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.createFileStructureNode(String),True
#####
AspectJ
72154
f5035234ee878003515413fee5e7e6bfa7a2228d
Support for simple dump file When the compiler terminates abnormally (exception) or behaves unexpectedly (warning/error/abort) a simple dump of the compiler state should be produced to aid problem diagnosis. The content and conditions under which the dump is produced should be configurable by the user but the facility should be enabled by default for exceptions. Consequently its inclusion should have negligible impact on compiler performance and footprint. The file should be attached to bug reports to give a complete and objective description of the user?s environment and support problem resolution where a testcase cannot be provided. One approach is to write a uniquely name file (using date &amp; time) in the current directory e.g ?ajcore.20040818.105200.txt? which should be human readable (it can be zipped if large) to allow the user to potentially diagnose their own problems or remove potentially sensitive data before submission. It should contain basic information such as AspectJ version, system properties and command line as well as failure information such as _full_ exception stack trace, compiler messages and internal compiler state.
Support for simple dump file When the compiler terminates abnormally (exception) or behaves unexpectedly (warning/error/abort) a simple dump of the compiler state should be produced to aid problem diagnosis. The content and conditions under which the dump is produced should be configurable by the user but the facility should be enabled by default for exceptions. Consequently its inclusion should have negligible impact on compiler performance and footprint. The file should be attached to bug reports to give a complete and objective description of the user?s environment and support problem resolution where a testcase cannot be provided. One approach is to write a uniquely name file (using date &amp; time) in the current directory e.g  which should be human readable (it can be zipped if large) to allow the user to potentially diagnose their own problems or remove potentially sensitive data before submission. It should contain basic information such as AspectJ version, system properties and command line as well as failure information such as _full_ exception stack trace, compiler messages and internal compiler state.
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.doCommand(IMessageHandler, boolean),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.populateBuildConfig(AjBuildConfig, String[], boolean, File),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.performCompilation(List),True
org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.run(String[], IMessageHolder),True
org.aspectj.ajdt.core/testdata/DumpTestCase/src/HelloWorld.main(String[]),False,new_method
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.suite(),False,test_method
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/CompilerDumpTestCase.setUp(),False,new_method|test_method
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/CompilerDumpTestCase.tearDown(),False,new_method|test_method
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/CompilerDumpTestCase.testDump(),False,new_method|test_method
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/CompilerDumpTestCase.testDumpWithWarnings(),False,new_method|test_method
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/CompilerDumpTestCase.testWithErrors(),False,new_method|test_method
weaver/src/org/aspectj/weaver/Dump.dump(String),False,new_method
weaver/src/org/aspectj/weaver/Dump.dumpWithException(weaver/src/org/aspectj/weaver/Dump.Throwable),False,new_method
weaver/src/org/aspectj/weaver/Dump.dumpOnExit(),False,new_method
weaver/src/org/aspectj/weaver/Dump.shouldDumpOnExit(),False,new_method
weaver/src/org/aspectj/weaver/Dump.setDumpOnException(boolean),False,new_method
weaver/src/org/aspectj/weaver/Dump.getDumpOnException(),False,new_method
weaver/src/org/aspectj/weaver/Dump.setDumpOnExit(IMessage.Kind),False,new_method
weaver/src/org/aspectj/weaver/Dump.setDumpOnExit(String),False,new_method
weaver/src/org/aspectj/weaver/Dump.getDumpOnExit(),False,new_method
weaver/src/org/aspectj/weaver/Dump.getLastDumpFileName(),False,new_method
weaver/src/org/aspectj/weaver/Dump.saveCommandLine(String[]),False,new_method
weaver/src/org/aspectj/weaver/Dump.saveFullClasspath(List),False,new_method
weaver/src/org/aspectj/weaver/Dump.saveMessageHolder(IMessageHolder),False,new_method
weaver/src/org/aspectj/weaver/Dump.registerNode(Class, INode),False,new_method
weaver/src/org/aspectj/weaver/Dump.Dump(String),False,new_method
weaver/src/org/aspectj/weaver/Dump.getFileName(),False,new_method
weaver/src/org/aspectj/weaver/Dump.dumpDefault(),False,new_method
weaver/src/org/aspectj/weaver/Dump.dumpException(Throwable),False,new_method
weaver/src/org/aspectj/weaver/Dump.dumpAspectJProperties(),False,new_method
weaver/src/org/aspectj/weaver/Dump.dumpDumpConfiguration(),False,new_method
weaver/src/org/aspectj/weaver/Dump.dumpFullClasspath(),False,new_method
weaver/src/org/aspectj/weaver/Dump.dumpSytemProperties(),False,new_method
weaver/src/org/aspectj/weaver/Dump.dumpCommandLine(),False,new_method
weaver/src/org/aspectj/weaver/Dump.dumpCompilerMessages(),False,new_method
weaver/src/org/aspectj/weaver/Dump.openDump(),False,new_method
weaver/src/org/aspectj/weaver/Dump.close(),False,new_method
weaver/src/org/aspectj/weaver/Dump.println(String),False,new_method
weaver/src/org/aspectj/weaver/Dump.println(Object[]),False,new_method
weaver/src/org/aspectj/weaver/Dump.println(Properties),False,new_method
weaver/src/org/aspectj/weaver/Dump.println(Throwable),False,new_method
weaver/src/org/aspectj/weaver/Dump.println(File),False,new_method
weaver/src/org/aspectj/weaver/Dump.println(List),False,new_method
weaver/src/org/aspectj/weaver/Dump.accept(IVisitor),False,new_method
weaver/src/org/aspectj/weaver/Dump.visitString(String),False,new_method
weaver/src/org/aspectj/weaver/Dump.visitList(List),False,new_method
weaver/src/org/aspectj/weaver/World.World(),True
weaver/src/org/aspectj/weaver/World.accept(Dump.IVisitor),False,new_method
weaver/src/org/aspectj/weaver/World.resolve(TypeX, boolean),True
weaver/src/org/aspectj/weaver/World.getShadowMungers(),True
weaver/src/org/aspectj/weaver/World.resolveObjectType(ResolvedTypeX.Name),True
weaver/src/org/aspectj/weaver/World.concreteAdvice(AjAttribute.AdviceAttribute, Pointcut, Member),True
weaver/src/org/aspectj/weaver/World.concreteTypeMunger(ResolvedTypeMunger, ResolvedTypeX),True
weaver/testsrc/org/aspectj/weaver/BcweaverTests.suite(),False,test_method
weaver/testsrc/org/aspectj/weaver/DumpTestCase.DumpTestCase(String name),False,new_method|test_method
weaver/testsrc/org/aspectj/weaver/DumpTestCase.setUp(),False,new_method|test_method
weaver/testsrc/org/aspectj/weaver/DumpTestCase.tearDown(),False,new_method|test_method
weaver/testsrc/org/aspectj/weaver/DumpTestCase.testSetDumpOnException(),False,new_method|test_method
weaver/testsrc/org/aspectj/weaver/DumpTestCase.testSetDumpOnExit(),False,new_method|test_method
weaver/testsrc/org/aspectj/weaver/DumpTestCase.testDump(),False,new_method|test_method
weaver/testsrc/org/aspectj/weaver/DumpTestCase.testDumpWithException(),False,new_method|test_method
weaver/testsrc/org/aspectj/weaver/DumpTestCase.testDumpOnExit(),False,new_method|test_method
weaver/testsrc/org/aspectj/weaver/DumpTestCase.testDumpOnExitExcluded(),False,new_method|test_method
weaver/testsrc/org/aspectj/weaver/DumpTestCase.testDumpOnExitIncluded(),False,new_method|test_method
weaver/testsrc/org/aspectj/weaver/DumpTestCase.assertContents(File, String, String),False,new_method|test_method
weaver/testsrc/org/aspectj/weaver/DumpTestCase.fileContains(File, String, String),False,new_method|test_method
weaver/testsrc/org/aspectj/weaver/DumpTestCase.recursiveCall(String, int),False,new_method|test_method
#####
AspectJ
68494
3707411c2b5fdd0294c2ab5305c32766644241f1
ajdoc does not support .aj files In addition to accepting .java source files ajdoc needs to accept .aj files.
ajdoc does not support files In addition to accepting source files ajdoc needs to accept files.
******
ajdoc/src/org/aspectj/tools/ajdoc/Main.main(String[]),True
ajdoc/src/org/aspectj/tools/ajdoc/Main.findFile(String),True
ajdoc/src/org/aspectj/tools/ajdoc/Main.parseArgs(List, File),True
ajdoc/src/org/aspectj/tools/ajdoc/StructureUtil.translateAjPathName(String),False,new_method
ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.processFile(SymbolManager, File, File),True
ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.testCoverage(),False,test_method
#####
AspectJ
72531
82eae551311afbd3a942d54e55b1c569c5f975b8
declare warning warns at wrong points I have a "declare warning" declaration that warns on usage of any method that returns an array of any POJO type, this should point to the methods that in reality return an array, but i see warnings at points other than these array returning methods, and also those that have void in their signature. In the attached files i get a warning at statements like: &gt; PrinterWorld p = new PrinterWorld();[in main()method] &gt; System.out.println("Hello World!"); &gt; return new Integer(3); and these being the first/only lines in their respective methods.
declare warning warns at wrong points I have a "declare warning" declaration that warns on usage of any method that returns an array of any POJO type, this should point to the methods that in reality return an array, but i see warnings at points other than these array returning methods, and also those that have void in their signature. In the attached files i get a warning at statements like: &gt; and these being the first/only lines in their respective methods.
******
tests/bugs/pr72531/de/rohith/HelloWorld.main(String[]),False,new_method|test_method
tests/bugs/pr72531/de/rohith/HelloWorldAspect.HelloWorldAspect(),False,new_method|test_method
tests/bugs/pr72531/de/rohith/HelloWorldAspect.print(String, Object),False,new_method|test_method
tests/bugs/pr72531/de/rohith/PrinterWorld.PrinterWorld(),False,new_method|test_method
tests/bugs/pr72531/de/rohith/PrinterWorld.print(),False,new_method|test_method
tests/bugs/pr72531/de/rohith/PrinterWorld.returnInt(),False,new_method|test_method
tests/bugs/pr72531/de/rohith/PrinterWorld.returnArrayWithCloning(),False,new_method|test_method
tests/bugs/pr72531/de/rohith/PrinterWorld.returnArrayWithoutCloning(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.test050_typePatternMatchingWithArrays(),False,new_method|test_method
weaver/src/org/aspectj/weaver/patterns/WildTypePattern.matchesExactlyByName(String),True
weaver/src/org/aspectj/weaver/patterns/WildTypePattern.resolveBindings(IScope, Bindings, boolean, boolean),True
weaver/testsrc/org/aspectj/weaver/patterns/TypePatternTestCase.testArrayMatch(),False,new_method
#####
AspectJ
54421
d43a39103f476d95cade6b87b604ee4578de25b3
Compile time declarations (warning and error) do not accept string concatenation (with +) The following code does not compile because the message uses string concatenation (the + operator). public class WarningSample { public void method() {} public void anotherMethod() { this.method(); } } aspect WarningAspect { pointcut illegalCall(): call(* WarningSample.method()) &amp;&amp; within(WarningSample); // the same thing happens with declare error declare warning: illegalCall() : "Hey, don't " + "do that, that is not nice. You should do something else"; }
Compile time declarations (warning and error) do not accept string concatenation (with +) The following code does not compile because the message uses string concatenation (the + operator). // the same thing happens with declare error declare warning: "Hey, don't " + "do that, that is not nice. You should do something else"
******
tests/bugs/decwStrings.method(),False,new_method|test_method
tests/bugs/decwStrings.anotherMethod(),False,new_method|test_method
tests/bugs/decwStrings.e1(),False,new_method|test_method
tests/bugs/decwStrings.e2(),False,new_method|test_method
tests/bugs/decwStrings.e3(),False,new_method|test_method
tests/bugs/decwStrings.e4(),False,new_method|test_method
tests/bugs/decwStrings.e5(),False,new_method|test_method
tests/bugs/decwStrings.e6(),False,new_method|test_method
tests/bugs/decwStringsErroneous.method(),False,new_method|test_method
tests/bugs/decwStringsErroneous.e1(),False,new_method|test_method
tests/bugs/decwStringsErroneous.e2(),False,new_method|test_method
tests/bugs/decwStringsErroneous.e3(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.test026_bindingThisAndTargetToTheSameFormal(),False,test_method|formatting
tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.test030_privateITDinitialisersBeingMatched(),False,test_method|formatting
tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.test032_stringConcatForDEOW(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.test033_stringConcatForDEOWErrorCase(),False,new_method|test_method
weaver/src/org/aspectj/weaver/patterns/PatternParser.parseErrorOrWarning(boolean),True
parsePossibleStringSequence(boolean),False,new_method
#####
AspectJ
49657
dbe1024f852c600d2752e5f39eb31ca4f5d72de9
Weaver results in rt error if affected base class not exposed I was weaving a 3rd party library and wrote an aspect that should affect both a base class and a derived class, but inadvertently wove only the derived class. This resulted in the following error. I would like the weaver to catch this kind of error at weave (link) time, rather than creating code that results in a rt error... I get this error in 1.1.1 final and in a fairly recent version from CVS HEAD: java.lang.AbstractMethodError at ajee.logging.LogManager.ajc$interMethodDispatch1 $ajee_logging_LogManager$ajee_logging_Loggable$getLogger(LogManager.java) at ajee.tracing.ExecutionTracer.ajc$before$ajee_tracing_ExecutionTracer$926 (ExecutionTracer.java:62) at library.Derived.&lt;init&gt;(Derived.java:46) This line is a call to super(); I've attached a small example that reproduces another error that I think is related: C:\devel\test\ctors\twoPass&gt;build C:\devel\test\ctors\twoPass&gt;call ajc -outjar fullBase.jar sample\Base.java sampl e\Derived.java Exception in thread "main" java.lang.ExceptionInInitializerError at sample.Derived.&lt;init&gt;(Derived.java:6) at sample.Derived.main(Derived.java:13) Caused by: org.aspectj.lang.NoAspectBoundException at sample.Trace.aspectOf(Trace.aj) at sample.Trace.&lt;init&gt;(Trace.aj:5) at sample.Trace.ajc$postClinit(Trace.aj) at sample.Trace.&lt;clinit&gt;(Trace.aj:5) ... 2 more
results in rt error if affected base class not exposed I was weaving a 3rd party library and wrote an aspect that should affect both a base class and a derived class, but inadvertently wove only the derived class. This resulted in the following error. I would like the weaver to catch this kind of error at weave (link) time, rather than creating code that results in a rt error... I get this error in 1.1.1 final and in a fairly recent version from CVS HEAD: This line is a call to ; I've attached a small example that reproduces another error that I think is related: Exception in thread  2 more
******
weaver/src/org/aspectj/weaver/WeaverMessages,True
org.aspectj.ajdt.core/testdata/partialHierarchy/sample/Base.Base(),False,new_method|test_method
org.aspectj.ajdt.core/testdata/partialHierarchy/sample/Base.foo(),False,new_method|test_method
org.aspectj.ajdt.core/testdata/partialHierarchy/sample/Derived.Derived(),False,new_method|test_method
org.aspectj.ajdt.core/testdata/partialHierarchy/sample/Derived.foo(),False,new_method|test_method
org.aspectj.ajdt.core/testdata/partialHierarchy/sample/Derived.main(String),False,new_method|test_method
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.suite(),True
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/PartiallyExposedHierarchyTestCase.setUp(),False,new_method|test_method
testPartiallyExposedHierarchy(),False,new_method|test_method
weaver/src/org/aspectj/weaver/ResolvedTypeX.getTopmostImplementor(ResolvedTypeX),False,new_method
weaver/src/org/aspectj/weaver/ResolvedTypeX.findHigher(ResolvedTypeX),False,new_method
weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.mungeNewMethod(BcelClassWeaver, NewMethodTypeMunger),True
#####
AspectJ
62642
84e4e53608871ab3ad0381d19abd8fa2e1bc4533
proper handling of ExceptionInIntializer inside &lt;clinit&gt; in presence of after throwing advice When a &lt;clinit&gt; of a class contains after throwing advice that may catch ExceptionInInitializer errors due to an embedded advice aspectOf() that fails, the ExceptionInIntializer error does not get properly reported. For the example below: public class Main { static int x = 13; int y; public Main() { y= 14; } public static void main(String args[]) { Main m = new Main(); m.y = 3; System.out.println("hi"); } } aspect Aspect { before () : within(*) { System.out.println("BEFORE " + thisJoinPointStaticPart.getKind() + " at " + thisJoinPointStaticPart.getSourceLocation()); } after () : within(*) { System.out.println("AFTER " + thisJoinPointStaticPart.getKind() + " at " + thisJoinPointStaticPart.getSourceLocation()); } } .... when compiled with ajc, and then run, the following exception is given, Exception in thread "main" java.lang.NoClassDefFoundError at Main.&lt;clinit&gt;(Main.java:1) when really one wants the following: Exception in thread "main" java.lang.ExceptionInInitializerError at Main. ... Caused by: org.aspectj.lang.NoAspectBoundException: Aspect at Aspect.aspectOf .. ------------- Here is a fix ... I give the decompiled &lt;clinit&gt; for Main.java and indicate with comments, look for ***LJH ****, what can be woven to fix it. Basically, the catch block for after throwing, when in &lt;clinit&gt;, should first check if the caught exception if a ExceptionInInitializerError, and if so just throw it. ----------- static { org.aspectj.runtime.reflect.Factory r1; java.lang.Throwable r2, r31; int $i0; r1 = new Factory("Main.java", Class.forName("Main")); ajc$tjp_0 = r1.makeSJP("field-set", r1.makeFieldSig("8-x-Main-int-"), 2); ajc$tjp_1 = r1.makeSJP("staticinitialization", r1.makeInitializerSig("8--Main-"), 2); ajc$tjp_10 = r1.makeSJP("preinitialization", r1.makeConstructorSig("1--Main----"), 5); ajc$tjp_2 = r1.makeSJP("field-set", r1.makeFieldSig("0-y-Main-int-"), 6); ajc$tjp_3 = r1.makeSJP("constructor-execution", r1.makeConstructorSig("1--Main----"), 6); ajc$tjp_4 = r1.makeSJP("constructor-call", r1.makeConstructorSig("1--Main----"), 10); ajc$tjp_5 = r1.makeSJP("field-set", r1.makeFieldSig("0-y-Main-int-"), 11); ajc$tjp_6 = r1.makeSJP("field-get", r1.makeFieldSig("19-out-java.lang.System-java.io.PrintStream-"), 12); ajc$tjp_7 = r1.makeSJP("method-call", r1.makeMethodSig("1-println-java.io.PrintStream-java.lang.String:-arg0:--void-"), 12); ajc$tjp_8 = r1.makeSJP("method-execution", r1.makeMethodSig("9-main-Main-[Ljava.lang.String;:-args:--void-"), 10); ajc$tjp_9 = r1.makeSJP("initialization", r1.makeConstructorSig("1--Main----"), 6); try { Aspect.aspectOf().ajc$before$Aspect$1$36f01b1c(ajc$tjp_1); $i0 = 13; try { Aspect.aspectOf().ajc$before$Aspect$1$36f01b1c(ajc$tjp_0); x = $i0; } catch (Throwable $r30) { /*** LJH insert here ******/ if ($r30 instanceof ExceptionInIntializerError) //*** throw($r30); //*** /*************/ r31 = $r30; Aspect.aspectOf().ajc$after$Aspect$2$36f01b1c(ajc$tjp_0); throw r31; } Aspect.aspectOf().ajc$after$Aspect$2$36f01b1c(ajc$tjp_0); } catch (Throwable $r36) { /*** LJH insert here ******/ if ($r36 instanceof ExceptionInIntializerError) //*** throw($r36); //*** /*************/ r2 = $r36; Aspect.aspectOf().ajc$after$Aspect$2$36f01b1c(ajc$tjp_1); throw r2; } Aspect.aspectOf().ajc$after$Aspect$2$36f01b1c(ajc$tjp_1); }
proper handling of inside &lt;clinit&gt; in presence of after throwing advice When a &lt;clinit&gt; of a class contains after throwing advice that may catch errors due to an embedded advice that fails, the error does not get properly reported. For the example below: .... when compiled with ajc, and then run, the following exception is given, Exception in thread "main" at  when really one wants the following: Exception in thread "main" at  ... Caused by: : .. ------------- Here is a fix ... I give the decompiled &lt;clinit&gt; for  and indicate with comments, look for ***LJH ****, what can be woven to fix it. Basically, the catch block for after throwing, when in &lt;clinit&gt;, should first check if the caught exception if a , and if so just throw it.
******
tests/bugs/pr62642.C(),False,new_method|test_method
tests/bugs/pr62642.main(String),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.test043_pr62642_ExceptionInInitializerError(),False,new_method|test_method
weaver/src/org/aspectj/weaver/bcel/BcelShadow.weaveAfterThrowing(BcelAdvice, TypeX),True
#####
AspectJ
70619
75852d7b1915cddfd4ba3dea272324617abdaa60
"compiler aborts with ""conflicting dominates orders"" with circular declare precedences" The following program causes ajc 1.2 to abort: public class Conflict { public static void main(String[] args) { } } aspect Conflict1 { declare precedence: Conflict1, Conflict2; before(): execution(* *(..)) { } } aspect Conflict2 { declare precedence: Conflict2, Conflict1; after(): execution(* *(..)) { } }
"compiler aborts with ""conflicting dominates orders"" with circular declare precedences" The following program causes ajc 1.2 to abort: 
******
tests/bugs/bug70619/Conflict.main(String[]),False,new_method|test_method
tests/bugs/bug70619/Precedence.main(String[]),False,new_method|test_method
weaver/src/org/aspectj/weaver/World.compareByDominates(ResolvedTypeX, ResolvedTypeX),True
#####
AspectJ
72150
b5e6307a63b0513cb058e8d6e56ff87287bdfa15
AJC possible bug with static nested classes AJC fails to find nested static classes during binary-weaving analysis if the classes have been previously compiled with J2SE5.0 javac compiler with options: -source 1.5/ - target 1.5 Note, that the nested static classes are not necessarily subject to bytecode weaving - AJC merely fails to detect them in the JARS for its analysis. This issue disappears when the .java sources are pre-compiled with - source/target 1.4, regardless if the javac compiler comes from the J2SE1.4 or J2SE5.0 distribution. This issue is distinct form Bug #71548, since no 5.0 source code processing is required from AJC ever. Thanks, Hristo
AJC possible bug with static nested classes AJC fails to find nested static classes during binary-weaving analysis if the classes have been previously compiled with J2SE5.0 javac compiler with options: -source 1.5/ - target 1.5 Note, that the nested static classes are not necessarily subject to bytecode weaving - AJC merely fails to detect them in the JARS for its analysis. This issue disappears when the .java sources are pre-compiled with - source/target 1.4, regardless if the javac compiler comes from the J2SE1.4 or J2SE5.0 distribution. This issue is distinct form Bug #71548, since no 5.0 source code processing is required from AJC ever. Thanks, Hristo
******
tests/bugs/java5/arrayCloning/A,False,test
tests/bugs/java5/arrayCloning/C.main(String[]),False,new_method|test_method
tests/bugs/java5/arrayCloning/C.D(int),False,new_method|test_method
weaver/src/org/aspectj/weaver/TypeX.nameToSignature(String),True
tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.test051_arrayCloningInJava5(),False,new_method|test_method
#####
AspectJ
74952
a303a09bbdbee8ce39e2ba00a3a33e54df92c24f
"before,after !(cflow(within(Trace*))) prints nothing" Reference: "cflow(within(C)) vs (within(C)||cflowbelow(within(C)) in aspectj-users mailing list. The aspect TraceClass below doesn't print any message when the pointcut is defined to "!cflow(within(Trace*))". The other defintion "!(within(Trace*) || cflowbelow(within(Trace*)))" works fine. Wes Isberg in his reply explained that cflow should never be used alone but he thought "there is a bug or two in here" class SomeClass { static public void main (String [] args) { } } // SomeClass aspect TraceClass { // members static private int level = 0; static private void offset() { int i; for (i = 0; i &lt; level; ++i) { System.out.print(" "); } } // offset pointcut pc() : !cflow(within(Trace*)) // !(within(Trace*) || cflowbelow(within(Trace*))) ; before () : pc() { offset(); System.out.println("-&gt; " + thisJoinPoint); ++level; } after () : pc() { --level; offset(); System.out.println("&lt;- " + thisJoinPoint); } } // TraceClass In order to try to figure out what is happening within TraceClass, I added a second aspect, TraceTrace, just to trace TraceClass. aspect TraceTrace { // members static private int level = 0; static private void offset() { int i; for (i = 0; i &lt; level; ++i) { System.out.print(" "); } } // offset pointcut pc() : within(TraceClass); before () : pc() { offset(); System.out.println("=&gt; " + thisJoinPoint); ++level; } after () : pc() { --level; offset(); System.out.println("&lt;= " + thisJoinPoint); } } // TraceTrace Here is what TraceTrace prints when TraceClass uses "!cflow(within(Trace*))" =&gt; staticinitialization(TraceClass.&lt;clinit&gt;) =&gt; set(int TraceClass.level) &lt;= set(int TraceClass.level) =&gt; preinitialization(TraceClass()) =&gt; initialization(TraceClass()) =&gt; execution(TraceClass()) &lt;= execution(TraceClass()) &lt;= initialization(TraceClass()) &lt;= staticinitialization(TraceClass.&lt;clinit&gt;) The after advice is not executed for preinitialization.
"before,after prints nothing" Reference: " in aspectj-users mailing list. The aspect below doesn't print any message when the pointcut is defined to "". The other defintion "" works fine. Wes Isberg in his reply explained that cflow should never be used alone but he thought "there is a bug or two in here" // In order to try to figure out what is happening within , I added a second aspect, , just to trace // Here is what prints when uses The after advice is not executed for preinitialization.
******
tests/bugs/WhatsGoingOn.offset(),False,new_method|test_method
tests/bugs/WhatsGoingOn.pc(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.countLines(String s),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.test065(),False,new_method|test_method
weaver/src/org/aspectj/weaver/bcel/BcelShadow.prepareForMungers(),True
weaver/src/org/aspectj/weaver/bcel/BcelShadow.weaveAfterReturning(BcelAdvice),True
weaver/src/org/aspectj/weaver/bcel/BcelShadow.weaveCflowEntry(final BcelAdvice, Member),True
#####
AspectJ
77799
aab9c2c57db1c014e03720676d7e3cac14a761aa
NullPointerException in StructureSearchManager Calling Ajde.getDefault().getStructureSearchManager().findMatches(...) for an AspectJ project that has not been built results in a NullPointerException in StructureSearchManager.findMatchesHelper(...) (line 58) Simple patch is attached.
in Calling for an AspectJ project that has not been built results in a in (line 58) Simple patch is attached.
******
ajde/src/org/aspectj/ajde/ui/StructureSearchManager.findMatchesHelper(IProgramElement, String, IProgramElement.Kind, List),True
#####
AspectJ
77163
edd6539e53d96e60f257952e582783c7d8aac25c
Load time weaver default verbose setting The default setting for the load time weaver is (as of 1.2.1rc1) to produce weaving messages rather than ignore them. I think the default should be changed to ignore them. Also, I cannot override the default setting with -Daj.weaver.versose="False". This is the implied syntax from docs/examples/build.xml. If this has changed then build.xml should be updated. Otherwise, the weaver should be fixed to use it!
Load time weaver default verbose setting The default setting for the load time weaver is (as of 1.2.1rc1) to produce weaving messages rather than ignore them. I think the default should be changed to ignore them. Also, I cannot override the default setting with ". This is the implied syntax from If this has changed then should be updated. Otherwise, the weaver should be fixed to use it!
******
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.getFullClassPath(ClassLoader),True
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.init(List, List),True
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.addURL(URL),True
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.weaveClass(String, byte[]),True
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.shouldWeave(String),True
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.registerAspectLibraries(List),True
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.addAspectLibrary(File),True
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.addAspectLibrary(String),False,new_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.info(String),False,new_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.warn(String),False,new_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.error(String),False,new_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.WeavingAdaptorMessageHandler(PrintWriter),False,new_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.handleMessage(IMessage),True
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.isIgnoring (Kind),False,new_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.ignore(IMessage.Kind),False,new_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.isIgnoring(Kind),True
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.dontIgnore(IMessage.Kind),False,new_method
weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.WeavingURLClassLoaderTest(String),False,test_method
weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.testLoadClass(),False,new_method|test_method
weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.testLoadWovenClass(),False,new_method|test_method
weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.testWeaveWovenClass(),False,new_method|test_method
weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.testWeaveAdvice(),False,test_method
weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.testWeaveAdviceWithVerbose(),False,new_method|test_method
weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.testWeaveAdviceWithWeaveInfo(),False,new_method|test_method
weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.testWeaveDeclareWarningAdvice(),False,test_method
weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.testWeaveDeclareErrorAdvice(),False,test_method
weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.testWeaveAroundClosure(),False,test_method
weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.testJunkAspectJar(),False,new_method|test_method
testIncompletePath(),False,test_method
testPackage(),False,test_method
setSystemProperty(String, String),False,new_method|test_method
copyProperty(String, Properties, Properties),False,new_method|test_method
setUp(),False,new_method|test_method
tearDown(),False,new_method|test_method
#####
AspectJ
80249
9052d5d86cfcdeb9a64ed903beea53d077f0de08
Order of types passed to compiler determines weaving behavior Currently, the order in which you specify types when passing them to the compiler can affect how they are woven: For example, if we have class A and class B extends A - Also, an aspect that 'declare parents: A+ implements Serializable' then depending on whether we see A first, we may or may not make B serializable. The fix is that when we weave a type, we first weave its supertype then its superinterfaces (if they were also passed to the compiler). The problematic construct is declare parents - so we only process the types in a special order if there are declare parents around. Also, because we can't currently do decp when binary weaving, the order processing logic is only being put into the source weaving pipeline
Order of types passed to compiler determines weaving behavior Currently, the order in which you specify types when passing them to the compiler can affect how they are woven: For example, if we have - Also, an aspect that 'declare parents: A+ implements Serializable' then depending on whether we see A first, we may or may not make B serializable. The fix is that when we weave a type, we first weave its supertype then its superinterfaces (if they were also passed to the compiler). The problematic construct is declare parents - so we only process the types in a special order if there are declare parents around. Also, because we can't currently do decp when binary weaving, the order processing logic is only being put into the source weaving pipeline
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.completeTypeBindings(),True
weaveIntertypes(List,SourceTypeBinding,Collection,Collection),False,new_method
tests/decp/B.main(String[]),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.test(),False,test_method
tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.test_typeProcessingOrderWhenDeclareParents(),False,new_method|test_method
#####
AspectJ
80916
427c0d3dfdcc6a74c7e0bc6fcf1f55206ee04a8e
"In some cases the structure model doesn't contain the ""matches declare"" relationship" With a project containing one class and one aspect: public class HelloClass { public static void main(String[] args) { new HelloClass().sayHello(); } public void sayHello() { System.out.println("Hello"); } } public aspect A1 { pointcut test() : get(* System.out); declare warning : test() &amp;&amp; !within(A1) : "test warning"; pointcut anotherTest() : execution(void HelloClass.sayHello(..)); after() returning : anotherTest() { System.out.println("returning...."); } } The following is returned from the structure model: asmRelMap entry: HelloClass.sayHello(), relationship: advised by, target: A1.afterReturning(): anotherTest.. asmRelMap entry: A1.afterReturning(): anotherTest.., relationship: uses pointcut, target: A1.anotherTest() asmRelMap entry: A1.afterReturning(): anotherTest.., relationship: advises, target: HelloClass.sayHello() asmRelMap entry: HelloClass.sayHello(), relationship: advised by, target: A1.afterReturning(): anotherTest.. asmRelMap entry: A1.anotherTest(), relationship: pointcut used by, target: A1.afterReturning(): anotherTest.. asmRelMap entry: A1.declare warning: "test warning", relationship: matched by, target: HelloClass.sayHello() In other words, the model is saying that there are two entries the same: asmRelMap entry: HelloClass.sayHello(), relationship: advised by, target: A1.afterReturning(): anotherTest.. whereas one of these should be the "matches declare" relationship relating to the declare warning. Changing the aspect to be: public aspect A1 { pointcut test() : get(* System.out); declare warning : test() &amp;&amp; !within(A1) : "test warning"; pointcut anotherTest() : execution(void HelloClass.sayHello(..)); after() returning : anotherTest() { System.out.println("returning...."); } after() returning : test() { System.out.println("returning again!"); } } means that the IRelationshipMap does now contain the "matches declare" relationship. This is all with AspectJ 5 M1.
"In some cases the structure model doesn't contain the ""matches declare"" relationship" With a project containing one class and one aspect: The following is returned from the structure model: asmRelMap entry: H, relationship: advised by, target:  relationship: advised by, target: : .  entry: warning: "test warning", relationship: matched by, target: In other words, the model is saying that there are two entries the same: asmRelMap entry: , relationship: advised by, target: : anotherTest.. whereas one of these should be the "matches declare" relationship relating to the declare warning. Changing the aspect to be: means that the does now contain the "matches declare" relationship. This is all with AspectJ 5 M1.
******
weaver/src/org/aspectj/weaver/AsmRelationshipProvider.checkerMunger(IHierarchy, Shadow, Checker),True
#####
AspectJ
76798
6aa75169a769a19b3f7f26acc03a5ad81f092bb0
Add versions to woven class files - enabling better backwards compatibility. We don't currently include a version in the class files that come out of the weaver. This can cause problems. For example, if we add a new attribute to a class file in a future version of AspectJ, then that attribute will cause older versions of AspectJ to blow up if they encounter it. If we include a version in the class file we can rev the version number when we add attributes (or change the class file form in another way), and by checking that version number in the weaver we can better determine whether we should fail if we encounter a new attribute (or other change), or if it is safe to continue processing. I will add a new WeaverVersion attribute that includes 2 shorts. Major and Minor. Encountering a major version in a class file that is greater than the version a particular weaver is designed to understand will cause compilation to fail. Encountering a minor version in a class file that is greater than the minor version a particular weaver is designed to understand will not cause compilation to fail - we will assume it is safe to continue.
Add versions to woven class files - enabling better backwards compatibility. We don't currently include a version in the class files that come out of the weaver. This can cause problems. For example, if we add a new attribute to a class file in a future version of AspectJ, then that attribute will cause older versions of AspectJ to blow up if they encounter it. If we include a version in the class file we can rev the version number when we add attributes (or change the class file form in another way), and by checking that version number in the weaver we can better determine whether we should fail if we encounter a new attribute (or other change), or if it is safe to continue processing. I will add a attribute that includes 2 shorts. Major and Minor. Encountering a major version in a class file that is greater than the version a particular weaver is designed to understand will cause compilation to fail. Encountering a minor version in a class file that is greater than the minor version a particular weaver is designed to understand will not cause compilation to fail - we will assume it is safe to continue.
******
weaver/src/org/aspectj/weaver/AjAttribute.read(String, byte[], ISourceContext),True
weaver/src/org/aspectj/weaver/AjAttribute.read(String, byte[], ISourceContext,IMessageHandler),False,new_method
weaver/src/org/aspectj/weaver/AjAttribute.getNameString(),False,new_method
weaver/src/org/aspectj/weaver/AjAttribute.WeaverVersionInfo(),False,new_method
weaver/src/org/aspectj/weaver/AjAttribute.WeaverVersionInfo(short, short),False,new_method
weaver/src/org/aspectj/weaver/AjAttribute.write(DataOutputStream),False,new_method
weaver/src/org/aspectj/weaver/AjAttribute.read(DataInputStream),False,new_method
weaver/src/org/aspectj/weaver/AjAttribute.getMajorVersion(),False,new_method
weaver/src/org/aspectj/weaver/AjAttribute.getMinorVersion(),False,new_method
weaver/src/org/aspectj/weaver/AjAttribute.getCurrentWeaverMajorVersion(),False,new_method
weaver/src/org/aspectj/weaver/AjAttribute.getCurrentWeaverMinorVersion(),False,new_method
weaver/src/org/aspectj/weaver/AjAttribute.toString(),False,new_method
weaver/src/org/aspectj/weaver/AjAttribute.toCurrentVersionString(),False,new_method
weaver/src/org/aspectj/weaver/bcel/BcelAttributes.readAjAttributes(Attribute[], ISourceContext),True
weaver/src/org/aspectj/weaver/bcel/BcelAttributes.readAjAttributes(Attribute[], ISourceContext,IMessageHandler),False,new_method
weaver/src/org/aspectj/weaver/bcel/BcelField.unpackAttributes(World),True
weaver/src/org/aspectj/weaver/bcel/BcelMethod.unpackAjAttributes(World),True
weaver/src/org/aspectj/weaver/bcel/BcelObjectType.unpackAspectAttributes(),True
weaver/src/org/aspectj/weaver/bcel/BcelObjectType.getWeaverVersionAttribute(),True
weaver/src/org/aspectj/weaver/bcel/LazyClassGen.writeBack(BcelWorld),True
weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.printAspectAttributes(PrintStream),True
#####
AspectJ
82062
98976598593e8a1f89e9628e8fc11c7822b8e3d4
WeaveMessage should provide more information It would be wonderful if the WeaveMessage object would provide two additional things: - the affected class name - the aspect name I could use this to determine which aspect is woven into which class during load-time weaving (need this for dependency management).
should provide more information It would be wonderful if the object would provide two additional things: - the affected class name - the aspect name I could use this to determine which aspect is woven into which class during load-time weaving (need this for dependency management).
******
weaver/src/org/aspectj/weaver/Advice,True
bridge/src/org/aspectj/bridge/WeaveMessage.WeaveMessage(String),True
bridge/src/org/aspectj/bridge/WeaveMessage.WeaveMessage(String, String, String),False,new_method
bridge/src/org/aspectj/bridge/WeaveMessage.constructWeavingMessage(WeaveMessageKind, String[]),False,new_method
bridge/src/org/aspectj/bridge/WeaveMessage.constructWeavingMessage(WeaveMessageKind, String[]),True
bridge/src/org/aspectj/bridge/WeaveMessage.getAspectname(),False,new_method
bridge/src/org/aspectj/bridge/WeaveMessage.getAffectedtypename(),False,new_method
weaver/src/org/aspectj/weaver/Shadow.reportWeavingMessage(ShadowMunger),True
weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.munge(BcelClassWeaver),True
weaver/src/org/aspectj/weaver/bcel/BcelWorld.makeBcelObjectType(ResolvedTypeX.Name, JavaClass, boolean),False,access-level-changed
#####
AspectJ
81863
8a8930fd9808b03e3c117086d7ba0eaa654a2438
Annotation matching using within() PCD doesn't appear to be working. From discussion on aspectj list: Hi, Well, having just done some testing, I think this even simpler case shows within() is not behaving correctly for annotations: @Entity public class myClass1 {...} public class myClass2 {...} public aspect myAspect { before():call(* *(..)) &amp;&amp; within(@Entity *) { } } The pointcut matches all the method calls in myClass1 and myClass2 (effectively it is parsing but then ignoring the annotation specified in the within()). So, what you want to do is valid but AspectJ is misbehaving - you get a stack overflow because the perthis() clause is also matching on your aspect type when obviously that doesnt have the annotation and shouldnt be matched. Andy. --- Andy Clement AspectJ Development Rifflard Micka?l &lt;Mickael.Rifflard@atosorigin.com&gt; Sent by: aspectj-users-admin@eclipse.org 22/12/2004 16:56 Please respond to aspectj-users@eclipse.org To &lt;aspectj-users@eclipse.org&gt; cc Subject [aspectj-users] Aspect instance on JDK 1.5 annotation Hi all, I'm currently trying to get an aspect instance for an object instance with specific JDK 1.5 annotation. Exemple : Create an aspect instance for all object like that : @Entity public class myClass { ... } I try public aspect myAspect perthis(within(@Entity *)) {...} but this aspect execution lead to a java.lang.StackOverflowError exception. Is it possible ? Thanks. Micka?l _______________________________________________ aspectj-users mailing list aspectj-users@eclipse.org http://dev.eclipse.org/mailman/listinfo/aspectj-users
Annotation matching using PCD doesn't appear to be working. From discussion on aspectj list: Hi, Well, having just done some testing, I think this even simpler case shows is not behaving correctly for annotations: The pointcut matches all the method calls in and (effectively it is parsing but then ignoring the annotation specified in the). So, what you want to do is valid but AspectJ is misbehaving - you get a stack overflow because the clause is also matching on your aspect type when obviously that doesnt have the annotation and shouldnt be matched. Andy. --- Andy Clement AspectJ Development Rifflard Micka?l &lt;Mickael.Rifflard@atosorigin.com&gt; Sent by: aspectj-users-admin@eclipse.org 22/12/2004 16:56 Please respond to aspectj-users@eclipse.org To &lt;aspectj-users@eclipse.org&gt; cc Subject [aspectj-users] Aspect instance on JDK 1.5 annotation Hi all, I'm currently trying to get an aspect instance for an object instance with specific JDK 1.5 annotation. Exemple : Create an aspect instance for all object like that : but this aspect execution lead to a exception. Is it possible ? Thanks. Micka?l 
******
tests/src/org/aspectj/systemtest/ajc150/AnnotationPointcutsTests.test003_Within_Code(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/AnnotationPointcutsTests.test004_Within(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/AnnotationRuntimeTests.test007_Within_Code(),False,test_method
weaver/src/org/aspectj/weaver/patterns/AnnotationTypePattern.FuzzyBoolean fastMatches(AnnotatedElement),False,new_method
weaver/src/org/aspectj/weaver/patterns/ExactAnnotationTypePattern.resolve(World),True
weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.matchesExactly(ResolvedTypeX),True
weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.matchesInstanceof(ResolvedTypeX),True
weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.matchInternal(Shadow),True
weaver/src/org/aspectj/weaver/patterns/TypePattern.matches(ResolvedTypeX, MatchKind),True
weaver/src/org/aspectj/weaver/patterns/TypePattern.resolve(World),False,new_method
weaver/src/org/aspectj/weaver/patterns/TypePattern.postRead(ResolvedTypeX),False,formatting
weaver/src/org/aspectj/weaver/patterns/WildTypePattern.matchesExactly(ResolvedTypeX),True
weaver/src/org/aspectj/weaver/patterns/WithinPointcut.isWithinType(ResolvedTypeX),True
weaver/src/org/aspectj/weaver/patterns/WithinPointcut.fastMatch(FastMatchInfo),True
#####
AspectJ
82218
f70b383d6292995c1e0521e7312e827022fe8fc9
fails to doc spacewar using AJDT 1.2.0M2 Using AJDT 1.2.0M2 {with Java 5 JRE on XP SP2}, install Spacewar example and generate to Spacewar/docs. Result: output has no cross-references (and displays special AJDT tags), and stderr lists this exception: java.lang.StringIndexOutOfBoundsException: String index out of range: -1 at java.lang.AbstractStringBuilder.insert(AbstractStringBuilder.java:980) at java.lang.StringBuffer.insert(StringBuffer.java:447) at org.aspectj.tools.ajdoc.HtmlDecorator.insertDeclarationsDetails(HtmlDecorator.java:350) at org.aspectj.tools.ajdoc.HtmlDecorator.addAspectDocumentation(HtmlDecorator.java:234) at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFile(HtmlDecorator.java:188) at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromDecl(HtmlDecorator.java:116) at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromDecls(HtmlDecorator.java:54) at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromInputFiles(HtmlDecorator.java:43) at org.aspectj.tools.ajdoc.Main.main(Main.java:210)
fails to doc spacewar using AJDT 1.2.0M2 Using AJDT 1.2.0M2 {with Java 5 JRE on XP SP2}, install Spacewar example and generate to . Result: output has no cross-references (and displays special AJDT tags), and stderr lists this exception
******
ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.findSummaryIndex(StringBuffer, int),True
ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.findDetailsIndex(StringBuffer fileBuffer, int),True
ajdoc/src/org/aspectj/tools/ajdoc/Util.isExecutingOnJava5(),False,new_method
ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.testCoveragePublicMode(),True
ajdoc/testsrc/org/aspectj/tools/ajdoc/JDKVersionTest.testIsUsing1point4(),False,new_method|test_method
ajdoc/testsrc/org/aspectj/tools/ajdoc/JDKVersionTest.testIsUsing1point5(),False,new_method|test_method
#####
AspectJ
83303
5d281fd8e98c5c2bec4365d3fc340e2d5f04becc
"complier error when mixing inheritance, overriding and polymorphism" Given this scenario: - class A define method m1 (with proteceted visibility) - class B extends class A and implements interface I and override method m1 (but with public visibility) - interface I define method m1 (with public visibility) The code is correct and compile using java 1.4 Let's modify the scenario: move the method B.m1 into a method introduction on aspect C, such that - class B extends class A - apsect C intosuces method m1 into B (with public visibility) and makes B implemts I (declare parents) - A and I as before The compiler reports this error: B.java:1 [error] The inherited method A.m1() cannot hide the public abstract method in I class B extends A {
"complier error when mixing inheritance, overriding and polymorphism" Given this scenario: - class A define method m1 (with proteceted visibility) - class B extends class A and implements interface I and override method m1 (but with public visibility) - interface I define method m1 (with public visibility) The code is correct and compile using java 1.4 Let's modify the scenario: move the method B.m1 into a method introduction on aspect C, such that - class B extends class A - apsect C intosuces method m1 into B (with public visibility) and makes B implemts I (declare parents) - A and I as before The compiler reports this error::1 [error] The inherited method cannot hide the public abstract method in
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.inheritedMethodReducesVisibility(SourceTypeBinding, MethodBinding, MethodBinding[]),False,new_method
tests/bugs150/PR83303.m1(),False,new_method|test_method
tests/bugs150/PR83303.main(String),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/Ajc150TestsNoHarness.testCanOverrideProtectedMethodsViaITDandDecp_pr83303(),False,new_method|test_method
#####
AspectJ
83563
1b01255892ef222c14fea25b5db77208f1f6bb13
pertypewithin() handing of inner classes It seems that pertypewithin() aspect association does not handle nested classes correctly. Here is a test class that exhibits the problem: package test; public class Test { public static void main(String[] args) { new NestedTest().run(); } static class NestedTest implements Runnable { public void run() { System.out.println("Running..."); } } } aspect PertypewithinTest pertypewithin(Test) { before() : execution(* *.*(..)) { System.out.println(thisJoinPointStaticPart); } } &gt; ajc -version AspectJ Compiler DEVELOPMENT built on Monday Jan 24, 2005 at 17:07:00 GMT &gt; ajc test\Test.java &gt; java test.Test execution(void test.Test.main(String[])) execution(void test.Test.bar()) Exception in thread "main" java.lang.NoSuchMethodError: test.Test$1.ajc$test_Per typewithinTest$localAspectOf()Ltest/PertypewithinTest; at test.Test$1.run(Test.java) at test.Test.bar(Test.java:9) at test.Test.main(Test.java:13) The same problem is seen for anonymous inner classes, as well: package test; public class Test { public void bar() { new Runnable() { public void run() { System.out.println("Running..."); } }.run(); } public static void main(String[] args) { new Test().bar(); } } aspect PertypewithinTest pertypewithin(Test) { before() : execution(* *.*(..)) { System.out.println(thisJoinPoint); } } &gt; ajc test\Test.java &gt; java test.Test execution(void test.Test.main(String[])) execution(void test.Test.bar()) Exception in thread "main" java.lang.NoSuchMethodError: test.Test$1.ajc$test_Per typewithinTest$localAspectOf()Ltest/PertypewithinTest; at test.Test$1.run(Test.java) at test.Test.bar(Test.java:9) at test.Test.main(Test.java:13)
handing of inner classes It seems that aspect association does not handle nested classes correctly. Here is a test class that exhibits the problem: package test; &gt; ajc -version AspectJ Compiler DEVELOPMENT built on Monday Jan 24, 2005 at 17:07:00 GMT &gt; ajc test\Test.java &gt; java : The same problem is seen for anonymous inner classes, as well: package test;
******
tests/bugs150/PR83563_1.main(String[]),False,new_method|test_method
tests/bugs150/PR83563_1.run(),False,new_method|test_method
tests/bugs150/PR83563_1.pertypewithin(PR83563_1),False,new_method|test_method
tests/bugs150/PR83563_2.bar(),False,new_method|test_method
tests/bugs150/PR83563_2.main(String[]),False,new_method|test_method
tests/bugs150/PR83563_2.pertypewithin(PR83563_2),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/Ajc150TestsNoHarness.testPerTypeWithinMissesNamedInnerTypes(),False,test_method
tests/src/org/aspectj/systemtest/ajc150/Ajc150TestsNoHarness.testPerTypeWithinMissesAnonymousInnerTypes(),False,test_method
weaver/src/org/aspectj/weaver/PerTypeWithinTargetTypeMunger.matches(ResolvedTypeX, ResolvedTypeX),True
weaver/src/org/aspectj/weaver/patterns/PerTypeWithin.isWithinType(ResolvedTypeX),False,new_method
weaver/src/org/aspectj/weaver/patterns/PerTypeWithin.concretize(ResolvedTypeX),True
#####
AspectJ
76055
b0f270ee1090daf7b5aec3b534b98d28955f77bd
Some Pointcut PatternNodes are missing getters to traverse syntax tree In order to find out which other pointcuts are referenced by a pointcut definition i need to access the private members of the CflowPointcut, IfPointcut and NotPointcut PatternNodes found in the weaver module. Unlike the OrPointcut and AndPointcut classes, they are missing the appropriate getter methods.
Some are missing getters to traverse syntax tree In order to find out which other pointcuts are referenced by a pointcut definition i need to access the private members of the , and found in the weaver module. Unlike the and classes, they are missing the appropriate getter methods.
******
weaver/src/org/aspectj/weaver/patterns/CflowPointcut.getEntry(),False,new_method
weaver/src/org/aspectj/weaver/patterns/IfPointcut.getResidueSource(),False, new_method
#####
AspectJ
82134
797b6a6afb75b14dc530bc0831566e110da3ae91
AspectJ 5 M2 should implement backwards compatibility for binary aspect form Hi Adrian, thanks for the detailed explanation of the compatibility questions. That explains the problem I observed. &gt; * An AspectJ program should always be run with the aspectjrt.jar runtime &gt; library that accompanies the distribution containing the compiler/weaver &gt; used to build it. Interesting point. Which one? The one that is used to compile it or the one that is used to weave it? &gt; However, instead of some IOException, what you should see is a nice &gt; message saying that the aspect was produced by a more recent version of &gt; AspectJ and cannot be read. Likewise, if you load a pre-aspectj 5 aspect &gt; into the AspectJ 5 weaver right now, you'll also see an IOException &gt; (odds-on). In M2 we'll detect that and use the back-level loaders to read &gt; it in. Okay. Is there a bug to track this? I really would like to update the weaver of my weaving runtime but only if it allows to load/weave asepects that are compiled with any of the AJDT versions that are out right now (AJDT 1.1.x and AJDT 1.2.0Mx).
AspectJ 5 M2 should implement backwards compatibility for binary aspect form Hi Adrian, thanks for the detailed explanation of the compatibility questions. That explains the problem I observed. &gt; * An AspectJ program should always be run with the runtime &gt; library that accompanies the distribution containing the compiler/weaver &gt; used to build it. Interesting point. Which one? The one that is used to compile it or the one that is used to weave it? &gt; However, instead of some, what you should see is a nice &gt; message saying that the aspect was produced by a more recent version of &gt; AspectJ and cannot be read. Likewise, if you load a pre-aspectj 5 aspect &gt; into the AspectJ 5 weaver right now, you'll also see an &gt; (odds-on). In M2 we'll detect that and use the back-level loaders to read &gt; it in. Okay. Is there a bug to track this? I really would like to update the weaver of my weaving runtime but only if it allows to load/weave asepects that are compiled with any of the AJDT versions that are out right now (AJDT 1.1.x and AJDT 1.2.0Mx).
******
tests/src/org/aspectj/systemtest/ajc150/AllTestsJava5_binaryWeaving.suite(),False,test_method
tests/src/org/aspectj/systemtest/ajc150/MigrationTests.testMigrationFrom121_pointcutsAndAdvice(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/MigrationTests.testMigrationFrom120_pointcutsAndAdvice(),False,new_method|test_method
weaver/src/org/aspectj/weaver/AdviceKind.read(DataInputStream),True
weaver/src/org/aspectj/weaver/AdviceKind.read(VersionedDataInputStream),False,new_method
weaver/src/org/aspectj/weaver/AjAttribute.read(String, byte[], ISourceContext, IMessageHandler),True
weaver/src/org/aspectj/weaver/AjAttribute.read(AjAttribute.WeaverVersionInfo, String, byte[], ISourceContext, IMessageHandler),False,new_method
weaver/src/org/aspectj/weaver/AjAttribute.read(AjAttribute.read(DataInputStream),True
weaver/src/org/aspectj/weaver/AjAttribute.read(AjAttribute.read(VersionedDataInputStream),False,new_method
weaver/src/org/aspectj/weaver/ResolvedPointcutDefinition.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/ResolvedPointcutDefinition.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/VersionedDataInputStream.VersionedDataInputStream(InputStream),False,new_method
weaver/src/org/aspectj/weaver/VersionedDataInputStream.getMajorVersion(),False,new_method
weaver/src/org/aspectj/weaver/VersionedDataInputStream.getMinorVersion(),False,new_method
weaver/src/org/aspectj/weaver/VersionedDataInputStream.setVersion(WeaverVersionInfo),False,new_method
weaver/src/org/aspectj/weaver/WeaverStateInfo.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/WeaverStateInfo.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/bcel/BcelAttributes.readAjAttributes(Attribute[], ISourceContext, IMessageHandler),True
weaver/src/org/aspectj/weaver/bcel/BcelAttributes.readAjAttributes(String, Attribute[], ISourceContext, IMessageHandler),False,new_method
weaver/src/org/aspectj/weaver/bcel/BcelField.unpackAttributes(World),True
weaver/src/org/aspectj/weaver/bcel/BcelMethod.unpackAttributes(World),True
weaver/src/org/aspectj/weaver/bcel/BcelObjectType.unpackAspectAttributes(),True
weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.printAspectAttributes(PrintStream),True
weaver/src/org/aspectj/weaver/patterns/AndAnnotationTypePattern.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/AndAnnotationTypePattern.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/AndPointcut.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/AndPointcut.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/AndTypePattern.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/AndTypePattern.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/AnnotationPatternList.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/AnnotationPatternList.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/AnnotationPatternList.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/AnnotationTypePattern.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/AnnotationTypePattern.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/BindingAnnotationTypePattern.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/BindingAnnotationTypePattern.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/BindingTypePattern.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/BindingTypePattern.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/CflowPointcut.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/CflowPointcut.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/Declare.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/Declare.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/DeclareErrorOrWarning.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/DeclareErrorOrWarning.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/DeclareParents.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/DeclareParents.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/DeclareSoft.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/DeclareSoft.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/ExactAnnotationTypePattern.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/ExactAnnotationTypePattern.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.readTypePattern150(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.toString(),True
weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.readTypePatternOldStyle(DataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/IfPointcut.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/IfPointcut.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/KindedPointcut.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/KindedPointcut.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/ModifiersPattern.read(DataInputStream),True
weaver/src/org/aspectj/weaver/patterns/ModifiersPattern.read(VersionedDataInputStream),False,new_method
weaver/src/org/aspectj/weaver/patterns/NamePattern.read(DataInputStream),True
weaver/src/org/aspectj/weaver/patterns/NamePattern.read(VersionedDataInputStream),False,new_method
weaver/src/org/aspectj/weaver/patterns/NotAnnotationTypePattern.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/NotAnnotationTypePattern.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/NotPointcut.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/NotPointcut.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/NotTypePattern.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/NotTypePattern.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/OrAnnotationTypePattern.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/OrAnnotationTypePattern.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/OrPointcut.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/OrPointcut.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/OrTypePattern.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/OrTypePattern.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/PerCflow.readPerClause(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/PerCflow.readPerClause(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/PerClause.readPerClause(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/PerClause.readPerClause(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/PerClause.read(DataInputStream),True
weaver/src/org/aspectj/weaver/patterns/PerClause.read(VersionedDataInputStream),False,new_method
weaver/src/org/aspectj/weaver/patterns/PerFromSuper.readPerClause(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/PerFromSuper.readPerClause(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/PerObject.readPerClause(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/PerObject.readPerClause(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/PerSingleton.readPerClause(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/PerSingleton.readPerClause(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/Pointcut.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/Pointcut.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/SignaturePattern.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/SignaturePattern.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/ThisOrTargetAnnotationPointcut.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/ThisOrTargetAnnotationPointcut.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/ThrowsPattern.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/ThrowsPattern.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/TypePattern.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/ThrowsPattern.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/TypePatternList.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/TypePatternList.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/WildTypePattern.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/WildTypePattern.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/WildTypePattern.readTypePattern150(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/WildTypePattern.readTypePatternOldStyle(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/WithinAnnotationPointcut.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/WithinAnnotationPointcut.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/WithinCodeAnnotationPointcut.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/WithinCodeAnnotationPointcut.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/WithinPointcut.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/WithinPointcut.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.read(DataInputStream, ISourceContext),True
weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.read(VersionedDataInputStream, ISourceContext),False,new_method
weaver/testsrc/org/aspectj/weaver/bcel/PatternWeaveTestCase.checkSerialize(Pointcut),False,test_method
weaver/testsrc/org/aspectj/weaver/bcel/PointcutResidueTestCase.checkSerialize(Pointcut),False,test_method
weaver/testsrc/org/aspectj/weaver/patterns/AndOrNotTestCase.checkSerialization(String),False,test_method
weaver/testsrc/org/aspectj/weaver/patterns/DeclareErrorOrWarningTestCase.checkSerialization(Declare),False,test_method
weaver/testsrc/org/aspectj/weaver/patterns/ModifiersPatternTestCase.checkSerialization(String),False,test_method
weaver/testsrc/org/aspectj/weaver/patterns/NamePatternTestCase.checkSerialization(NamePattern),False,test_method
weaver/testsrc/org/aspectj/weaver/patterns/SignaturePatternTestCase.checkSerialization(SignaturePattern),False,test_method
weaver/testsrc/org/aspectj/weaver/patterns/TypePatternListTestCase.checkSerialization(String),False,test_method
weaver/testsrc/org/aspectj/weaver/patterns/TypePatternTestCase.checkSerialization(String),False,test_method
weaver/testsrc/org/aspectj/weaver/patterns/WithinTestCase.checkSerialization(Pointcut),False,test_method
#####
AspectJ
86789
f90186cb8eac1b4abae4c9b8fd74828b98f534ab
"annotations and ""circularity in declare precedence""" The following example declare precedence : (@PremiumPartner *), *; results in the error message circularity in declare precedence, ''*'' occurs more than once It is the same example (apart form the name) as in the developers notebook. (see also http://dev.eclipse.org/mhonarc/lists/aspectj-dev/msg01326.html)
"annotations and ""circularity in declare precedence""" The following example declare precedence : (@PremiumPartner *), *; results in the error message circularity in declare precedence, ''*'' occurs more than once It is the same example (apart form the name) as in the developers notebook. (see also http://dev.eclipse.org/mhonarc/lists/aspectj-dev/msg01326.html)
******
weaver/src/org/aspectj/weaver/patterns/WildTypePattern.matchesExactlyByName(String),True
weaver/src/org/aspectj/weaver/patterns/WildTypePattern.resolveBindings(IScope, Bindings, boolean, boolean),True
weaver/src/org/aspectj/weaver/patterns/WildTypePattern.isStar(),True
weaver/src/org/aspectj/weaver/patterns/WildTypePattern.isNamePatternStar(),False,new_method
#####
AspectJ
87376
85aa1520881e7271e658b9377dfd020fde28868c
NPE when unresolved type of a bound var in a pointcut expression (EclipseFactory.java:224) see attached mini-project to reproduce
NPE when unresolved type of a bound var in a pointcut expression see attached mini-project to reproduce
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.getPointcutDeclaration(ReferencePointcut, MethodDeclaration),True
tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.npeOnTypeNotFound(),False,new_method|test_method
tests/bugs150/pr87376/I,False,test
#####
AspectJ
88652
b5f4d09e4f4e45943c6c8b3dc8dca0c05b90f27c
an array type as the last parameter in a signature does not match on the varargs declared method I get this warning in my code, though I actually do not specify an array type. The signature I want to match is the following constructor signature: public Touple(Object formulaHandle, Object... propositions) {...} Touple implements IRelation The pointcut I use is the following: pointcut p(): call(Touple.new(..)); This should actually match the signature, shouldn't it? AspectJ however complains with this warning: an array type as the last parameter in a signature does not match on the varargs declared method: void ltlrv.Touple.&lt;init&gt;(java.lang.Object, java.lang.Object[]) [Xlint:cantMatchArrayTypeOnVarargs] Also, even if I *had* stated an array type, it should match even then IMHO, since arrays and varargs are actually the same in the Java implementation.
an array type as the last parameter in a signature does not match on the declared method I get this warning in my code, though I actually do not specify an array type. The signature I want to match is the following constructor signature:  This should actually match the signature, shouldn't it? AspectJ however complains with this warning: an array type as the last parameter in a signature does not match on the declared method: Also, even if I *had* stated an array type, it should match even then IMHO, since arrays and are actually the same in the Java implementation.
******
tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.testVarargsInConsBug(),False,new_method|test_method
weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.isArray(),False,new_method
weaver/src/org/aspectj/weaver/patterns/SignaturePattern.isNotMatchBecauseOfVarargsIssue(TypePatternList,int),True
weaver/src/org/aspectj/weaver/patterns/TypePattern.isArray(),False,new_method
weaver/src/org/aspectj/weaver/patterns/WildTypePattern.isArray(),False,new_method
#####
AspectJ
96371
f14646f57a93e7ec865416048c4491d9943064e5
Patch to support loading aop.xml properly AspectJ 5 load-time weaving in CVS HEAD isn't loading aop.xml files properly from a jar file without specifying the global -D flag. The following patch fixes the problem for me so I can load aop.xml files from jars on the classpath without a global flag: ClassLoaderWeavingAdaptor.java:109: - Enumeration xmls = loader.getResources("/META-INF/aop.xml"); + Enumeration xmls = loader.getResources("META-INF/aop.xml"); I.e., getResources doesn't work with a leading separator, at least not on the Sun VM or JRockIt on Windows. Writing a unit test for this would require significant changes to the loadtime module, so I wrote a standalone test of the API: public class TestApi extends TestCase { public void testLoadResource() throws Exception { URL urlList[] = { new URL ("file:testsrc/org/aspectj/weaver/loadtime/test/sample.jar") }; ClassLoader loader = new URLClassLoader(urlList); Enumeration xmls = loader.getResources("META-INF/aop.xml"); //this version fails: //Enumeration xmls = loader.getResources("/META-INF/aop.xml"); assertTrue(xmls.hasMoreElements()); } }
Patch to support properly AspectJ 5 load-time weaving in CVS HEAD isn't loading files properly from a jar file without specifying the global -D flag. The following patch fixes the problem for me so I can load files from jars on the classpath without a global flag: :109: - Enumeration ; + Enumeration ; I.e.,  doesn't work with a leading separator, at least not on the Sun VM or JRockIt on Windows. Writing a unit test for this would require significant changes to the loadtime module, so I wrote a standalone test of the API: 
******
loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.registerDefinitions(BcelWeaver, ClassLoader),True
loadtime5/java5-src/org/aspectj/weaver/loadtime/ClassPreProcessorAgentAdapter,True
tests/java5/ataspectj/ataspectj/SingletonAspectBindingsTest,False,test
#####
AspectJ
83565
5765d534a5437b624646ff20ca487346fa76a267
"BCException ""bad type name"" thrown when compiling" I just downloaded AJDT version 1.2.0.20050124144759 and I am running Eclipse 3.1M4. I tried to use aspectJ on an existing Java 5 project. There are no aspects in it yet, just straight Java 5. The project runs just fine as a standard Java project. When add the AspectJ nature and I try to compile the project, no class files are generated and I get this error generated on a type that is parameterized: Internal compiler error org.aspectj.weaver.BCException: Bad type name: at org.aspectj.weaver.TypeX.nameToSignature(TypeX.java:634) at org.aspectj.weaver.TypeX.forName(TypeX.java:87) at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBinding(EclipseFactory.java:155) at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBindings(EclipseFactory.java:163) at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeResolvedMember(EclipseFactory.java:229) at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeResolvedMember(EclipseFactory.java:224) at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.visit(AsmHierarchyBuilder.java:675) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.traverse(ConstructorDeclaration.java:447) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1133) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:314) at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.internalBuild(AsmHierarchyBuilder.java:171) at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.buildStructureForCompilationUnit(AsmHierarchyBuilder.java:111) at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.finishedCompilationUnit(EclipseFactory.java:354) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterProcessing(AjCompilerAdapter.java:138) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:373) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:682) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:168) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:102) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:165) The source code of the file that generates this error is: package mj.compiler.ast; import java.util.Vector; import mj.compiler.Driver; import mj.compiler.Visitor; public class Sequence&lt;T extends AST&gt; extends AST { private Vector&lt;T&gt; elements = new Vector&lt;T&gt;(); public Sequence() { super(0, 0); } public Sequence(T element) { super(element); elements.add(element); } public int length() { return elements.size(); } public T elementAt(int i) { return elements.elementAt(i); } public Sequence add(T element) { elements.add(element); return this; } public Sequence add(int pos, T element) { elements.add(pos, element); return this; } public Sequence addAll(Sequence&lt;T&gt; others) { if( others == null ) return this; elements.addAll(others.elements); return this; } public void visitChildren(Visitor v) { for( AST element : elements ) { element.visit(v); } } public void replaceChild(AST old, AST gnu) { T NEW = (T)gnu; for(int i = 0; i &lt; elements.size(); i++ ) { if( elements.get(i) == old ) { elements.set(i, NEW); return; } } throw new Driver.CompileError("Can't find child in replaceChild."); } /*** START GENERATED VISITOR PROTOCOL ***///TODO public void visit(mj.compiler.Visitor v) { v.visitSequence(this); } /*** END GENERATED VISITOR PROTOCOL ***/ } Hope this helps something. ps- I am able to create and run a very simple AspectJ project with an aspect, advice, and some Java 5 syntax.
" ""bad type name"" thrown when compiling" I just downloaded AJDT version 1.2.0.20050124144759 and I am running Eclipse 3.1M4. I tried to use aspectJ on an existing Java 5 project. There are no aspects in it yet, just straight Java 5. The project runs just fine as a standard Java project. When add the AspectJ nature and I try to compile the project, no class files are generated and I get this error generated on a type that is parameterized: Internal compiler error The source code of the file that generates this error is: /*** START GENERATED VISITOR PROTOCOL *** /*** END GENERATED VISITOR PROTOCOL ***/  Hope this helps something. ps- I am able to create and run a very simple AspectJ project with an aspect, advice, and some Java 5 syntax.
******
ajde/testdata/bug-83565/Bug.Sequence(T),False,new_method|test_method
ajde/testdata/bug-83565/Bug.length(),False,new_method|test_method
ajde/testdata/bug-83565/Bug.elementAt(int),False,new_method|test_method
ajde/testdata/bug-83565/Bug.AST(),False,new_method|test_method
ajde/testdata/bug-83565/Bug.AST(T),False,new_method|test_method
ajde/testsrc/org/aspectj/ajde/AjdeTests.suite(),False,new_method|test_method
ajde/testsrc/org/aspectj/ajde/GenericsTest.testBuild(),False,new_method|test_method
ajde/testsrc/org/aspectj/ajde/GenericsTest.setup(),False,new_method|test_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.genBytecodeInfo(MethodDeclaration, IProgramElement),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.visit(ConstructorDeclaration, ClassScope),True
#####
AspectJ
81846
a675b659cdc4da45383551e75c9472556c095f94
EclipseAdapterUtils.java:83 java.lang.ArrayIndexOutOfBoundsException: 3 Unfortunately I can't provide much more information, please see the attached compiler dump.
:83 : 3 Unfortunately I can't provide much more information, please see the attached compiler dump.
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.makeLocationContext(ICompilationUnit, IProblem),True
#####
AspectJ
99168
588023e3beb9f861405f4f9a580122993d2dbb47
[generics][itds] ITD on generic inner class crashes ajc inter-type declaration on a generic inner class crashes the compiler: class Outer { class Inner {} class Generic_Inner&lt;T&gt; {} } class Generic_Outer&lt;T&gt; { } aspect Injector { int Outer.outer; // works int Outer.Inner.inner; // works int Generic_Outer.outer; // works int Outer.Generic_Inner.inner; // crashes } /home/user/sgelin3/dev/java/ajc/new_bug/Bug.java [error] Internal compiler error java.lang.RuntimeException: can't handle: class Generic_Inner#RAW extends NULL TYPENULL SUPERINTERFACES enclosing type : OuterNULL FIELDSNULL METHODS at org.aspectj.ajdt.internal.compiler.lookup.InterTypeScope.makeSourceTypeBinding(InterTypeScope.java:35) at org.aspectj.ajdt.internal.compiler.lookup.InterTypeScope.&lt;init&gt;(InterTypeScope.java:28) at org.aspectj.ajdt.internal.compiler.ast.InterTypeDeclaration.resolve(InterTypeDeclaration.java:101) at org.aspectj.ajdt.internal.compiler.ast.InterTypeFieldDeclaration.resolve(InterTypeFieldDeclaration.java:141) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1076) at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.resolve(AspectDeclaration.java:110) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1125) ...
[generics][itds] ITD on generic inner class crashes ajc inter-type declaration on a generic inner class crashes the compiler: class Outer { class Inner {} class Generic_Inner&lt;T&gt; {} } class Generic_Outer&lt;T&gt; { } aspect Injector { int Outer.outer; // works int Outer.Inner.inner; // works int Generic_Outer.outer; // works int Outer.Generic_Inner.inner; // crashes } /home/user/sgelin3/dev/java/ajc/new_bug/Bug.java [error] Internal compiler error java.lang.RuntimeException: can't handle: class Generic_Inner#RAW extends NULL TYPENULL SUPERINTERFACES enclosing type : OuterNULL FIELDSNULL METHODS at ...
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeScope.makeSourceTypeBinding(ReferenceBinding),True
#####
AspectJ
98320
bdfe1316585fb6697eba3beeef0095bc9039371a
[generics][itds] intertype with nested generic type import java.util.*; class C { Set&lt;String&gt; simple_local; Set&lt;Set&lt;String&gt;&gt; nested_local; } aspect Inter_Type_Injector { Set&lt;String&gt; C.simple_intertype; Set&lt;Set&lt;String&gt;&gt; C.nested_intertype; public void test() { Set&lt;String&gt; simple_local = new C().simple_local; // works Set&lt;String&gt; simple_intertype = new C().simple_intertype; // works Set&lt;Set&lt;String&gt;&gt; nested_local = new C().nested_local; // works Set&lt;Set&lt;String&gt;&gt; nested_intertype = new C().nested_intertype; // fails } } zipfile classpath entry does not exist: /opt/sun-jdk-1.5.0/jre/lib/i18n.jar zipfile classpath entry does not exist: /opt/sun-jdk-1.5.0/jre/lib/sunrsasign.jar directory classpath entry does not exist: /opt/sun-jdk-1.5.0/jre/classes compiling /home/user/sgelin3/shared/dev/java/ajc/Bug.java /home/user/sgelin3/shared/dev/java/ajc/Bug.java:16 [error] Type mismatch: cannot convert from Set&lt;Set&lt;E&gt;&gt; to Set&lt;Set&lt;String&gt;&gt; Set&lt;Set&lt;String&gt;&gt; nested_intertype = new C().nested_intertype; // fails ^^^^^^^^^^^ 1 error
[generics][itds] intertype with nested generic type zipfile classpath entry does not exist: zipfile classpath entry does not exist: directory classpath entry does not exist: compiling :16 [error] Type mismatch: cannot convert from Set&lt;Set&lt;E&gt;&gt; to Set&lt;Set&lt;String&gt;&gt; Set&lt;Set&lt;String&gt;&gt; // fails ^^^^^^^^^^^ 1 error
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.fromBinding(TypeBinding),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.lookupBinding(String),True
#####
AspectJ
100227
7d5002ad52c86eefdf58535310fb41f042206d11
[generics][itds] inner class with generic enclosing class ajc crashes with a NullPointerException when an intertype declaration tries to modify an inner class, if the enclosing (outer) class is generic: class Outer { class Inner {} } class Generic_Outer&lt;T&gt; { class Inner {} } aspect Injector { int Outer.outer; // works int Outer.Inner.inner; // works int Generic_Outer.outer; // works int Generic_Outer.Inner.inner; // crashes } /home/user/sgelin3/dev/java/ajc/new_bug/Bug.java [error] Internal compiler error java.lang.NullPointerException at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBinding(EclipseFactory.java:202) at org.aspectj.ajdt.internal.compiler.ast.InterTypeFieldDeclaration.build(InterTypeFieldDeclaration.java:173) at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTypeAndPerClause(AspectDeclaration.java:1020) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildInterTypeAndPerClause(AjLookupEnvironment.java:306) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:122) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:302) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:316) ...
[generics][itds] inner class with generic enclosing class ajc crashes with a when an intertype declaration tries to modify an inner class, if the enclosing (outer) class is generic: ...
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.fromBinding(TypeBinding),True
tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.testItdGenerics_pr99228(),False,test_method
tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.testItdGenerics_pr98320(),False,test_method
tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.testItdGenerics_pr100227(),False,new_method|test_method
weaver/src/org/aspectj/weaver/TypeX.forParameterizedTypeNames(String, String[]),True
weaver/src/org/aspectj/weaver/TypeX.forRawTypeNames(String),True
weaver/src/org/aspectj/weaver/TypeX.isParameterized(),True
weaver/src/org/aspectj/weaver/TypeX.isRawType(),True
weaver/src/org/aspectj/weaver/TypeX.setRawtype(boolean),False,new_method
#####
AspectJ
82171
df7fff4c8c073a3bbcfe749134d577299402d5fb
enable ASM interoperability with JavaCore via uniform element handles Proposal pasted from the following email discussion: http://dev.eclipse.org/mhonarc/lists/ajdt-dev/msg00379.html We finally seem to be both have more support for working directly with the Java Model, and more need to do so. Here's an idea for a light-weight update to our architecture that will give us transparent access for working with the relationship map using either the IJavaElements or IProgramElements. The idea is that we change the handle identifiers, used for storing entries in the map, to be the same those used by the JavaModel, i.e. IJavaElement.getHandleIdentifier(). That will allow us to ask for relationships for IJavaElements, and get back a list of handles that an adapter can turn into IJavaElements. Currently our identifiers are a source location including path, line, and column number. The Java model uses the handles that look like the following, "=Project-l/src&lt;pkg1{Foo.java[Foo~m1", which uniquely identify members, are stable across builds and Eclipse invocations, but don't go below the member signature. So our adapter will have to extend these by appending either line/column or offset information to reach at "code" elements (e.g. calls, handlers). That's doable, and these handles should just get ignored by JavaCore as desired. But I'm wondering what they should correspond to in our extended Java Model, perhaps a subtype of SourceRefElement called ICodeElement? We should get JDT Core to add something like that anyway, but they'll probably want to call it IUnknownElement or IGenericRefElement to provide other projects with the same sort of extensibility. Another challenge will be generating the project part of the handle because our compiler doesn't know about workspaces. I hope that info can be extracted from the full path and source path information. Then for other IDEs we can simply use the same relative path convention.
enable ASM interoperability with via uniform element handles Proposal pasted from the following email discussion: http://dev.eclipse.org/mhonarc/lists/ajdt-dev/msg00379.html We finally seem to be both have more support for working directly with the Java Model, and more need to do so. Here's an idea for a light-weight update to our architecture that will give us transparent access for working with the relationship map using either the or. The idea is that we change the handle identifiers, used for storing entries in the map, to be the same those used by the , i.e.. That will allow us to ask for relationships for , and get back a list of handles that an adapter can turn into . Currently our identifiers are a source location including path, line, and column number. The Java model uses the handles that look like the following, , which uniquely identify members, are stable across builds and Eclipse invocations, but don't go below the member signature. So our adapter will have to extend these by appending either line/column or offset information to reach at "code" elements (e.g. calls, handlers). That's doable, and these handles should just get ignored by JavaCore as desired. But I'm wondering what they should correspond to in our extended Java Model, perhaps a subtype of SourceRefElement called ? We should get JDT Core to add something like that anyway, but they'll probably want to call it or to provide other projects with the same sort of extensibility. Another challenge will be generating the project part of the handle because our compiler doesn't know about workspaces. I hope that info can be extracted from the full path and source path information. Then for other IDEs we can simply use the same relative path convention.
******
asm/src/org/aspectj/asm/AsmManager.AsmManager(),True
asm/src/org/aspectj/asm/AsmManager.getHandleProvider(),False,new_method
asm/src/org/aspectj/asm/AsmManager.setHandleProvider(IElementHandleProvider),False,new_method
asm/src/org/aspectj/asm/IElementHandleProvider.createHandleIdentifier(ISourceLocation),False,new_method
asm/src/org/aspectj/asm/IElementHandleProvider.createHandleIdentifier(File, int,int,int),False,new_method
asm/src/org/aspectj/asm/IElementHandleProvider.getFileForHandle(String),False,new_method
asm/src/org/aspectj/asm/IElementHandleProvider.getLineNumberForHandle(String),False,new_method
asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.getElement(String),True
asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.findElementForHandle(String),True
asm/src/org/aspectj/asm/internal/FullPathHandleProvider.createHandleIdentifier(ISourceLocation),False,new_method
asm/src/org/aspectj/asm/internal/FullPathHandleProvider.createHandleIdentifier(File, int, int, int),False,new_method
asm/src/org/aspectj/asm/internal/FullPathHandleProvider.getFileForHandle(String),False,new_method
asm/src/org/aspectj/asm/internal/FullPathHandleProvider.getLineNumberForHandle(String),False,new_method
asm/src/org/aspectj/asm/internal/ProgramElement.createHandleIdentifier(File, int, int, int),True
asm/src/org/aspectj/asm/internal/ProgramElement.getHandleIdentifier(),True
asm/src/org/aspectj/asm/internal/ProgramElement.genHandleIdentifier(ISourceLocation),True
docs/sandbox/api-clients/org/aspectj/samples/AsmRelationshipMapExtensionTest.addDeclareParentsRelationship(ISourceLocation, ResolvedTypeX, List),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AsmInterTypeRelationshipProvider.ddRelationship(ResolvedTypeX, EclipseTypeMunger),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.addUsesPointcutRelationsForNode(IProgramElement peNode, List namedPointcuts, MethodDeclaration),True
weaver/src/org/aspectj/weaver/AsmRelationshipProvider.checkerMunger(IHierarchy, Shadow, Checker),True
weaver/src/org/aspectj/weaver/AsmRelationshipProvider.addRelationship(ResolvedTypeX, ResolvedTypeMunger, ResolvedTypeX),True
weaver/src/org/aspectj/weaver/AsmRelationshipProvider.addDeclareParentsRelationship(ISourceLocation, ResolvedTypeX, List),True
weaver/src/org/aspectj/weaver/AsmRelationshipProvider.addDeclareAnnotationRelationship(ISourceLocation, ISourceLocation),True
weaver/src/org/aspectj/weaver/AsmRelationshipProvider.addDeclareAnnotationRelationship(ISourceLocation, String, Method),True
weaver/src/org/aspectj/weaver/AsmRelationshipProvider.addDeclareAnnotationRelationship(ISourceLocation, String, Field),True
weaver/src/org/aspectj/weaver/ShadowMunger.getHandle(),True
#####
AspectJ
82752
37c44d35a618695c1abb2e204cc31c5e38bfcbe5
"ProgramElement.getSourceSignature returns ""public"" for ""private"" members" This bug affects ajdoc, and could affect other tools relying on the ASM.
"returns ""public"" for ""private"" members" This bug affects ajdoc, and could affect other tools relying on the ASM.
******
ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.testAspectAccessibility(),False,new_method|test_method
asm/src/org/aspectj/asm/internal/ProgramElement.setParents(),True
#####
AspectJ
102459
c6bc7a2b2ee30b7647d3cb17fc323ebf96768fef
provide more detail in -showWeaveInfo messages When advice is executed, the object you have to work with is the joinpoint. This can then be queried to get various information out of it. It would be nice, if as part of the weaving you could get hold of the same information. This is particularly useful in the case of writing a coverage tool. In order to measure where you've been, you have to know all the places you could possibly go. The introduction of the -showWeaveInfo option means that we can record these places, however, this would be greatly enhanced by providing similar information as to that which is collected as the program is running. The information which would be good is the same as that obtained from JoinPoint.StaticPart.getSignature().toLongString().
provide more detail in -showWeaveInfo messages When advice is executed, the object you have to work with is the. This can then be queried to get various information out of it. It would be nice, if as part of the weaving you could get hold of the same information. This is particularly useful in the case of writing a coverage tool. In order to measure where you've been, you have to know all the places you could possibly go. The introduction of the -showWeaveInfo option means that we can record these places, however, this would be greatly enhanced by providing similar information as to that which is collected as the program is running. The information which would be good is the same as that obtained from.
******
tests/java5/ataspectj/ataspectj/ltwlog/MainVerboseAndShow.main(String),False,test_method
weaver/src/org/aspectj/weaver/Shadow.reportWeavingMessage(ShadowMunger),True
bridge/src/org/aspectj/bridge/WeaveMessage,True
#####
AspectJ
109173
03b20bc1129e03d5e8594262b89021e54ab017f9
"Weaving Adaptor enhancements for performance, configuration and diagnosis" Here are some suggested enhancements as a result of exhaustive testing in the Eclipse/OSGi environment. 1. If no aspects are declared for a particular class loader, either because there are no visible aop.xml files or they contain no aspect definitions, then we should short-circuit the implementation of weaveClass() so that byte-code is not unnecessarily passed to the weaver. This is especially important under OSGi where there may be hundreds of class bundles, each with their own class loader only some of which are being woven. We can use the existing ?enabled? flag. 2. As previously discussed on aspectj-dev the META-INF directory is considered private in OSGi and is therefore an inappropriate location for aop.xml files declaring shared aspects. I therefore propose a System property to set the a resource names for finding aop.xml files which would default to ?META-INF/aop.xml? e.g. -Dorg.aspectj.weaver.loadtime.configuration=META- INF/aop.xml;org/aspectj/aop.xml. 3. We should not be catching Throwable in Aj. Instead we should catch known exceptions e.g. BCException and issue messages while letting other runtime exceptions pass back to the class loader. A user provided IMessageHandler implementation can decide under what circumstances to abort. Alternatively if Aj is considered to be a ?safe? interface for weaving agents e.g. JVMTI then the dump logic it contains should be moved to the WeavingAdaptor so that it can be used directly from a class loader.
"Weaving Adaptor enhancements for performance, configuration and diagnosis" Here are some suggested enhancements as a result of exhaustive testing in the Eclipse/OSGi environment. 1. If no aspects are declared for a particular class loader, either because there are no visible files or they contain no aspect definitions, then we should short-circuit the implementation of so that byte-code is not unnecessarily passed to the weaver. This is especially important under OSGi where there may be hundreds of class bundles, each with their own class loader only some of which are being woven. We can use the existing ?enabled? flag. 2. As previously discussed on the directory is considered private in OSGi and is therefore an inappropriate location for aop.xml files declaring shared aspects. I therefore propose a System property to set the a resource names for finding files which would default to ?? e.g. -Dorg.. 3. We should not be catching Throwable in Aj. Instead we should catch known exceptions e.g. and issue messages while letting other runtime exceptions pass back to the class loader. A user provided implementation can decide under what circumstances to abort. Alternatively if Aj is considered to be a ?safe? interface for weaving agents e.g. JVMTI then the dump logic it contains should be moved to the so that it can be used directly from a class loader.
******
loadtime/src/org/aspectj/weaver/loadtime/Aj.Aj(),True
loadtime/src/org/aspectj/weaver/loadtime/Aj.Aj(IWeavingContext),True
loadtime/src/org/aspectj/weaver/loadtime/Aj.getWeaver(ClassLoader),True
loadtime/src/org/aspectj/weaver/loadtime/Aj.getWeaver(ClassLoader, IWeavingContext),False,new_method
loadtime/src/org/aspectj/weaver/loadtime/Aj.getNamespace(ClassLoader),False,new_method
loadtime/src/org/aspectj/weaver/loadtime/Aj.generatedClassesExist(ClassLoader),False,new_method
loadtime/src/org/aspectj/weaver/loadtime/Aj.flushGeneratedClasses(ClassLoader),False,new_method
loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.ClassLoaderWeavingAdaptor(ClassLoader),True
loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.ClassLoaderWeavingAdaptor(ClassLoader, IWeavingContext),False,new_method
loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.registerDefinitions(BcelWeaver, ClassLoader),True
loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.registerAspects(BcelWeaver, ClassLoader, List),True
loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.getNamespace(),True
loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.generatedClassesExist(),True
loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.flushGeneratedClasses(),False,new_method
loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.readAspect(String, ClassLoader),False,new_method
loadtime/src/org/aspectj/weaver/loadtime/DefaultWeavingContext.DefaultWeavingContext(),False,new_method
loadtime/src/org/aspectj/weaver/loadtime/DefaultWeavingContext.DefaultWeavingContext(ClassLoader),False,new_method
loadtime/src/org/aspectj/weaver/loadtime/DefaultWeavingContext.getResources(String),False,new_method
loadtime/src/org/aspectj/weaver/loadtime/DefaultWeavingContext.getBundleIdFromURL(URL),False,new_method
loadtime/src/org/aspectj/weaver/loadtime/IWeavingContext.getResources(String),False,new_method
loadtime/src/org/aspectj/weaver/loadtime/IWeavingContext.getBundleIdFromURL(URL),False,new_method
#####
AspectJ
92880
d2ab7c219daefa33aef2e934c1b1d660cdad401e
@AJ PTW implement PTW for @AJ aspects so far delayed to make sure PTW in code style was not evolving
@AJ PTW implement PTW for @AJ aspects so far delayed to make sure PTW in code style was not evolving
******
weaver/src/org/aspectj/weaver/bcel/BcelPerClauseAspectAdder.generatePerTypeWithinGetInstanceMethod(ClassFile ),True
weaver/src/org/aspectj/weaver/AjcMemberMaker,True
#####
AspectJ
101047
85a4b0afb2c4b69cb467484d9ed18b21e414a868
Weaver produces wrong local variable table bytecode AspectJ version: DEVELOPMENT (also observed in 1.2.1) When weaving with a before or after advice, the generated local variable table will, on branch instructions, offset the "length" field of a local variable wrongly by one instruction. Also, the weaver will mix up local variables with the same name, thus violating the java VM specification: // Test.aj aspect Test { before() : ( execution(* Foo.foo(..) ) ) { System.out.println("before"); } // Foo.java public class Foo { private String myString = "A String"; public static void main(String[] args) { new Foo().foo(); } private void foo() { String myLocal = myString; if (myLocal.endsWith("X")) { String local1 = "local1"; System.out.println(local1); } else if (myLocal.endsWith("Y")) { String local2 = "local2"; System.out.println(local2); } else { String local1 = "local3"; System.out.println(local1); } } } --- We compilw with ajc -sourceroots . and dumps Foo with javap: javap -c -l -s -private Foo .... .... private void foo(); Signature: ()V Code: 0: invokestatic #65; //Method Test.aspectOf:()LTest; 3: invokevirtual #68; //Method Test.ajc$before$Test$1$f0485e90:()V 6: aload_0 7: getfield #15; //Field myString:Ljava/lang/String; 10: astore_1 11: aload_1 12: ldc #30; //String X 14: invokevirtual #36; //Method java/lang/String.endsWith: (Ljava/lang/String;)Z 17: ifeq 33 20: ldc #38; //String local1 22: astore_2 23: getstatic #44; //Field java/lang/System.out:Ljava/io/PrintStream; 26: aload_2 27: invokevirtual #50; //Method java/io/PrintStream.println: (Ljava/lang/String;)V 30: goto 65 33: aload_1 34: ldc #52; //String Y 36: invokevirtual #36; //Method java/lang/String.endsWith: (Ljava/lang/String;)Z 39: ifeq 55 42: ldc #54; //String local2 44: astore_2 45: getstatic #44; //Field java/lang/System.out:Ljava/io/PrintStream; 48: aload_2 49: invokevirtual #50; //Method java/io/PrintStream.println: (Ljava/lang/String;)V 52: goto 65 55: ldc #56; //String local3 57: astore_2 58: getstatic #44; //Field java/lang/System.out:Ljava/io/PrintStream; 61: aload_2 62: invokevirtual #50; //Method java/io/PrintStream.println: (Ljava/lang/String;)V 65: return LineNumberTable: line 7: 6 line 8: 11 line 9: 20 line 10: 23 line 11: 33 line 12: 42 line 13: 45 line 15: 55 line 16: 58 line 18: 65 LocalVariableTable: Start Length Slot Name Signature 6 60 0 this LFoo; 11 55 1 myLocal Ljava/lang/String; 45 12 2 local2 Ljava/lang/String; 23 43 2 local1 Ljava/lang/String; We see that the two occurences of the "local1" variable erroneously have been combined into one entry, starting at byte 23 and ending at byte 66. This is obviously wrong, since "local1" has no value in the "local2" block. Secondly, the "local2" variable end is wrongly offset by one instruction offset.
Weaver produces wrong local variable table bytecode AspectJ version: DEVELOPMENT (also observed in 1.2.1) When weaving with a before or after advice, the generated local variable table will, on branch instructions, offset the "length" field of a local variable wrongly by one instruction. Also, the weaver will mix up local variables with the same name, thus violating the java VM specification: // --- We compilw with ajc -sourceroots . and dumps Foo with javap: .... .... We see that the two occurences of the "local1" variable erroneously have been combined into one entry, starting at byte 23 and ending at byte 66. This is obviously wrong, since "local1" has no value in the "local2" block. Secondly, the "local2" variable end is wrongly offset by one instruction offset.
******
bcel-builder/src/org/aspectj/apache/bcel/generic/MethodGen.MethodGen(Method, String, ConstantPoolGen),True
#####
AspectJ
108118
81a07900d1e2c4db563d5b4a833b404ac51ee5bd
Complete implementation of @SuppressAjWarnings ensure that @SuppressAJWarnings are indeed suppressed during pointcut operations. This requires wrapping major pointcut operations with calls to Lint from the associated advice.
Complete implementation of ensure that are indeed suppressed during pointcut operations. This requires wrapping major pointcut operations with calls to Lint from the associated advice.
******
tests/src/org/aspectj/systemtest/ajc150/SuppressedWarnings.testSuppressionOfMessagesIssuedDuringMatching(),False,new_method|test_method
weaver/src/org/aspectj/weaver/bcel/BcelAdvice.concretize(ResolvedType, World, PerClause),False,new_method|test_method
weaver/src/org/aspectj/weaver/bcel/BcelAdvice.match(Shadow, World),False,new_method|test_method
weaver/src/org/aspectj/weaver/bcel/BcelAdvice.specializeOn(Shadow),True
weaver/src/org/aspectj/weaver/bcel/BcelAdvice.suppressLintWarnings(World),False,new_method
weaver/src/org/aspectj/weaver/bcel/BcelAdvice.clearLintSuppressions(World),False,new_method
weaver/src/org/aspectj/weaver/bcel/Utility.getSuppressedWarnings(AnnotationX[], Lint),True
#####
AspectJ
100195
d6256b8c3c944d8fa2feb6d837900144db6521ac
Missing LocalVariableTable debug info for around advice AspectJ version: 1.2.1 (also observed in aspectj-DEVELOPMENT) java version "1.4.2_07" When debugging java code woven with an "around" advice with proceed, it looks like the LocalVariableTable information gets lost during the weaving. Example code: // Foo.java public class Foo { private String myString = "A String"; public static void main(String[] args) { new Foo().foo(); } private void foo() { String myLocal = myString; System.out.println(myLocal); // breakpoint here } } // Test.aj aspect Test { void around() : ( execution(* Foo.foo(..) ) ) { System.out.println("before"); proceed(); System.out.println("after"); } } We compiled with ajc 1.2.1: ajc -g -preserveAllLocals -sourceroots . When running Foo in the Eclipse 3.1.0 debugger and setting a breakpoint at the "System.out.println(myLocal);" line, the debugger "Variables" window is empty. Also, disassembling with javap shows that the LocalVariableTable is empty in the generated foo_aroundBody0 method : &gt; javap -c -l -s -private Foo private static final void foo_aroundBody0(Foo); Signature: (LFoo;)V Code: 0: aload_0 1: getfield #15; //Field myString:Ljava/lang/String; 4: astore_1 5: aload_1 6: ldc #30; //String X 8: invokevirtual #36; //Method java/lang/String.endsWith: (Ljava/lang/String;)Z 11: ifeq 27 14: ldc #38; //String local1 16: astore_3 17: getstatic #44; //Field java/lang/System.out:Ljava/io/PrintStream; 20: aload_3 21: invokevirtual #50; //Method java/io/PrintStream.println: (Ljava/lang/String;)V 24: goto 37 27: ldc #52; //String local2 29: astore_3 30: getstatic #44; //Field java/lang/System.out:Ljava/io/PrintStream; 33: aload_3 34: invokevirtual #50; //Method java/io/PrintStream.println: (Ljava/lang/String;)V 37: return LineNumberTable: line 7: 0 line 8: 5 line 9: 14 line 10: 17 line 12: 27 line 13: 30 line 15: 37
Missing debug info for around advice AspectJ version: 1.2.1 (also observed in aspectj-DEVELOPMENT) java version "1.4.2_07" When debugging java code woven with an "around" advice with proceed, it looks like the information gets lost during the weaving. Example code: // We compiled with ajc 1.2.1: ajc -g -preserveAllLocals -sourceroots . When running Foo in the Eclipse 3.1.0 debugger and setting a breakpoint at the "" line, the debugger "Variables" window is empty. Also, disassembling with javap shows that the is empty in the generated foo_aroundBody0 method : &gt; javap
******
tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.testDebugInfoForAroundAdvice(),False,new_method|test_method
weaver/src/org/aspectj/weaver/bcel/ShadowRange.extractInstructionsInto(LazyMethodGen, IntMap, boolean),True
#####
AspectJ
112243
04e8dca2fc16f5f834e124b7abea5847d90c3366
Compiler Core Dump with Apparent Fix I am seeing this exception when using ajc to do binary weaving: [iajc] Exception thrown from AspectJ 1.5.0M4 [iajc] This might be logged as a bug already -- find current bugs at [iajc] http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component =Compiler [iajc] Bugs for exceptions thrown have titles File:line from the top stack, [iajc] e.g., "SomeFile.java:243" [iajc] If you don't find the exception below in a bug, please add a new bug [iajc] at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ [iajc] To make the bug a priority, please include a test program [iajc] that can reproduce this exception. [iajc] org.aspectj.weaver.MissingResolvedTypeWithKnownSignature [iajc] when batch building with classpath: ... [iajc] org.aspectj.weaver.MissingResolvedTypeWithKnownSignature [iajc] java.lang.ClassCastException: org.aspectj.weaver.MissingResolvedType WithKnownSignature [iajc] at org.aspectj.weaver.bcel.BcelWorld.addSourceObjectType(BcelWor ld.java:277) [iajc] at org.aspectj.weaver.bcel.BcelWeaver.addClassFile(BcelWeaver.ja va:373) [iajc] at org.aspectj.weaver.bcel.BcelWeaver.addJarFile(BcelWeaver.java :306) [iajc] at org.aspectj.ajdt.internal.core.builder.AjBuildManager.initBce lWorld(AjBuildManager.java:598) [iajc] at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild (AjBuildManager.java:204) [iajc] at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBu ild(AjBuildManager.java:151) [iajc] at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:1 12) [iajc] at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java: 60) [iajc] at org.aspectj.tools.ajc.Main.run(Main.java:326) [iajc] at org.aspectj.tools.ajc.Main.runMain(Main.java:240) [iajc] at org.aspectj.tools.ajc.Main.main(Main.java:83) [iajc] 1 fail|abort I see this also in HEAD and used the debugger to determine it is trying to resolve the type that it's trying to load! I am able to get it to finish the weave with no errors by changing BcelWorld as follows: public BcelObjectType addSourceObjectType(JavaClass jc) { BcelObjectType ret = null; String signature = UnresolvedType.forName(jc.getClassName ()).getSignature(); ReferenceType nameTypeX = null; Object lookup = typeMap.get(signature); if (lookup instanceof ReferenceType) { nameTypeX = (ReferenceType)lookup; } Instead of just casting. Then the result is null and it falls through to the usual lookup unresolved type logic. Is this fix correct? I suspect it would take a few hours to narrow down a test case for this one.
Compiler Core Dump with Apparent Fix I am seeing this exception when using ajc to do binary weaving: [iajc] Exception thrown from AspectJ 1.5.0M4 [iajc] This might be logged as a bug already -- find current bugs at [iajc] http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component =Compiler [iajc] Bugs for exceptions thrown have titles File:line from the top stack, [iajc] e.g., ":243" [iajc] If you don't find the exception below in a bug, please add a new bug [iajc] at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ [iajc] To make the bug a priority, please include a test program [iajc] that can reproduce this exception. [iajc] [iajc] when batch building with classpath: ... [iajc] [iajc] [iajc] [iajc] 1 fail|abort I see this also in HEAD and used the debugger to determine it is trying to resolve the type that it's trying to load! I am able to get it to finish the weave with no errors by changing BcelWorld as follows: Instead of just casting. Then the result is null and it falls through to the usual lookup unresolved type logic. Is this fix correct? I suspect it would take a few hours to narrow down a test case for this one.
******
weaver/src/org/aspectj/weaver/World.put(String, ResolvedType),True
weaver/src/org/aspectj/weaver/bcel/BcelWorld.addSourceObjectType(JavaClass),True
#####
AspectJ
107299
332a5df39711d17d13ef2c87fdaba023d4869538
#NAME? ajc doesn't recognize Windows absolute file paths that don't start with a drive letter, e.g., run: ajc -inpath \test.jar [error] build config error: bad inpath component: \test.jar but ajc -inpath c:\test.jar works ajc -aspectpath \test.jar Test.aj [error] build config error: bad aspectpath: \test.jar ajc -aspectpath c:\test.jar Test.aj (works)
#NAME? ajc doesn't recognize Windows absolute file paths that don't start with a drive letter, e.g., run: ajc [error] build config error: bad inpath component: works ajc [error] build config error: bad  (works)
******
util/src/org/aspectj/util/ConfigParser.makeFile(File, String),True
#####
AspectJ
113510
62d16d52c25f7b5ff389ee2de603bbb3dc186c8e
readAspect clearly define what the goal for readAspect is old byte per byte reading cause NPE in some test case current impl is hashcode for aspect name + classloader - ie unstable across startups.
clearly define what the goal for is old byte per byte reading cause NPE in some test case current impl is hashcode for aspect name + - ie unstable across startups.
******
loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.registerAspects(BcelWeaver, ClassLoader, List),True
loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.readAspect(String, ClassLoader),True
#####
AspectJ
103741
a87f82dcb4a8f162a02992d89a78ec43b677fef5
Problem turning off Java 5 Support with @annotation pointcut (TypeX.java:821) I had a project that I was compiling using Java 5 source support. I turned off java 5 support but accidentally left in an @annotation pointcut in it. When recompiling, I get an error dialog BCException thrown: Bad type signature: &lt;missing&gt; When I restart I get this in my error log, and if I compile the same message. java.lang.ClassCastException: org.eclipse.core.internal.resources.Project at org.eclipse.ajdt.core.javaelements.AJCompilationUnit.&lt;init&gt; (AJCompilationUnit.java:118) at org.eclipse.ajdt.core.AspectJCore.create(AspectJCore.java:137) at org.eclipse.ajdt.core.AspectJCore.create(AspectJCore.java:38) at org.eclipse.ajdt.core.model.AJProjectModel$Persistence.loadJavaElements (AJProjectModel.java:633) at org.eclipse.ajdt.core.model.AJProjectModel$Persistence.loadModel (AJProjectModel.java:568) at org.eclipse.ajdt.core.model.AJProjectModel.loadModel (AJProjectModel.java:136) at org.eclipse.ajdt.core.model.AJModel.getModelForProject(AJModel.java:83) at org.eclipse.ajdt.core.model.AJModel.isAdvised(AJModel.java:126) at org.eclipse.ajdt.internal.buildconfig.ImageDecorator.decorateImage (ImageDecorator.java:207) at org.eclipse.ui.internal.decorators.FullDecoratorDefinition.decorateImage (FullDecoratorDefinition.java:111) at org.eclipse.ui.internal.decorators.FullImageDecoratorRunnable.run (FullImageDecoratorRunnable.java:28) at org.eclipse.core.internal.runtime.InternalPlatform.run (InternalPlatform.java:1044) at org.eclipse.core.runtime.Platform.run(Platform.java:783) at org.eclipse.ui.internal.decorators.DecoratorManager.safeDecorateImage (DecoratorManager.java:395) at org.eclipse.ui.internal.decorators.DecoratorManager.decorateImage (DecoratorManager.java:360) at org.eclipse.jface.viewers.DecoratingLabelProvider.getImage (DecoratingLabelProvider.java:84) at org.eclipse.jface.viewers.DecoratingLabelProvider.updateLabel (DecoratingLabelProvider.java:212) at org.eclipse.jface.viewers.StructuredViewer.buildLabel (StructuredViewer.java:1855) at org.eclipse.jface.viewers.TreeViewer.doUpdateItem(TreeViewer.java:228) at org.eclipse.jface.viewers.AbstractTreeViewer$UpdateItemSafeRunnable.run (AbstractTreeViewer.java:85) at org.eclipse.core.internal.runtime.InternalPlatform.run (InternalPlatform.java:1044) at org.eclipse.core.runtime.Platform.run(Platform.java:783) at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:44) at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:148) at org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem (AbstractTreeViewer.java:621) at org.eclipse.jface.viewers.StructuredViewer$UpdateItemSafeRunnable.run (StructuredViewer.java:434) at org.eclipse.core.internal.runtime.InternalPlatform.run (InternalPlatform.java:1044) at org.eclipse.core.runtime.Platform.run(Platform.java:783) at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:44) at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:148)
Problem turning off Java 5 Support with @annotation (:821) I had a project that I was compiling using Java 5 source support. I turned off java 5 support but accidentally left in an @annotation pointcut in it. When recompiling, I get an error dialog thrown: Bad type signature: &lt;missing&gt; When I restart I get this in my error log, and if I compile the same message.
******
weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.resolveBindings(IScope, Bindings),True
weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.resolveBindings(IScope, Bindings),True
weaver/src/org/aspectj/weaver/patterns/DeclareAnnotation.resolve(IScope),True
weaver/src/org/aspectj/weaver/patterns/ThisOrTargetAnnotationPointcut.resolveBindings(IScope, Bindings),True
weaver/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.resolveBindings(IScope, Bindings, boolean),True
weaver/src/org/aspectj/weaver/patterns/WithinAnnotationPointcut.resolveBindings(IScope, Bindings),True
weaver/src/org/aspectj/weaver/patterns/WithinCodeAnnotationPointcut.resolveBindings(IScope, Bindings),True
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.init(List, List),True
weaver/testsrc/org/aspectj/weaver/patterns/AnnotationPatternMatchingTestCase.loadType(String),false,test_method
weaver/testsrc/org/aspectj/weaver/patterns/AnnotationPatternTestCase.makeSimpleScope(),False,test_method
weaver/testsrc/org/aspectj/weaver/patterns/ParserTestCase.makeSimpleScope(),False,test_method
weaver/src/org/aspectj/weaver/WeaverMessages,True
#####
AspectJ
95529
3226d27a82e968da0f04e6b4fb5a29a03fbdb0f5;76ebbc76add2abd815b3a8b5ea0beb11c94c8c49
concrete-aspect for M4 note: need to think some if we want to jit the concrete aspect, or if its not that needed ie that the shadow munger API allow us to do what we need (perhaps not easy to deal with perClause and uniqueness enforcement of concrete-aspect name, but perhaps a burden as well to deal with jit since then no bytecode can be grabbed from file system ie may confuse the bcel repository and resolvedTypeX and alike) Ideas Andy ? I am more in favor of bytecode gen the concrete aspect there. (that further means the underlying infra needs to support define class callbacks like "acceptClass" thing used for ajc$Closure and alike when running LTW. I am ok with that)
concrete-aspect for M4 note: need to think some if we want to jit the concrete aspect, or if its not that needed ie that the shadow munger API allow us to do what we need (perhaps not easy to deal with and uniqueness enforcement of concrete-aspect name, but perhaps a burden as well to deal with jit since then no bytecode can be grabbed from file system ie may confuse the bcel repository and and alike) Ideas Andy ? I am more in favor of bytecode gen the concrete aspect there. (that further means the underlying infra needs to support define class callbacks like "" thing used for and alike when running LTW. I am ok with that)
******
loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.ClassLoaderWeavingAdaptor(ClassLoader, IWeavingContext),True
loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.registerDefinitions(BcelWeaver, ClassLoader),True
loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.getClassLoaderName(ClassLoader),False,new_method
loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.registerAspects(BcelWeaver, ClassLoader, List),True
loadtime/src/org/aspectj/weaver/loadtime/DefaultWeavingContext.getClassLoaderName(),False,new_method
loadtime/src/org/aspectj/weaver/loadtime/IWeavingContext.getClassLoaderName(),False,Comments
loadtime/src/org/aspectj/weaver/loadtime/Options.parse(String, ClassLoader),True
loadtime/src/org/aspectj/weaver/loadtime/Options.parse(String, ClassLoader, IMessageHandler),False,new_method
loadtime/src/org/aspectj/weaver/loadtime/Options.WeaverOption(),True
loadtime/src/org/aspectj/weaver/loadtime/Options.WeaverOption(IMessageHandler),False,new_method
loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.ConcreteAspectCodeGen(Definition.ConcreteAspect, World),False,new_method
loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.validate(),False,new_method
loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.stringify(),False,new_method
loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.getBytes(),False,new_method
loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.reportError(String),False,new_method
loadtime/src/org/aspectj/weaver/loadtime/WeavingURLClassLoader.defineClass(String, byte[], CodeSource),True
loadtime/testsrc/org/aspectj/weaver/loadtime/WeavingURLClassLoaderTest.testLoadWovenClass(),False,test_method,Comments
testWeaveWovenClass(),False,test_method
org.aspectj.ajdt.core/testsrc/org/aspectj/tools/ajc/AjcTestCase.run(String, String[], String, boolean),False,test_method
testing/newsrc/org/aspectj/testing/RunSpec.copyLtwFile(File),False,test_method
tests/ltw/Main.main(String[]),False,test_method
tests/ltw/Main.invokeDeclaredMethods(),False,new_method|test_method
tests/ltw/TestITDMethod.invokeDeclaredMethods (String[]),False,new_method|test_method
tests/ltw/TestITDMethod.main(String[]),False,new_method|test_method
tests/ltw/TestMain.main(String[]),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/ltw/LTWTests.testNoAopxml(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/ltw/LTWTests.testDefineConcreteAspect(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/ltw/LTWTests.testDeclareAbstractAspect(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/ltw/LTWTests.setSystemProperty (String key, String),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/ltw/LTWTests.copyProperty (String key, Properties from, Properties),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/ltw/LTWTests.setUp(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/ltw/LTWTests.tearDown(),False,new_method|test_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.WeavingAdaptor(),False,new_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.init(List, List),True
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.createMessageHandler(),False,new_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.info(String),False,changed_access_level
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.warn(String),False,changed_access_level
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.error(String),False,changed_access_level
aspectj5rt/java5-src/org/aspectj/lang/annotation/Pointcut.Stringvalue(),True
loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.ConcreteAspectCodeGen(Definition.ConcreteAspect, World),False,new_method
loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.validate(),False,new_method
loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.stringify(),False,new_method
loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.getBytes(),False,new_method
loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.reportError(String),False,new_method
loadtime/src/org/aspectj/weaver/loadtime/definition/Definition.ConcreteAspect(String, String),True
loadtime/src/org/aspectj/weaver/loadtime/definition/Definition.ConcreteAspect(String, String, String),False,new_method
loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.startElement(String, String, String, Attributes),True
tests/java5/ataspectj/ataspectj/ConcreteAtAspectTest.target(),False,new_method|test_method
tests/java5/ataspectj/ataspectj/ConcreteAtAspectTest.pc(),False,new_method|test_method
tests/java5/ataspectj/ataspectj/ConcreteAtAspectTest.testConcrete(),False,new_method|test_method
tests/java5/ataspectj/ataspectj/ConcreteAtAspectTest.main(String[]),False,new_method|test_method
tests/java5/ataspectj/ataspectj/ConcreteAtAspectTest.suite(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.testConcreteAspect(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.testConcreteAtAspect(),False,new_method|test_method
weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.handlePointcutAnnotation(RuntimeAnnotations runtimeAnnotations, AjAttributeMethodStruct),True
weaver/src/org/aspectj/weaver/bcel/BcelPerClauseAspectAdder.munge(BcelClassWeaver),True
weaver/src/org/aspectj/weaver/bcel/BcelPerClauseAspectAdder.forceMunge(LazyClassGen),False,new_method
weaver/src/org/aspectj/weaver/bcel/BcelWeaver.addLibraryAspect(String),True
#####
AspectJ
115275
e8b6bde2173e74a5969162aee2de59eee9476456;e2db71535154c6564fb30bebf2f51fc321a94f7c
aop.xml aspect include I have a question about load-time weaving in AspectJ. According to the AspectJ 5 Development Kit Developer's Notebook, the &lt;aspects&gt; element can have an &lt;include within="[pattern]"&gt; child element (http://eclipse.org/aspectj/doc/next/adk15notebook/ltw-configuration.html). However, when I include that element as a child to the &lt;aspects&gt; element in my aop.xml file, I get a SAX exception: org.xml.sax.SAXException: Unknown element while parsing &lt;aspectj&gt; element: include Is the &lt;include&gt; element currently supported within the &lt;aspects&gt; element? Or do I have to explicitly list every aspect I want woven at load time using an &lt;aspect name="..."&gt; for each aspect? Basically I do not wish to explicitly ennumerate every aspect in the aop.xml file for the load-time weaver. Rather, I want to use a wildcard pattern to capture them all.
aspect include I have a question about load-time weaving in AspectJ. According to the AspectJ 5 Development Kit Developer's Notebook, the &lt;aspects&gt; element can have an &lt;include within="[pattern]"&gt; child element (http://eclipse.org/aspectj/doc/next/adk15notebook/ltw-configuration.html). However, when I include that element as a child to the &lt;aspects&gt; element in my file, I get a SAX exception: : Unknown element while parsing &lt;aspectj&gt; element: include Is the &lt;include&gt; element currently supported within the &lt;aspects&gt; element? Or do I have to explicitly list every aspect I want woven at load time using an &lt;aspect name="..."&gt; for each aspect? Basically I do not wish to explicitly ennumerate every aspect in the file for the load-time weaver. Rather, I want to use a wildcard pattern to capture them all.
******
weaver/src/org/aspectj/weaver/Lint,True
loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.registerDefinitions(BcelWeaver, ClassLoader),True
loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.lint(String name, String[]),False,new_method
loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.registerAspects(BcelWeaver, ClassLoader, List),True
tests/src/org/aspectj/systemtest/ajc150/ltw/LTWTests.testAspectsInclude(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/ltw/LTWTests.testAspectsIncludeWithLintWarning(),False,new_method|test_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.warn(String, Throwable),False,new_method
loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.registerDefinitions(BcelWeaver, ClassLoader),True
loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.registerAspectInclude(BcelWeaver, ClassLoader, List),False,new_method
loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.acceptAspect(String),True
loadtime/src/org/aspectj/weaver/loadtime/definition/Definition.getAspectIncludePatterns(),False,new_method
loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.startElement(String, String, String qName, Attributes),True
loadtime/testsrc/org/aspectj/weaver/loadtime/test/DocumentParserTest.(),False,test_method
tests/java5/ataspectj/ataspectj/ConcreteAtAspectTest.pc(),False,test_method|comment
#####
AspectJ
95517
4ea00513761eeb32b3403caa1a3ba39f9218a839
ajc pseudo LTW not consistent with LTW docs says ajc provides LTW things, but that one does not at all go thru aop.xml lookups and so on Needs to be removed or made consistent in some way
ajc pseudo LTW not consistent with LTW docs says ajc provides LTW things, but that one does not at all go thru aop.xml lookups and so on Needs to be removed or made consistent in some way
******
build/src/$installer$/org/aspectj/Main.onUnix(),True
build/src/$installer$/org/aspectj/Main.writeAJLaunchScript(),True
build/src/$installer$/org/aspectj/Main.writeAJLaunchScript(String, boolean),False,new_method
build/src/$installer$/org/aspectj/Main.writeAJLaunchScriptContent(PrintStream),True
build/src/$installer$/org/aspectj/Main.writeAJLaunchScriptContent(PrintStream, boolean),False,new_method
build/src/$installer$/org/aspectj/Main.writeAJ5WindowsLaunchLine(PrintStream),False,new_method
build/src/$installer$/org/aspectj/Main.writeAJUnixLaunchLine(PrintStream),True
build/src/$installer$/org/aspectj/Main.writeAJ5UnixLaunchLine(PrintStream),False,new_method
docs/dist/doc/examples/ltw/HelloWorld.main(String[]),False,new_method
#####
AspectJ
115252
99504bc120db0049fb441bb69b0f37a4a4f29cd9
want xlint message for improper annotation type When an annotation can only target one kind of thing (e.g., a type) but is used to modify something else in a pointcut (e.g., a method), it would be nice if the compiler emitted an error, since the two situations can be confusingly similar: call(@Nice * *(..)) // method call((@Nice *) *(..)) // return type --------------------------------------------- import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; public class AnnotationTypePatternMistakes { @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.TYPE}) @interface I{} @I() class C{} static aspect A { // would like a CE here - I only on types pointcut pc() : execution(@I * *(..)); declare error : pc() : "hi"; } }
want xlint message for improper annotation type When an annotation can only target one kind of thing (e.g., a type) but is used to modify something else in a pointcut (e.g., a method), it would be nice if the compiler emitted an error, since the two situations can be confusingly similar: // return type --------------------------------------------- 
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.getRetentionPolicy(),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.getAnnotationTargetKinds(),True
weaver/src/org/aspectj/weaver/Lint,True
tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.testXlintMessageForImproperAnnotationType_pr115252_Exact(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.testXlintMessageForImproperAnnotationType_pr115252_OR(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.testXlintMessageForImproperAnnotationType_pr115252_AND(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.testXlintMessageForImproperAnnotationType_pr115252_Return(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.testXlintMessageForImproperAnnotationType_pr115252_Declaring(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.testXlintMessageForImproperAnnotationType_pr115252_Parameter(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.testXlintMessageForImproperAnnotationType_pr115252_Throws(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.testXlintMessageForImproperAnnotationType_pr115252_MoreThanOne(),False,new_method|test_method
weaver/src/org/aspectj/weaver/AnnotationTargetKind.AnnotationTargetKind(String, int),False,new_method
weaver/src/org/aspectj/weaver/AnnotationTargetKind.read(DataInputStream),False,new_method
weaver/src/org/aspectj/weaver/BoundedReferenceType.canAnnotationTargetType(),False,new_method
weaver/src/org/aspectj/weaver/BoundedReferenceType.getAnnotationTargetKinds(),False,new_method
weaver/src/org/aspectj/weaver/ReferenceType.canAnnotationTargetType(),False,new_method
weaver/src/org/aspectj/weaver/ReferenceType.getAnnotationTargetKinds(),False,new_method
weaver/src/org/aspectj/weaver/ResolvedType.canAnnotationTargetType(),False,new_method
getAnnotationTargetKinds(),False,new_method
weaver/src/org/aspectj/weaver/bcel/BcelObjectType.canAnnotationTargetType(),False,new_method
weaver/src/org/aspectj/weaver/bcel/BcelObjectType.getAnnotationTargetKinds(),False,new_method
weaver/src/org/aspectj/weaver/patterns/SignaturePattern.resolveBindings(IScope, Bindings),True
reportUnmatchedTargetKindMessage(AnnotationTargetKind[], PatternNode, IScope, boolean),False,new_method
weaver/src/org/aspectj/weaver/patterns/SignaturePattern.TypePatternVisitor(IScope, boolean),False,new_method
weaver/src/org/aspectj/weaver/patterns/SignaturePattern.visit(WildAnnotationTypePattern, Object),False,new_method
weaver/src/org/aspectj/weaver/patterns/SignaturePattern.visit(ExactAnnotationTypePattern, Object),False,new_method
weaver/src/org/aspectj/weaver/patterns/SignaturePattern.visit(ExactTypePattern, Object),False,new_method
weaver/src/org/aspectj/weaver/patterns/SignaturePattern.visit(AndTypePattern, Object),False,new_method
weaver/src/org/aspectj/weaver/patterns/SignaturePattern.visit(OrTypePattern, Object),False,new_method
weaver/src/org/aspectj/weaver/patterns/SignaturePattern.visit(AnyWithAnnotationTypePattern, Object),False,new_method
weaver/src/org/aspectj/weaver/patterns/SignaturePattern.containedIncorrectTargetKind(),False,new_method
weaver/src/org/aspectj/weaver/patterns/SignaturePattern.getIncorrectTargetKinds(),False,new_method
weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegate.canAnnotationTargetType(),False,new_method
weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegate.getAnnotationTargetKinds(),False,new_method
#####
AspectJ
114875
490749300499a9dac9d290d32cb56ef37e13d74e
@Pointcut - throws java.lang.NullPointerException Eclipse 3.1 AJDT 1.3.0.20051102174241 package com.aspectj.test; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; import org.aspectj.lang.annotation.Pointcut; @Aspect public abstract class Base { @Pointcut --&gt;Seems to be the problem abstract void method(); public static void main(String args[]){ } } package com.aspectj.test; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; import org.aspectj.lang.annotation.Pointcut; @Aspect public class Sub extends Base{ @Pointcut( "execution(* com.aspectj.test.Base.main(..))" ) void method(){}; @Before("method()") public void test(){ } } The code above shows java.lang.NullPointerException at org.aspectj.weaver.patterns.BasicTokenSource.makeTokenSource (BasicTokenSource.java:84) at org.aspectj.weaver.patterns.PatternParser.&lt;init&gt; (PatternParser.java:1373) at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVisitor.conv ertToPointcutDeclaration(ValidateAtAspectJAnnotationsVisitor.java:493) at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVisitor.visi t(ValidateAtAspectJAnnotationsVisitor.java:188) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse (MethodDeclaration.java:185) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse (TypeDeclaration.java:1183) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.tr averse(CompilationUnitDeclaration.java:339) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.beforeAnalysing (AjCompilerAdapter.java:154) at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$before$org_aspectj_ajdt_ internal_compiler_CompilerAdapter$7$db78446d(CompilerAdapter.aj:101) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process (Compiler.java:517) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile (Compiler.java:329) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation (AjBuildManager.java:759) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild (AjBuildManager.java:225) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild (AjBuildManager.java:180) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild (AjBuildManager.java:158) at org.aspectj.ajde.internal.CompilerAdapter.compile (CompilerAdapter.java:117) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run (AspectJBuildManager.java:191) The syntax @Pointcut("") is shown as error too. If this is not a bug then a proper message instead of an exception is helpful.
@Pointcut - throws Eclipse 3.1 AJDT 1.3.0.20051102174241 The syntax is shown as error too. If this is not a bug then a proper message instead of an exception is helpful.
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.validateAspectDeclaration(TypeDeclaration),True
tests/multiIncremental/pr114875/base/Base.method(),False,new_method|test_method
tests/multiIncremental/pr114875/base/Base.main(String),False,new_method|test_method
tests/multiIncremental/pr114875/inc1/Sub.method(),False,new_method|test_method
tests/multiIncremental/pr114875/inc1/Sub.test(),False,new_method|test_method
tests/multiIncremental/pr114875/inc2/Base.main(String),False,new_method|test_method
tests/multiIncremental/pr114875/inc2/Base.method(),False,new_method|test_method
tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.testPr114875(),False,new_method|test_method
#####
AspectJ
116626
c7608950f0deb6f9951435f58209ad60aaf28e06
Load-time weaving - exception from the weaver Hi again :-) I'm trying to use loadtime weaving and getting an exception. Please look at the testcase: Java code: ========== public class Test&lt;T&gt; { Set&lt;T&gt; intsSet; public Test() { this.intsSet = new HashSet&lt;T&gt;(); } public &lt;T&gt; T[] getObjs(T[] a) { return intsSet.toArray(a); } public static void main(String[] args) { System.out.println("AAA :-)"); new TTT().foo(); } } class TTT { public void foo() { Test&lt;Object&gt; mt = new Test&lt;Object&gt;(); Object[] arr = mt.getObjs(new Object[]{}); } } Aspect: ======= public privileged aspect TestAspect { pointcut TestToArray(Test mt) : target(mt) &amp;&amp; !within(TestAspect); Object[] around(Test mt, Object[] objs) : TestToArray(mt) &amp;&amp; args(objs) &amp;&amp; execution(Object[] com.mprv.secsph.Test.getObjs(Object[])) { objs = proceed(mt, objs); System.out.println("GO Aspects!"); return objs; } } aop.xml ======= &lt;aspectj&gt; &lt;aspects&gt; &lt;aspect name="com.mprv.secsph.TestAspect"/&gt; &lt;/aspects&gt; &lt;weaver options="-verbose -XlazyTjp -showWeaveInfo"&gt; &lt;include within="com.mprv.*"/&gt; &lt;/weaver&gt; &lt;/aspectj&gt; Program output: ============== AAA :-) info weaving 'com/mprv/secsph/TestAspect' java.lang.NullPointerException at org.aspectj.weaver.tools.WeavingAdaptor$WeavingClassFileProvider.getBytes (WeavingAdaptor.java:390) at org.aspectj.weaver.tools.WeavingAdaptor.getAtAspectJAspectBytes (WeavingAdaptor.java:259) at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass (WeavingAdaptor.java:181) at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:66) at org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform (ClassPreProcessorAgentAdapter.java:52) at sun.instrument.TransformerManager.transform (TransformerManager.java:122) at sun.instrument.InstrumentationImpl.transform (InstrumentationImpl.java:155) at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClass(ClassLoader.java:620) at java.security.SecureClassLoader.defineClass (SecureClassLoader.java:124) at java.net.URLClassLoader.defineClass(URLClassLoader.java:260) at java.net.URLClassLoader.access$100(URLClassLoader.java:56) at java.net.URLClassLoader$1.run(URLClassLoader.java:195) at java.security.AccessController.doPrivileged(Native Method) at java.net.URLClassLoader.findClass(URLClassLoader.java:188) at java.lang.ClassLoader.loadClass(ClassLoader.java:306) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:268) at java.lang.ClassLoader.loadClass(ClassLoader.java:251) at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:319) at com.mprv.secsph.Test.getObjs(Test.java:1) at com.mprv.secsph.TTT.foo(Test.java:34) at com.mprv.secsph.Test.main(Test.java:27) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at com.intellij.rt.execution.application.AppMain.main(AppMain.java:86) GO Aspects! ==== This exception doesn't happen all the time ... but if you will try a few times, you will probably get it. May you can understand what is the problem event without running the test case. Anyway, I took a look at your code, and have a guess (but it's only the guess) - My aspect is in the application classpath. Actually it's in the same package, so may be you are trying to weave the aspect with itself somehow ... Thanks! Misha.
Load-time weaving - exception from the weaver Hi again :-) I'm trying to use weaving and getting an exception. Please look at the testcase: Java code: ========== : =======  ======= Program output: ============== AAA :-) info weaving ' GO Aspects! ==== This exception doesn't happen all the time ... but if you will try a few times, you will probably get it. May you can understand what is the problem event without running the test case. Anyway, I took a look at your code, and have a guess (but it's only the guess) - My aspect is in the application classpath. Actually it's in the same package, so may be you are trying to weave the aspect with itself somehow ... Thanks! Misha.
******
tests/bugs150/pr116626/com/foo/bar/Test.Test(),False,new_method|test_method
tests/bugs150/pr116626/com/foo/bar/Test.getObjs(tests/bugs150/pr116626/com/foo/bar/Test.T[]),False,new_method|test_method
tests/bugs150/pr116626/com/foo/bar/Test.main(String[]),False,new_method|test_method
tests/bugs150/pr116626/com/foo/bar/Test.foo(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.testNPEinWeavingAdaptor_pr116626(),False,new_method|test_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.WeavingClassFileProvider (String, byte[]),True
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.getBytes(),True
#####
AspectJ
115607
9ed75a10abaca8a6c8569ead1b74eaaadc980b07
Incorrect structure model for simple declare @type program? This program: ---8&lt;----- @interface I {} class Simple {} public aspect C { declare @type: Simple : @I; } ---8&lt;----- (all in a file called C.java, open with the AJ editor) when built shows incorrect gutter markers, it shows a double headed arrow on Simple implying that it annotates itself - rather than something outgoing from the declare statement and something incoming on the Simple type.
Incorrect structure model for simple declare @type program? This program: ---8&lt;----- ----- (all in a file, open with the AJ editor) when built shows incorrect gutter markers, it shows a double headed arrow on Simple implying that it annotates itself - rather than something outgoing from the declare statement and something incoming on the Simple type.
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceLocation.getColumn(),True
tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.testSelfBoundGenerics_pr117296(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.testSelfBoundGenerics_pr117296(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.testDeclareAtTypeInStructureModel_pr115607(),False,new_method|test_method
#####
AspectJ
113511
70888ddc862b717646b236db2767e11a586b6157
LTW enhancements Alex, here is the basic patch that is working well before you leave for the weekend ;-) I'll let Matthew post it officially to bugzilla since it was his idea. The earlier return from !enabled is a small addition I made that seems to help further. It would be great to have this in HEAD so I can report performance numbers based on it in part 2 of my article on developerworks ;-) Hope you are enjoying your new addition! Thanks! Index: ClassLoaderWeavingAdaptor.java =================================================================== RCS file: /home/technology/loadtime/src/org/aspectj/weaver/loadtim e/ClassLoaderWeavingAdaptor.java,v retrieving revision 1.18 diff -u -r1.18 ClassLoaderWeavingAdaptor.java --- ClassLoaderWeavingAdaptor.java 19 Oct 2005 13:11:36 -0000 1.18 +++ ClassLoaderWeavingAdaptor.java 21 Oct 2005 16:04:41 -0000 @@ -107,8 +107,13 @@ // register the definitions registerDefinitions(weaver, loader); + if (!enabled) { + return; + } messageHandler = bcelWorld.getMessageHandler(); + bcelWorld.setResolutionLoader((ClassLoader)null);//loader.getParent()); + // after adding aspects weaver.prepareForWeave(); } @@ -148,7 +153,11 @@ definitions.add(DocumentParser.parse(xml)); } } - + if (definitions.isEmpty()) { + enabled = false; + return; + } + // still go thru if definitions is empty since we will configure // the default message handler in there registerOptions(weaver, loader, definitions);
LTW enhancements Alex, here is the basic patch that is working well before you leave for the weekend ;-) I'll let Matthew post it officially to bugzilla since it was his idea. The earlier return from !enabled is a small addition I made that seems to help further. It would be great to have this in HEAD so I can report performance numbers based on it in part 2 of my article on developerworks ;-) Hope you are enjoying your new addition! Thanks! Index: =================================================================== RCS ,v retrieving revision 1.18 diff -u -r1.18 C
******
loadtime/src/org/aspectj/weaver/loadtime/Aj.getWeaver(ClassLoader, IWeavingContext),True
loadtime/src/org/aspectj/weaver/loadtime/Aj.ExplicitlyInitializedClassLoaderWeavingAdaptor(ClassLoaderWeavingAdaptor),False,formatting
loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.initialize(ClassLoader, IWeavingContext),True
loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.registerDefinitions(BcelWeaver, ClassLoader),True
#####
AspectJ
117296
e549651eb81aacce53afc0268fe675fdd93051ec
Stack overflow when using self-bounded generics Hi, This code is a form of "Curiously Recurring Template Pattern" public class PropertySupport&lt;T extends PropertySupport&lt;T&gt;&gt; { } My AJDT project does not accept this though my JDK 5.0 ECLIPSE project does. java.lang.StackOverflowError at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBinding(EclipseFactory.java:197) at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBinding(EclipseFactory.java:281) at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBinding(EclipseFactory.java:281) Thanks, Mohan
Stack overflow when using self-bounded generics Hi, This code is a form of "Curiously Recurring Template Pattern" My AJDT project does not accept this though my JDK 5.0 ECLIPSE project does. Thanks, Mohan
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.fromBinding(TypeBinding),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.fromTypeVariableBinding(TypeVariableBinding),True
tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.testSelfBoundGenerics_pr117296(),False,test_method
tests/src/org/aspectj/systemtest/ajc150/GenericsTests.testSelfBoundGenerics_pr117296(),False,new_method|test_method
#####
AspectJ
117189
a5ac5af396426f2049abe52036748bd344a7d1fe
Contribution: reduce overhead when no aspects define This patch to the ClassLoaderWeavingAdaptor adds two optimizations when enabled is false for the adaptor: it immediately returns false for accept and it also avoids the overhead of constructing a weaver or world. It also contains commented out code that was letting me improve performance by loading reflective proxies instead of creating BCEL objects for a resolution loader (which is currently broken since reflective proxies now require a ReflectionWorld...)
Contribution: reduce overhead when no aspects define This patch to the ClassLoaderWeavingAdaptor adds two optimizations when enabled is false for the adaptor: it immediately returns false for accept and it also avoids the overhead of constructing a weaver or world. It also contains commented out code that was letting me improve performance by loading reflective proxies instead of creating BCEL objects for a resolution loader (which is currently broken since reflective proxies now require a ReflectionWorld...)
******
loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.initialize(ClassLoader, IWeavingContext),True
loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.registerDefinitions(BcelWeaver, ClassLoader),True
loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.parseDefinitions(ClassLoader),False,new_method|test_method
loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.parseDefinitions(ClassLoader),True
registerDefinitions(BcelWeaver, ClassLoader, List),False,new_method|test_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.weaveClass(String, byte[]),True
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.shouldWeave(String name, byte[]),True
#####
AspectJ
114343
4b5e76347445be5180616f5008e52328948b6cf5;2483e609ca9c0d9f5c43b60c0f32d7b9cdf51adc
generics] field-get problems when generic field is used. Hi guys! I've downloaded DEVELOPMENT-20051029200407. There is some issue that I think is still open. Take a look at the example: Java Code: ---------- public class Test1 { Set&lt;Integer&gt; intsSet; public Set&lt;Integer&gt; foo() { return intsSet; } } public class Test2 { Set&lt;Double&gt; dSet; public Set&lt;Double&gt; foo() { return dSet; } } Aspect: ------- public privileged aspect TestAspect { pointcut gettingMemberCollection(Test t) : target(t) &amp;&amp; get(!public Set&lt;Number+&gt; com.*.*) &amp;&amp; !within(TestAspect); Set around(Test t) : gettingMemberCollection(t) { Set s = proceed(t); return s; } } As you can see, I would like to replace access to member Set of something which derives from Number. But the problem is that around advice is stricted to return exact type of the member, and I'm getting the same error as earlier. incompatible return type applying to field-get(java.util.Set com.mprv.secsph.Test.intsSet) incompatible return type applying to field-get(java.util.Set com.mprv.secsph.Test.dSet) In the M2 I just declared the advice this way and it worked fine. May be now, you should allow to declare the advice this way: Set&lt;? extends Number&gt; around(Test t) : gettingMemberCollection(t) { Set s = proceed(t); return s; } Thanks! Misha.
generics] field-get problems when generic field is used. Hi guys! I've downloaded DEVELOPMENT-20051029200407. There is some issue that I think is still open. Take a look at the example: Java Code: ---------- pAs you can see, I would like to replace access to member Set of something which derives from Number. But the problem is that around advice is stricted to return exact type of the member, and I'm getting the same error as earlier. incompatible return type applying to incompatible return type applying to In the M2 I just declared the advice this way and it worked fine. May be now, you should allow to declare the advice this way: Thanks! Misha.
******
tests/bugs150/pr114343/case2/TTT.foo(),False,new_method|test_method
tests/bugs150/pr114343/case2/Test.toArray(T[]),False,new_method|test_method
tests/bugs150/pr114343/case2/TestAspect.TestToArray(Test),False,new_method|test_method
around(Test, Object[]),False,new_method|test_method
main(String[]),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.testFieldGet_pr114343_2(),False,test_method
weaver/src/org/aspectj/weaver/ReferenceType.isAssignableFrom(ResolvedType),True
weaver/src/org/aspectj/weaver/ResolvedType.makeArray(ResolvedType, int),True
Array(String, World, ResolvedType),True
Array(String, String, World, ResolvedType),False,new_method
weaver/src/org/aspectj/weaver/TypeFactory.createTypeFromSignature(String),True
weaver/src/org/aspectj/weaver/World.resolve(UnresolvedType, boolean),True
weaver/src/org/aspectj/weaver/World.resolveToReferenceType(UnresolvedType),True
#####
AspectJ
117681
11ab99f1c46007b084873d1050da2f9e78e43c82
VerifyError when using annotations to define inter-type annotation Using Sun JDK1.5.0_04 Audit.java public interface Audit { public String getLastUpdatedBy(); public void setLastUpdatedBy(String un); } AuditImpl.java public class AuditImpl implements Audit { private String lastUpdatedBy; public String getLastUpdatedBy() { return lastUpdatedBy; } public void setLastUpdatedBy(String un) { lastUpdatedBy = un; } } TestAspect.java import org.aspectj.lang.annotation.*; Test.java @Aspect public class TestAspect { @DeclareParents("Test") public static Audit introduced = new AuditImpl(); } public class Test { public static void main(String[] args) { Test t = new Test(); Audit a = (Audit)t; a.setLastUpdatedBy("username"); System.out.println("Username ="+a.getLastUpdatedBy()); } } files.lst Audit.java AuditImpl.java TestAspect.java Test.java Compiled using the following command d:\aspectj1.5\bin\ajc -classpath "d:\aspectj1.5\lib\aspectjrt.jar" -argfi le files.lst -1.5 d:\aspectj1.5\bin\aj5 Test Exception in thread "main" java.lang.VerifyError: (class: Test, method: setLastUpdatedBy signature: (Ljava/lang/String;)V) Incompatible argument to function d:\aspectj1.5\bin\aj5 -noverify Test Username=
VerifyError when using annotations to define inter-type annotation Using Sun JDK1.5.0_04 A Compiled using the following command  Incompatible argument to function
******
tests/bugs150/pr117681/Audit.getLastUpdatedBy(),False,new_method|test_method
tests/bugs150/pr117681/Audit.setLastUpdatedBy(String),False,new_method|test_method
tests/bugs150/pr117681/AuditImpl.getLastUpdatedBy(),False,new_method|test_method
tests/bugs150/pr117681/AuditImpl.setLastUpdatedBy(String),False,new_method|test_method
tests/bugs150/pr117681/MoodIndicator.getMood(int),False,new_method|test_method
tests/bugs150/pr117681/MoodIndicator.main(String),False,new_method|test_method
tests/bugs150/pr117681/Test..main(String),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.testAtDeclareParents_pr117681(),False,new_method|test_method
weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.mungeMethodDelegate(BcelClassWeaver, MethodDelegateTypeMunger),True
tests/bugs150/pr117681/TestAspect,False,test
#####
AspectJ
115251
e988530d35b027b23a92aa964b0db686b6c8ca07;3da3666d3cb57a6293a4d8aabf201ace00167045;e05df7e5ac7fb91031d8f98d4b93e361918e4b56
BCException when compiling incrementally on constructor-call shadow I get the same BCException when I build incrementally but not after cleaning the project. The code is correct (I think) and runs fine after clean-and-build. AJDT Build id: 20051104134042 AspectJ version: 1.5.0.200510241400 (Sorry if this is another manifestation of a different bug or an AJDT bug.) --------------------------------------------------------------- ----------------- Singleton.java package com.isberg.articles.aop7.patterns; /** * CODE article singleton variant without eager/lazy */ public abstract aspect Singleton&lt;Target&gt; pertypewithin(Target) { private final Object lock = new Object(); private Target singleton; /** * Subaspects define this. All join points must return type Target. */ abstract protected pointcut creation(); pointcut creating() : cflow(within(Singleton+) &amp;&amp; adviceexecution()); Target around() : creation() &amp;&amp; !creating(){ synchronized(lock) { if (singleton == null) { singleton = proceed(); } return singleton; } } } ----------------- SingletonTest.java package com.isberg.articles.aop7.patterns; import junit.framework.TestCase; public class SingletonTest extends TestCase { public void testSingleton() throws Exception { C[] cs = {C.create(), new C(), C.create()}; for (int i = 1; i &lt; cs.length; i++) { assertEquals(cs[0], cs[i]); } } static class C { static C create() {return new C();} C() {} } static aspect A extends Singleton&lt;C&gt; { protected pointcut creation() : execution(static C C.create()) || call(C.new()); } } --------------------------------------------------------------- trouble in:public class com.isberg.articles.aop7.patterns.SingletonTest extends junit.framework.TestCase: public void &lt;init&gt;(): ALOAD_0 // com.isberg.articles.aop7.patterns.SingletonTest this (line 5) INVOKESPECIAL junit.framework.TestCase.&lt;init&gt; ()V constructor-execution(void com.isberg.articles.aop7.patterns.SingletonTest.&lt;init&gt;()) | RETURN constructor-execution(void com.isberg.articles.aop7.patterns.SingletonTest.&lt;init&gt;()) end public void &lt;init&gt;() public void testSingleton() throws java.lang.Exception org.aspectj.weaver.MethodDeclarationLineNumber: 6:142 : method-execution(void com.isberg.articles.aop7.patterns.SingletonTest.testSingleton()) | ICONST_3 (line 7) | ANEWARRAY com.isberg.articles.aop7.patterns.SingletonTest$C | DUP | ICONST_0 | method-call(com.isberg.articles.aop7.patterns.SingletonTest$C com.isberg.articles.aop7.patterns.SingletonTest$C.create()) | | INVOKESTATIC com.isberg.articles.aop7.patterns.SingletonTest$C.create ()Lcom/isberg/articles/aop7/patterns/SingletonTest$C; | method-call(com.isberg.articles.aop7.patterns.SingletonTest$C com.isberg.articles.aop7.patterns.SingletonTest$C.create()) | AASTORE | DUP | ICONST_1 | constructor-call(void com.isberg.articles.aop7.patterns.SingletonTest$C.&lt;init&gt;()) | | NEW com.isberg.articles.aop7.patterns.SingletonTest$C | | DUP | | INVOKESPECIAL com.isberg.articles.aop7.patterns.SingletonTest$C.&lt;init&gt; ()V | constructor-call(void com.isberg.articles.aop7.patterns.SingletonTest$C.&lt;init&gt;()) | AASTORE | DUP | ICONST_2 | method-call(com.isberg.articles.aop7.patterns.SingletonTest$C com.isberg.articles.aop7.patterns.SingletonTest$C.create()) | | INVOKESTATIC com.isberg.articles.aop7.patterns.SingletonTest$C.create ()Lcom/isberg/articles/aop7/patterns/SingletonTest$C; | method-call(com.isberg.articles.aop7.patterns.SingletonTest$C com.isberg.articles.aop7.patterns.SingletonTest$C.create()) | AASTORE | ASTORE_1 | ICONST_1 (line 8) | ISTORE_2 | GOTO L1 | L0: ALOAD_1 // com.isberg.articles.aop7.patterns.SingletonTest$C[] cs (line 9) | ICONST_0 | AALOAD | ALOAD_1 // com.isberg.articles.aop7.patterns.SingletonTest$C[] cs | ILOAD_2 // int i | AALOAD | method-call(void junit.framework.Assert.assertEquals(java.lang.Object, java.lang.Object)) | | INVOKESTATIC com.isberg.articles.aop7.patterns.SingletonTest.assertEquals (Ljava/lang/Object;Ljava/lang/Object;)V | method-call(void junit.framework.Assert.assertEquals(java.lang.Object, java.lang.Object)) | IINC 2 1 // int i (line 8) | L1: ILOAD_2 // int i | ALOAD_1 // com.isberg.articles.aop7.patterns.SingletonTest$C[] cs | ARRAYLENGTH | IF_ICMPLT L0 | RETURN (line 11) method-execution(void com.isberg.articles.aop7.patterns.SingletonTest.testSingleton()) end public void testSingleton() throws java.lang.Exception end public class com.isberg.articles.aop7.patterns.SingletonTest when implementing on shadow constructor-call(void com.isberg.articles.aop7.patterns.SingletonTest$C.&lt;init&gt;()) when weaving type com.isberg.articles.aop7.patterns.SingletonTest when weaving classes when weaving when incrementally building BuildConfig[c:\home\ws\main-31\.metadata\.plugins\org.eclipse.ajdt.core\devworks-fall.generated.lst] #Files=90 org.aspectj.weaver.BCException: Class com.isberg.articles.aop7.patterns.Singleton does not have a method ajc$around$com_isberg_articles_aop7_patterns_Singleton$1$51e13820 with signature (Lorg/aspectj/runtime/internal/AroundClosure;)Ljava/lang/Object; when implementing on shadow constructor-call(void com.isberg.articles.aop7.patterns.SingletonTest$C.&lt;init&gt;()) when weaving type com.isberg.articles.aop7.patterns.SingletonTest when weaving classes when weaving when incrementally building BuildConfig[c:\home\ws\main-31\.metadata\.plugins\org.eclipse.ajdt.core\devworks-fall.generated.lst] #Files=90 at org.aspectj.weaver.bcel.LazyClassGen.getLazyMethodGen(LazyClassGen.java:1161) at org.aspectj.weaver.bcel.LazyClassGen.getLazyMethodGen(LazyClassGen.java:1146) at org.aspectj.weaver.bcel.BcelShadow.weaveAroundInline(BcelShadow.java:1973) at org.aspectj.weaver.bcel.BcelAdvice.implementOn(BcelAdvice.java:211) at org.aspectj.weaver.Shadow.implementMungers(Shadow.java:514) at org.aspectj.weaver.Shadow.implement(Shadow.java:391) at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:1782) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:394) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:98) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1478) at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1443) at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1217) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1039) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:300) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:178) at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:759) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:249) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:158) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)
when compiling incrementally on shadow I get the same BCException when I build incrementally but not after cleaning the project. The code is correct (I think) and runs fine after clean-and-build. AJDT Build id: 20051104134042 AspectJ version: 1.5.0.200510241400 (Sorry if this is another manifestation of a different bug or an AJDT bug.) --------------------------------------------------------------- ----------------- --------------------------------------------------------------- trouble in: when implementing on shadow when weaving type when weaving classes when weaving when incrementally building does not have a method a when implementing on shadow when weaving type when weaving classes when weaving when incrementally building BuildConfig
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.lookupPerClauseKind(ReferenceBinding),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.addSourceTypeBinding(SourceTypeBinding, CompilationUnitDeclaration),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.getPerClause(),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.doBuild(AjBuildConfig, IMessageHandler, boolean),False,formatting
tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.setUp(),False,test_method
tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.setUp(),False,test_method
tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.testPr115251(),False,new_method|test_method
tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.testPr111779(),False,test_method|other_bug
testPr113531(),False,test_method|other_bug
weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.addOrReplaceAspect(ResolvedType),True
weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.addOrReplaceDescendantsOf(ResolvedType),False,new_method
weaver/src/org/aspectj/weaver/ReferenceType.ReferenceType(ResolvedType, ResolvedType[], World),True
weaver/src/org/aspectj/weaver/ReferenceType.addDependentType(ReferenceType),False,new_method
weaver/src/org/aspectj/weaver/ReferenceType.setDelegate(ReferenceTypeDelegate),True
weaver/src/org/aspectj/weaver/ResolvedPointcutDefinition.parameterizedWith(UnresolvedType[], ResolvedType, boolean),True
weaver/src/org/aspectj/weaver/bcel/BcelWeaver.weave(IClassFileProvider),False,formatting
weaver/src/org/aspectj/weaver/patterns/CflowPointcut.concretize1(ResolvedType, ResolvedType, IntMap),True
tests/multiIncremental/PR115251/base/src/pack/C1.testMethod(),False,new_method|test_method
#####
AspectJ
116949
dd9a9b284ab44b14ea3735d2663e85afb861220b
[waitingOnAJDTdrop]Exception thrown from AspectJ compiler java.lang.ClassCastException at org.aspectj.weaver.bcel.BcelClassWeaver.checkForOverride (BcelClassWeaver.java:607) at org.aspectj.weaver.bcel.BcelClassWeaver.calculateAnyRequiredBridgeMethods (BcelClassWeaver.java:676) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1537) at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1485) at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1266) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1088) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave (AjCompilerAdapter.java:300) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling (AjCompilerAdapter.java:178) at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspect j_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile (Compiler.java:367) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation (AjBuildManager.java:809) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild (AjBuildManager.java:254) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild (AjBuildManager.java:163) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run (AspectJBuildManager.java:191) trouble in: public class ts.simul.client.AbstractClient$OptionSetter extends ts.util.CmdLineProgram$OptionSetterBase: final ts.simul.client.AbstractClient this$0 private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_0 public void &lt;init&gt;(ts.simul.client.AbstractClient) org.aspectj.weaver.MethodDeclarationLineNumber: 59:1411 : ALOAD_0 // ts.simul.client.AbstractClient$OptionSetter this (line 60) ALOAD_1 PUTFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 Lts/simul/client/AbstractClient; ALOAD_0 // ts.simul.client.AbstractClient$OptionSetter this (line 59) ALOAD_1 INVOKESPECIAL ts.util.CmdLineProgram$OptionSetterBase.&lt;init&gt; (Lts/util/CmdLineProgram;)V constructor-execution(void ts.simul.client.AbstractClient$OptionSetter.&lt;init&gt; (ts.simul.client.AbstractClient)) | RETURN constructor-execution(void ts.simul.client.AbstractClient$OptionSetter.&lt;init&gt; (ts.simul.client.AbstractClient)) end public void &lt;init&gt;(ts.simul.client.AbstractClient) public boolean setOption_file(String) throws ts.util.IllegalProgramArgumentException org.aspectj.weaver.MethodDeclarationLineNumber: 62:1469 : method-execution(boolean ts.simul.client.AbstractClient$OptionSetter.setOption_file(java.lang.String)) | ALOAD_1 // java.lang.String optParam (line 65) | method-call(int java.lang.String.length()) | | INVOKEVIRTUAL java.lang.String.length ()I | method-call(int java.lang.String.length()) | IFLE L1 | ALOAD_0 // ts.simul.client.AbstractClient$OptionSetter this (line 66) | GETFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 Lts/simul/client/AbstractClient; | ALOAD_1 // java.lang.String optParam | PUTFIELD ts.simul.client.AbstractClient.fileName Ljava/lang/String; | NEW java.io.File (line 67) | DUP | ALOAD_0 // ts.simul.client.AbstractClient$OptionSetter this | GETFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 Lts/simul/client/AbstractClient; | GETFIELD ts.simul.client.AbstractClient.fileName Ljava/lang/String; | constructor-call(void java.io.File.&lt;init&gt;(java.lang.String)) | | INVOKESPECIAL java.io.File.&lt;init&gt; (Ljava/lang/String;)V | constructor-call(void java.io.File.&lt;init&gt;(java.lang.String)) | ASTORE_2 | ALOAD_2 // java.io.File file (line 68) | method-call(boolean java.io.File.exists()) | | INVOKEVIRTUAL java.io.File.exists ()Z | method-call(boolean java.io.File.exists()) | IFNE L0 | NEW ts.util.IllegalProgramArgumentException (line 69) | DUP | NEW java.lang.StringBuilder | DUP | LDC "Cannot find file: [" | constructor-call(void java.lang.StringBuilder.&lt;init&gt;(java.lang.String)) | | INVOKESPECIAL java.lang.StringBuilder.&lt;init&gt; (Ljava/lang/String;)V | constructor-call(void java.lang.StringBuilder.&lt;init&gt;(java.lang.String)) | ALOAD_0 // ts.simul.client.AbstractClient$OptionSetter this | GETFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 Lts/simul/client/AbstractClient; | GETFIELD ts.simul.client.AbstractClient.fileName Ljava/lang/String; | method-call(java.lang.StringBuilder java.lang.StringBuilder.append (java.lang.String)) | | INVOKEVIRTUAL java.lang.StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder; | method-call(java.lang.StringBuilder java.lang.StringBuilder.append (java.lang.String)) | LDC "]" | method-call(java.lang.StringBuilder java.lang.StringBuilder.append (java.lang.String)) | | INVOKEVIRTUAL java.lang.StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder; | method-call(java.lang.StringBuilder java.lang.StringBuilder.append (java.lang.String)) | method-call(java.lang.String java.lang.StringBuilder.toString()) | | INVOKEVIRTUAL java.lang.StringBuilder.toString () Ljava/lang/String; | method-call(java.lang.String java.lang.StringBuilder.toString()) | constructor-call(void ts.util.IllegalProgramArgumentException.&lt;init&gt; (java.lang.String)) | | INVOKESPECIAL ts.util.IllegalProgramArgumentException.&lt;init&gt; (Ljava/lang/String;)V | constructor-call(void ts.util.IllegalProgramArgumentException.&lt;init&gt; (java.lang.String)) | ATHROW | L0: ICONST_1 (line 70) | IRETURN | L1: ICONST_0 (line 73) | IRETURN method-execution(boolean ts.simul.client.AbstractClient$OptionSetter.setOption_file(java.lang.String)) end public boolean setOption_file(String) throws ts.util.IllegalProgramArgumentException public boolean setOption_class(String) throws ts.util.IllegalProgramArgumentException org.aspectj.weaver.MethodDeclarationLineNumber: 76:1971 : method-execution(boolean ts.simul.client.AbstractClient$OptionSetter.setOption_class(java.lang.String)) | ALOAD_1 // java.lang.String optParam (line 79) | method-call(int java.lang.String.length()) | | INVOKEVIRTUAL java.lang.String.length ()I | method-call(int java.lang.String.length()) | IFLE L1 | ALOAD_0 // ts.simul.client.AbstractClient$OptionSetter this (line 80) | GETFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 Lts/simul/client/AbstractClient; | ALOAD_1 // java.lang.String optParam | PUTFIELD ts.simul.client.AbstractClient.className Ljava/lang/String; | catch ts.simul.SimulationException -&gt; E0 | | ALOAD_0 // ts.simul.client.AbstractClient$OptionSetter this (line 82) | | GETFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 Lts/simul/client/AbstractClient; | | ALOAD_0 // ts.simul.client.AbstractClient$OptionSetter this | | GETFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 Lts/simul/client/AbstractClient; | | GETFIELD ts.simul.client.AbstractClient.className Ljava/lang/String; | | method-call(java.lang.Class ts.simul.SceneFactory.getSceneClass (java.lang.String)) | | | INVOKESTATIC ts.simul.SceneFactory.getSceneClass (Ljava/lang/String;)Ljava/lang/Class; | | method-call(java.lang.Class ts.simul.SceneFactory.getSceneClass (java.lang.String)) | | PUTFIELD ts.simul.client.AbstractClient.sceneClass Ljava/lang/Class; | | ALOAD_0 // ts.simul.client.AbstractClient$OptionSetter this (line 83) | | GETFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 Lts/simul/client/AbstractClient; | | method-call(void ts.simul.client.AbstractClient.setBeanInfoSearchPath()) | | | INVOKESTATIC ts.simul.Architecture.aspectOf () Lts/simul/Architecture; | | | GETSTATIC ts.simul.client.AbstractClient$OptionSetter.ajc$tjp_0 Lorg/aspectj/lang/JoinPoint$StaticPart; | | | INVOKEVIRTUAL ts.simul.Architecture.ajc$before$ts_simul_Architecture$1$ae285a4d (Lorg/aspectj/lang/JoinPoint$StaticPart;)V | | | INVOKEVIRTUAL ts.simul.client.AbstractClient.setBeanInfoSearchPath ()V | | method-call(void ts.simul.client.AbstractClient.setBeanInfoSearchPath()) | | GOTO L0 | catch ts.simul.SimulationException -&gt; E0 | E0: ASTORE_2 (line 85) | NEW ts.util.IllegalProgramArgumentException (line 86) | DUP | ALOAD_2 // ts.simul.SimulationException e | method-call(java.lang.String ts.simul.SimulationException.getMessage()) | | INVOKEVIRTUAL ts.simul.SimulationException.getMessage () Ljava/lang/String; | method-call(java.lang.String ts.simul.SimulationException.getMessage()) | constructor-call(void ts.util.IllegalProgramArgumentException.&lt;init&gt; (java.lang.String)) | | INVOKESPECIAL ts.util.IllegalProgramArgumentException.&lt;init&gt; (Ljava/lang/String;)V | constructor-call(void ts.util.IllegalProgramArgumentException.&lt;init&gt; (java.lang.String)) | ATHROW | L0: ICONST_1 (line 88) | IRETURN | L1: ICONST_0 (line 91) | IRETURN method-execution(boolean ts.simul.client.AbstractClient$OptionSetter.setOption_class(java.lang.String)) end public boolean setOption_class(String) throws ts.util.IllegalProgramArgumentException public boolean setOption_name(String) org.aspectj.weaver.MethodDeclarationLineNumber: 94:2593 : method-execution(boolean ts.simul.client.AbstractClient$OptionSetter.setOption_name(java.lang.String)) | ALOAD_0 // ts.simul.client.AbstractClient$OptionSetter this (line 96) | GETFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 Lts/simul/client/AbstractClient; | ALOAD_1 // java.lang.String optParam | PUTFIELD ts.simul.client.AbstractClient.sceneName Ljava/lang/String; | ICONST_1 (line 97) | IRETURN method-execution(boolean ts.simul.client.AbstractClient$OptionSetter.setOption_name(java.lang.String)) end public boolean setOption_name(String) public boolean setOption_actors(String) org.aspectj.weaver.MethodDeclarationLineNumber: 100:2739 : method-execution(boolean ts.simul.client.AbstractClient$OptionSetter.setOption_actors(java.lang.String)) | catch java.lang.NumberFormatException -&gt; E0 | | ALOAD_1 // java.lang.String optParam (line 103) | | method-call(int java.lang.Integer.parseInt(java.lang.String)) | | | INVOKESTATIC java.lang.Integer.parseInt (Ljava/lang/String;) I | | method-call(int java.lang.Integer.parseInt(java.lang.String)) | | ISTORE_2 | | GOTO L0 | catch java.lang.NumberFormatException -&gt; E0 | E0: ASTORE_2 // int n (line 105) | ICONST_0 (line 106) | IRETURN | L0: ICONST_1 (line 108) | IRETURN method-execution(boolean ts.simul.client.AbstractClient$OptionSetter.setOption_actors(java.lang.String)) end public boolean setOption_actors(String) end public class ts.simul.client.AbstractClient$OptionSetter when weaving type ts.simul.client.AbstractClient$OptionSetter when weaving classes when weaving when incrementally building BuildConfig [c:\Projects\eclipse\.metadata\.plugins\org.eclipse.ajdt.core\TS.generated.lst] #Files=79
[]Exception thrown from AspectJ compiler when weaving type when weaving classes when weaving when incrementally building BuildConfig
******
weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.checkForOverride(ResolvedType typeToCheck,String mname,String mparams,String mrettype,int mmods,String mpkg,UnresolvedType[]),True
#####
AspectJ
112736
bcabce0283aec3c44a99000b3970bd880fee72a0
Bogus Compiler Warnings when Converting file extensions If you convert file extensions between .aj and .java, the compiler doesn't properly clear its symbol table, generating bogus warnings about conflicting inter-type declarations. It should avoid this. Work around: full rebuild. See screenshot for an example. After recompiling the "errors" go away...
Bogus Compiler Warnings when Converting file extensions If you convert file extensions between .aj and .java, the compiler doesn't properly clear its symbol table, generating bogus warnings about conflicting inter-type declarations. It should avoid this. Work around: full rebuild. See screenshot for an example. After recompiling the "errors" go away...
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AbstractStateListener.detectedClassChangeInThisDir(File),False,new_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AbstractStateListener.aboutToCompareClasspaths(List oldClasspath, List),False,new_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AbstractStateListener.pathChangeDetected(),False,new_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AbstractStateListener.detectedAspectDeleted(File),False,new_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AbstractStateListener.buildSuccessful(boolean),False,new_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.prepareForNextBuild(AjBuildConfig),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.processDeletedFiles(Set),False,new_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/IStateListener.detectedAspectDeleted(File),False,new_method
tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.testPr112736(),False,new_method|test_method
tests/src/org/aspectj/systemtest/incremental/IncrementalTests,False,test
tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed,False,test
#####
AspectJ
118192
b6980f2f7b2697e41b454a16d3a7bd1e0135aa8d;97b5f52b520f534ac712d1ce3cff7b6ed5cca14f
Missing superclass for java.io.Serializable in reflection 1.5 delegate impl See attached patch for a failing junit test case.
Missing superclass for in reflection 1.5 delegate impl See attached patch for a failing junit test case.
******
weaver/src/org/aspectj/weaver/UnresolvedType.getTypekind(),False,new_method
weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.testGenericInterfaceSuperclass_ReflectionWorldResolution(),False,test_method
weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.testSerializableSuperclass(),False,new_method
weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.testSubinterfaceSuperclass(),False,new_method
weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.testVoidSuperclass(),False,new_method
weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.testIntSuperclass(),False,new_method
weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.testGenericInterfaceSuperclass_BcelWorldResolution(),False,new_method
weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.testGenericInterfaceSuperclass_ReflectionWorldResolution(),False,new_method
weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegate.getSuperclass(),True
weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.testGenericInterfaceSuperclass_ReflectionWorldResolution(),False,new_method|test_method
weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.getSuperclass(),False,test_method
#####
AspectJ
118599
8098a25607df730cad497c286c9674609b1d3144
Ambiguous method error when weaving in binary aspects Configuration: - Eclipse 3.1.1 - AJDT 1.3.0.20051129155513 Problem Description: Project A defines an interface with static aspect to provide a default implementation: public interface Attributable { void setAttribute(String name, Object attribute); Object getAttribute(String name); static aspect DefImpl { private Map&lt;String,Object&gt; Attributable.attributes = new HashMap&lt;String,Object&gt;(); public void Attributable.setAttribute(String name, Object attribute) { this.attributes.put(name, attribute); } public Object Attributable.getAttribute(String name) { return this.attributes.get(name); } } } Project A generates a JAR that gets used in Project B on both the Java Build Path and the AspectJ Aspect Path. Project B contains the following implementing class: public class AnAttributedClass implements Attributable { public void doSomething() { this.setAttribute("foo", "bar"); } } This results in the compile error "The method setAttribute(String,Object) is ambiguous for the type AnAttributedClass". Please note that using the aspected interface within Project A when implementing classes does not cause said compiler error. With best regards, Christoph Cenowa
Ambiguous method error when weaving in binary aspects Configuration: - Eclipse 3.1.1 - AJDT 1.3.0.20051129155513 Problem Description: Project A defines an interface with static aspect to provide a default implementation: Project A generates a JAR that gets used in Project B on both the Java Build Path and the AspectJ Aspect Path. Project B contains the following implementing class: This results in the compile error "The method is ambiguous for the type ". Please note that using the aspected interface within Project A when implementing classes does not cause said compiler error. With best regards, Christoph Cenowa
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMemberFinder.addInterTypeMethod(MethodBinding),True
#####
AspectJ
117882
b17970f20c9040c3455a02b353a8e7fbc1914024;1b111328220bc522194ecc7361f282d169d781f3
[waiting-on-build] NullPointerException with declare annotations and incremental compilation Test program included and stack trace shown below: java.lang.NullPointerException at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.doDeclareAnnotations(AjLookupEnvironment.java:742) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:556) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:483) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.doPendingWeaves(AjLookupEnvironment.java:350) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:177) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:809) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:254) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:163) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) NullPointerException thrown: null
[waiting-on-build] with declare annotations and incremental compilation Test program included and stack trace shown below: 
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.doDeclareAnnotations(DeclareAnnotation, SourceTypeBinding, boolean),True
isAnnotationTargettingSomethingOtherThanAnnotationOrNormal(long),False,new_method
weaver/src/org/aspectj/weaver/FakeAnnotation.FakeAnnotation(String, String, boolean),False,new_method
weaver/src/org/aspectj/weaver/FakeAnnotation.getTypeName(),False,new_method
weaver/src/org/aspectj/weaver/FakeAnnotation.getTypeSignature(),False,new_method
weaver/src/org/aspectj/weaver/FakeAnnotation.addElementNameValuePair(ElementNameValuePair),False,new_method
weaver/src/org/aspectj/weaver/FakeAnnotation.dump(DataOutputStream),False,new_method
weaver/src/org/aspectj/weaver/FakeAnnotation.getTypeIndex(),False,new_method
weaver/src/org/aspectj/weaver/FakeAnnotation.getValues(),False,new_method
weaver/src/org/aspectj/weaver/FakeAnnotation.isRuntimeVisible(),False,new_method
weaver/src/org/aspectj/weaver/FakeAnnotation.isRuntimeVisible(boolean),False,new_method
weaver/src/org/aspectj/weaver/FakeAnnotation.toShortString(),False,new_method
weaver/src/org/aspectj/weaver/FakeAnnotation.toString(),False,new_method
bcel-builder/src/org/aspectj/apache/bcel/classfile/annotation/Annotation.getTypeSignature(),False,changed_to_final
bcel-builder/src/org/aspectj/apache/bcel/classfile/annotation/Annotation.getTypeName(),False,changed_to_not_final
#####
AspectJ
117209
551b9ca14c28b843c1dbbc14a48427bf4bb9f097
"Runtime error - Stack size too large, Bug#69706 related." AspectJ compiler version: 1.5M5 AJDT plugin version: 1.3.0 This is the same error as reported by Bug#69706, even the bug is resolved I'm still experiencing problem by using the classes attached at the bottom. // RUNTIME ERROR MESSAGE ======================== Exception in thread "main" java.lang.VerifyError: (class: DefaultInterfaceImplementationRecipe, method: &lt;clinit&gt; signature: ()V) Stack size too large at MyClass_ch16.main(MyClass_ch16.java:15) // MyClass_ch16.java ==================== public class MyClass_ch16 { public void foo(int number, String name) { System.out.println("Inside foo (int, String) with args: " + number + ":" + name); } public static void main(String[] args) { // Create an instance of MyClass MyInterface_ch16 myObject = (MyInterface_ch16)new MyClass_ch16 (); // Make the call to foo myObject.bar("Russ"); } } //MyInterface_ch16.java ======================= public interface MyInterface_ch16 { public void bar(String name); } // DefaultInterfaceImplementationRecipe.aj ========================================== public aspect DefaultInterfaceImplementationRecipe { declare parents : MyClass_ch16 implements MyInterface_ch16; // Declare the default implementation of the bar method public void MyInterface_ch16.bar(String name) { System.out.println("bar(String) called on " + this); } }
"Runtime error - Stack size too large, Bug#69706 related." AspectJ compiler version: 1.5M5 AJDT plugin version: 1.3.0 This is the same error as reported by Bug#69706, even the bug is resolved I'm still experiencing problem by using the classes attached at the bottom. // RUNTIME ERROR MESSAGE ========================  ==================== 
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.installGlobals(AjBuildConfig),True
tests/multiIncremental/pr117209/base/src/Aspect.main(String),False,new_method|test_method
tests/multiIncremental/pr117209/base/src/Aspect.m(),False,new_method|test_method
tests/multiIncremental/pr117209/base/src/DefaultInterfaceImplementationRecipe.MyInterface_ch16.bar(String),False,new_method|test_method
tests/multiIncremental/pr117209/base/src/MyClass_ch16.foo(int, String),False,new_method|test_method
tests/multiIncremental/pr117209/base/src/MyClass_ch16.main(String[]),False,new_method|test_method
tests/multiIncremental/pr117209/base/src/MyInterface_ch16.bar(String),False,new_method|test_method
tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.configureNonStandardCompileOptions(String),False,new_method|test_method
tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.setNonStandardOptions(String),False,new_method|test_method
tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.reset(),False,new_method|test_method
tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.build(String, String),False,test_method
getNonStandardOptions(),False,test_method
tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.testPr117209(),False,new_method|test_method
tests/multiIncremental/pr117209/base/src/Broken,False,test
#####
AspectJ
118715
1e1bbb3f2e7aab4757d715d76730cb68cceb3b87
Load Time Weaving wipes out Xlint files if no Xlint values In ClassLoaderWeavingAdaptor if weaverOption.lint is null, then a loaded Xlint properties file gets overwritten by the default Xlint properties. See attached patch to fix this problem.
Load Time Weaving wipes out Xlint files if no Xlint values In if .lint is null, then a loaded Xlint properties file gets overwritten by the default Xlint properties. See attached patch to fix this problem.
******
loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.registerOptions(BcelWeaver, ClassLoader, List),True
testing/newsrc/org/aspectj/testing/OutputSpec.matchAgainst(String),True
testing/newsrc/org/aspectj/testing/RunSpec.getXlintFile(),False,new_method
testing/newsrc/org/aspectj/testing/RunSpec.setXlintFile(String),False,new_method
testing/newsrc/org/aspectj/testing/RunSpec.copyXlintFile(File),False,new_method
testing/newsrc/org/aspectj/testing/RunSpec.execute(AjcTestCase),True
testing/newsrc/org/aspectj/testing/XMLBasedAjcTestCase.getDigester(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/ltw/LTWTests.testXlintfileEmpty(),False,test_method
tests/src/org/aspectj/systemtest/ajc150/ltw/LTWTests.testXlintfileMissing(),False,test_method
tests/src/org/aspectj/systemtest/ajc150/ltw/LTWTests.testXlintWarningAdviceDidNotMatchSuppressed(),False,test_method
tests/src/org/aspectj/systemtest/ajc150/ltw/LTWTests.testXlintfile(),False,test_method
tests/src/org/aspectj/systemtest/ajc150/ltw/LTWTests.testXlintDefault(),False,test_method
tests/src/org/aspectj/systemtest/ajc150/ltw/LTWTests.testXlintWarning(),False,test_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.warn(String, Throwable),True
#####
AspectJ
119543
9b8a8df4b408e5a10331f7e7f2ff64a4e4c1e1bc
"[waiting-on-build] StringIndexOutOfBoundsException, perhaps due to nested aspects and targets" Code and exception below. Same result for HEAD and AspectJ 1.5.0.20051206103951 via AJDT. ------------------------------- bugs/CachedToString.java package bugs; import java.lang.ref.SoftReference; import junit.framework.TestCase; public class CachedToString { /** * @param args */ public static void main(String[] args) { new CacheGetterTest().testToString(); } public static class CacheGetterTest extends TestCase { static boolean runAdvice; public void testToString() { RandomToString me = new RandomToString (); runAdvice = false; String one = me.toString(); String two = me.toString(); assertFalse(one.equals(two)); runAdvice = true; one = me.toString(); two = me.toString(); assertTrue(one.equals(two)); } static class RandomToString { static aspect CacheToString extends CachedItem&lt;String&gt; { public pointcut context() : if(runAdvice); public pointcut caching() : execution(String RandomToString.toString()); } Random random = new Random(-1); public String toString() { return "" + random.nextFloat(); } } } public abstract static aspect CachedItem&lt;Result&gt; pertarget(results()){ SoftReference&lt;Result&gt; cache; boolean nullCache; // CODE writing pointcut trifecta separate context if extended and errors // getcode declaring-pointcuts-to-extend-with-caching START /** * Define join points to cache. * Must override, with staticly-determinable pointcuts * that pick out join points that are permitted. */ protected abstract pointcut caching(); /** ok to use Result field-get or return value */ private pointcut permitted() : get(Result *) || execution(Result *()) || call(Result *()) || call(Result.new(..)); /** Subaspects may add dynamic tests for the join points. */ pointcut context() : !disabled(); private pointcut disabled(); // fyi, undefined == none // getcode results START /** the pointcut composed from the user, as permitted, with context */ pointcut results() : caching() &amp;&amp; permitted() &amp;&amp; context(); // getcode results END Result around() : results() { // ... } // getcode declaring-pointcuts-to-extend-with-caching END Result result; if (nullCache) { result = null; } else if ((null == cache) || (null == (result = cache.get()))){ result = proceed(); if (null == result) { nullCache = true; } else { cache = new SoftReference(result); } } return result; } } } ------------------------------- exception C:\home\ws\main-31\my-ajbugs\aspectj-src\bugs\CachedToString.java [error] Internal compiler error java.lang.StringIndexOutOfBoundsException: String index out of range: -2 at java.lang.String.substring(String.java:1768) at org.aspectj.weaver.TypeFactory.createTypeFromSignature(TypeFactory.java:86) at org.aspectj.weaver.UnresolvedType.forSignature(UnresolvedType.java:426) at org.aspectj.weaver.UnresolvedType.getOutermostType(UnresolvedType.java:601) at org.aspectj.weaver.ResolvedType.isVisible(ResolvedType.java:1259) at org.aspectj.weaver.ResolvedType.addPointcutsResolvingConflicts(ResolvedType.java:1743) at org.aspectj.weaver.ResolvedType.getExposedPointcuts(ResolvedType.java:1716) at org.aspectj.weaver.ResolvedType.getExposedPointcuts(ResolvedType.java:1710) at org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.checkPointcutDeclarations(EclipseSourceType.java:293) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.resolvePointcutDeclarations(AjLookupEnvironment.java:414) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.resolvePointcutDeclarations(AjLookupEnvironment.java:419) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.resolvePointcutDeclarations(AjLookupEnvironment.java:419) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.resolvePointcutDeclarations(AjLookupEnvironment.java:419) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:231) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:156) at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112) at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60) at org.aspectj.tools.ajc.Main.run(Main.java:326) at org.aspectj.tools.ajc.Main.runMain(Main.java:240) at org.aspectj.tools.ajc.Main.main(Main.java:83) (no source information available) ABORT Exception thrown from AspectJ DEVELOPMENT This might be logged as a bug already -- find current bugs at http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler Bugs for exceptions thrown have titles File:line from the top stack, e.g., "SomeFile.java:243" If you don't find the exception below in a bug, please add a new bug at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ To make the bug a priority, please include a test program that can reproduce this exception. String index out of range: -2 when resolving pointcut declarations CachedToString when completing type bindings when batch building with classpath: c:\home\apps\jdk15\jre\lib\ext\dnsns.jar;c:\home\apps\jdk15\jre\lib\ext\localedata.jar;c:\home\apps\jdk15\jre\lib\ext\sunjce_provider.jar;c:\home\apps\jdk15\jre\lib\ext\sunpkcs11.jar;C:\home\ws\main-31\lib\junit\junit.jar;C:\home\wes\dev\tools\aspectj-1.5\lib\aspectjrt.jar; String index out of range: -2 java.lang.StringIndexOutOfBoundsException: String index out of range: -2 at java.lang.String.substring(String.java:1768) at org.aspectj.weaver.TypeFactory.createTypeFromSignature(TypeFactory.java:86) at org.aspectj.weaver.UnresolvedType.forSignature(UnresolvedType.java:426) at org.aspectj.weaver.UnresolvedType.getOutermostType(UnresolvedType.java:601) at org.aspectj.weaver.ResolvedType.isVisible(ResolvedType.java:1259) at org.aspectj.weaver.ResolvedType.addPointcutsResolvingConflicts(ResolvedType.java:1743) at org.aspectj.weaver.ResolvedType.getExposedPointcuts(ResolvedType.java:1716) at org.aspectj.weaver.ResolvedType.getExposedPointcuts(ResolvedType.java:1710) at org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.checkPointcutDeclarations(EclipseSourceType.java:293) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.resolvePointcutDeclarations(AjLookupEnvironment.java:414) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.resolvePointcutDeclarations(AjLookupEnvironment.java:419) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.resolvePointcutDeclarations(AjLookupEnvironment.java:419) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.resolvePointcutDeclarations(AjLookupEnvironment.java:419) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:231) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:156) at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112) at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60) at org.aspectj.tools.ajc.Main.run(Main.java:326) at org.aspectj.tools.ajc.Main.runMain(Main.java:240) at org.aspectj.tools.ajc.Main.main(Main.java:83) 1 fail|abort, 1 error Signal 127
"[waiting-on-build], perhaps due to nested aspects and targets" Code and exception below. Same result for HEAD and AspectJ 1.5.0.20051206103951 via AJDT. ------------------------------- (no source information available) ABORT Exception thrown from AspectJ DEVELOPMENT This might be logged as a bug already -- find current bugs at http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler Bugs for exceptions thrown have titles File:line from the top stack, e.g., "SomeFile.java:243" If you don't find the exception below in a bug, please add a new bug at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ To make the bug a priority, please include a test program that can reproduce this exception. String index out of range: -2 when resolving pointcut declarations when completing type bindings when batch building with classpath: error Signal 127
******
weaver/src/org/aspectj/weaver/UnresolvedType.getOutermostType(),True
#####
AspectJ
109614
94159f9e80233497e02899c91a126ea5a3b605cc
[waiting-on-build] [iajc.task] java.lang.RuntimeException: Ranges must be updated with an enclosing instructionList I am getting following error when compiling code using iajc ant task: [iajc.task] trouble in: [iajc.task] public class admin.modelbean.AdminUserMB extends web.FormSupport: [iajc.task] private static final org.apache.log4j.Logger log .... (Ljava/lang/String;)Ljava/lang/StringBuffer; [iajc.task] | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.String)) [iajc.task] | LDC_W "}" (line 249) [iajc.task] | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.String)) [iajc.task] | | INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/String;)Ljava/lang/StringBuffer; [iajc.task] | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.String)) [iajc.task] | method-call(java.lang.String java.lang.StringBuffer.toString()) [iajc.task] | | INVOKEVIRTUAL java.lang.StringBuffer.toString ()Ljava/lang/String; (line 236) [iajc.task] | method-call(java.lang.String java.lang.StringBuffer.toString()) [iajc.task] | ARETURN [iajc.task] method-execution(java.lang.String admin.modelbean.AdminUserMB.toString()) [iajc.task] end public String toString() [iajc.task] end public class admin.modelbean.AdminUserMB [iajc.task] java.lang.RuntimeException: Ranges must be updated with an enclosing instructionList [iajc.task] at org.aspectj.weaver.bcel.Range.updateTarget(Range.java:170) [iajc.task] at org.aspectj.weaver.bcel.BcelShadow.retargetFrom(BcelShadow.java:235) [iajc.task] at org.aspectj.weaver.bcel.BcelShadow.deleteNewAndDup(BcelShadow.java:212) [iajc.task] at org.aspectj.weaver.bcel.BcelShadow.prepareForMungers(BcelShadow.java:252) [iajc.task] at org.aspectj.weaver.Shadow.implement(Shadow.java:374) [iajc.task] at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:1754) [iajc.task] at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:393) [iajc.task] at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:96) [iajc.task] at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1372) [iajc.task] at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1337) [iajc.task] at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1114) [iajc.task] at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1001) [iajc.task] at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:286) [iajc.task] at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:165) [iajc.task] at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70) [iajc.task] at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367) [iajc.task] at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:728) [iajc.task] at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:206) [iajc.task] at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:140) [iajc.task] at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112) [iajc.task] at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60) [iajc.task] at org.aspectj.tools.ajc.Main.run(Main.java:324) [iajc.task] at org.aspectj.tools.ajc.Main.runMain(Main.java:238) [iajc.task] at org.aspectj.tools.ajc.Main.main(Main.java:82) [iajc.task] ABORT [iajc.task] [iajc.task] Exception thrown from AspectJ 1.5.0_M3a [iajc.task] This might be logged as a bug already -- find current bugs at [iajc.task] http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler [iajc.task] Bugs for exceptions thrown have titles File:line from the top stack, [iajc.task] e.g., "SomeFile.java:243" [iajc.task] If you don't find the exception below in a bug, please add a new bug [iajc.task] at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ [iajc.task] To make the bug a priority, please include a test program [iajc.task] that can reproduce this exception. [iajc.task] Ranges must be updated with an enclosing instructionList [iajc.task] Ranges must be updated with an enclosing instructionList [iajc.task] java.lang.RuntimeException: Ranges must be updated with an enclosing instructionList [iajc.task] at org.aspectj.weaver.bcel.Range.updateTarget(Range.java:170) [iajc.task] at org.aspectj.weaver.bcel.BcelShadow.retargetFrom(BcelShadow.java:235) [iajc.task] at org.aspectj.weaver.bcel.BcelShadow.deleteNewAndDup(BcelShadow.java:212) [iajc.task] at org.aspectj.weaver.bcel.BcelShadow.prepareForMungers(BcelShadow.java:252) [iajc.task] at org.aspectj.weaver.Shadow.implement(Shadow.java:374) [iajc.task] at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:1754) [iajc.task] at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:393) [iajc.task] at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:96) [iajc.task] at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1372) [iajc.task] at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1337) [iajc.task] at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1114) [iajc.task] at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1001) [iajc.task] at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:286) [iajc.task] at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:165) [iajc.task] at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70) [iajc.task] at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367) [iajc.task] at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:728) [iajc.task] at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:206) [iajc.task] at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:140) [iajc.task] at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112) [iajc.task] at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60) [iajc.task] at org.aspectj.tools.ajc.Main.run(Main.java:324) [iajc.task] at org.aspectj.tools.ajc.Main.runMain(Main.java:238) [iajc.task] at org.aspectj.tools.ajc.Main.main(Main.java:82) [iajc.task] 1 fail|abort BUILD FAILED /home/sbhatti/workspace/devint/build.xml:100: The following error occurred while executing this line: /home/sbhatti/workspace/devint/build.xml:164: The following error occurred while executing this line: /home/sbhatti/workspace/devint/modules/novo/build.xml:59: The following error occurred while executing this line: /opt/sbhatti/dev/current/novo/build.xml:326: failure[-1] running ajc
[waiting-on-build] [iajc.task] java.lang.RuntimeException: Ranges must be updated with an enclosing instructionList I am getting following error when compiling code using iajc ant task: [iajc.task] trouble in: [iajc.task] public class admin.modelbean.AdminUserMB extends web.FormSupport: [iajc.task] private static final org.apache.log4j.Logger log .... (Ljava/lang/String;)Ljava/lang/StringBuffer; [iajc.task] | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.String)) [iajc.task] | LDC_W "}" (line 249) [iajc.task] | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.String)) [iajc.task] | | INVOKEVIRTUAL java.lang.StringBuffer.append (Ljava/lang/String;)Ljava/lang/StringBuffer; [iajc.task] | method-call(java.lang.StringBuffer java.lang.StringBuffer.append(java.lang.String)) [iajc.task] | method-call(java.lang.String java.lang.StringBuffer.toString()) [iajc.task] | | INVOKEVIRTUAL java.lang.StringBuffer.toString ()Ljava/lang/String; (line 236) [iajc.task] | method-call(java.lang.String java.lang.StringBuffer.toString()) [iajc.task] | ARETURN [iajc.task] method-execution(java.lang.String admin.modelbean.AdminUserMB.toString()) [iajc.task] end public String toString() [iajc.task] end public class admin.modelbean.AdminUserMB [iajc.task] java.lang.RuntimeException: Ranges must be updated with an enclosing instructionList [iajc.task] at org.aspectj.weaver.bcel.Range.updateTarget(Range.java:170) [iajc.task] at org.aspectj.weaver.bcel.BcelShadow.retargetFrom(BcelShadow.java:235) [iajc.task] at org.aspectj.weaver.bcel.BcelShadow.deleteNewAndDup(BcelShadow.java:212) [iajc.task] at org.aspectj.weaver.bcel.BcelShadow.prepareForMungers(BcelShadow.java:252) [iajc.task] at org.aspectj.weaver.Shadow.implement(Shadow.java:374) [iajc.task] at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:1754) [iajc.task] at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:393) [iajc.task] at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:96) [iajc.task] at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1372) [iajc.task] at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1337) [iajc.task] at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1114) [iajc.task] at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1001) [iajc.task] at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:286) [iajc.task] at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:165) [iajc.task] at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70) [iajc.task] at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367) [iajc.task] at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:728) [iajc.task] at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:206) [iajc.task] at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:140) [iajc.task] at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112) [iajc.task] at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60) [iajc.task] at org.aspectj.tools.ajc.Main.run(Main.java:324) [iajc.task] at org.aspectj.tools.ajc.Main.runMain(Main.java:238) [iajc.task] at org.aspectj.tools.ajc.Main.main(Main.java:82) [iajc.task] ABORT [iajc.task] [iajc.task] Exception thrown from AspectJ 1.5.0_M3a [iajc.task] This might be logged as a bug already -- find current bugs at [iajc.task] http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler Bugs for exceptions thrown have titles File:line from the top stack,  e.g.,  If you don't find the exception below in a bug, please add a new bugat http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ  To make the bug a priority, please include a test program that can reproduce this exception.  java.lang.RuntimeException: Ranges must be updated with an enclosing instructionList  The following error occurred while executing this line: The following error occurred while executing this line:: The following error occurred while executing this line
******
tests/bugs150/pr109614.main(String),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.testRangeProblem_pr109614(),False,new_method|test_method
weaver/src/org/aspectj/weaver/bcel/BcelShadow.deleteNewAndDup(),False,comments
weaver/src/org/aspectj/weaver/bcel/BcelShadow.retargetFrom(InstructionHandle, InstructionHandle),True
#####
AspectJ
119210
8b87db5ac266514d35e1632546d6888e7ca2f6d0
NullPointerException with around advice on field-set I met NullPointerException when weaving. Doesn't Aj support this situations? public class TestLib { private static int myInt; static { myInt = 1; } public static void main(String[] args) { // TODO Auto-generated method stub System.out.println("myInt="+myInt); } } public aspect ThreadAspectLib { pointcut setThreadLocalsField():set(private int TestLib.myInt); Integer around():setThreadLocalsField() { try{ return new Integer(2); } catch(Exception e) { e.printStackTrace(); return null; } } } ---- AspectJ Properties --- AspectJ Compiler DEVELOPMENT built on Tuesday Jun 14, 2005 at 15:41:05 GMT ---- Dump Properties --- Dump file: ajcore.20051205.145247.250.txt Dump reason: java.lang.NullPointerException Dump on exception: true Dump at exit condition: abort ---- Exception Information --- java.lang.NullPointerException at org.aspectj.weaver.ResolvedTypeX$Primitive.isAssignableFrom(ResolvedTypeX.java:985) at org.aspectj.weaver.ResolvedTypeX.isAssignableFrom(ResolvedTypeX.java:96) at org.aspectj.weaver.Advice.match(Advice.java:143) at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:1673) at org.aspectj.weaver.bcel.BcelClassWeaver.matchSetInstruction(BcelClassWeaver.java:1543) at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java(Compiled Code)) at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java(Compiled Code)) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:377) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:94) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1362) at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1327) at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1106) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:993) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:286) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:165) at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:368) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:727) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:206) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:140) at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112) at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60) at org.aspectj.tools.ajc.Main.run(Main.java:318) at org.aspectj.tools.ajc.Main.runMain(Main.java:228) at org.aspectj.tools.ant.taskdefs.AjcTask.executeInSameVM(AjcTask.java:1194) at org.aspectj.tools.ant.taskdefs.AjcTask.execute(AjcTask.java:985) at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:275) at org.apache.tools.ant.Task.perform(Task.java:364) at org.apache.tools.ant.Target.execute(Target.java:341) at org.apache.tools.ant.Target.performTasks(Target.java:369) at org.apache.tools.ant.Project.executeTarget(Project.java:1214) at org.apache.tools.ant.Project.executeTargets(Project.java:1062) at org.apache.tools.ant.Main.runBuild(Main.java:690) at org.apache.tools.ant.Main.startAnt(Main.java:200) at org.apache.tools.ant.launch.Launcher.run(Launcher.java:196) at org.apache.tools.ant.launch.Launcher.main(Launcher.java:55) ---- System Properties --- java.assistive=ON java.runtime.name=Java(TM) 2 Runtime Environment, Standard Edition sun.boot.library.path=C:\Program Files\IBM\Java141\jre\bin java.vm.version=1.4.1 java.vm.vendor=IBM Corporation java.vendor.url=http://www.ibm.com/ path.separator=; java.vm.name=Classic VM file.encoding.pkg=sun.io
with around advice on field-set I met when weaving. Doesn't Aj support this situations? ---- System Properties --- java.assistive=ON java.runtime.name=Java(TM) 2 Runtime Environment, Standard Edition VM 
******
weaver/src/org/aspectj/weaver/bcel/BcelShadow.weaveAroundInline(BcelAdvice, boolean),True
weaver/src/org/aspectj/weaver/bcel/Utility.createConversion(InstructionFactory factory,Type fromType,Type),True
createConversion(InstructionFactory, Type, Type, boolean),False,new_method
#####
AspectJ
119353
b52515fc2319ca34a045a0823ca0f5c8ffeaa2de
Inconsistent Implementations of ReferenceType.getDeclaredMethods() I am running into a problem in load-time weaving when I use reflection delegates because the weaver is generating an incorrect bridge method when I perform an inter-type declaration on Struts.ActionServlet for the init method. On investigation, the BCEL world is recognizing this as an overriding method, because its version of getDeclaredMethods is returning the declared methods for all ancestor superclasses. However, the reflection world is returning only the declared methods for this one class. It therefore appears that the weaver expects getDeclaredMethods to return all of them (making the name quite misleading). I think previously the method was being implemented inconsistently between 1.5 reflection and &lt;1.5 reflection delegates. But it looks like it needs to be handled consistently to include all superclass methods. However, I don?t know what other places (e.g., the MAP) are really expecting getDeclaredMethods and its siblings to behave like Java reflection's version? I started work on adding a getAllDeclaredMethods method to ReferenceType and delegates, as an alternative to provide the weaver the ability to check method overriding as in this case, but it's a little bit involved and I wanted to flag the issue first. Here's a test that fails and illustrates the issue: Index: ReflectionBasedReferenceTypeDelegateTest.java =================================================================== RCS file: /home/technology/weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java,v retrieving revision 1.5 diff -u -r1.5 ReflectionBasedReferenceTypeDelegateTest.java --- ReflectionBasedReferenceTypeDelegateTest.java 28 Nov 2005 17:44:40 -0000 1.5 +++ ReflectionBasedReferenceTypeDelegateTest.java 6 Dec 2005 04:11:41 -0000 @@ -238,6 +238,18 @@ assertTrue("Superclass for Map generic type should be Object but was "+rt2,rt2.equals(UnresolvedType.OBJECT)); } + public void testCompareSubclassDelegates() { + world.setBehaveInJava5Way(true); + + BcelWorld bcelWorld = new BcelWorld(); + bcelWorld.setBehaveInJava5Way(true); + UnresolvedType javaUtilHashMap = UnresolvedType.forName("java.util.HashMap"); + ReferenceType rawType = (ReferenceType)bcelWorld.resolve(javaUtilHashMap ); + + ReferenceType rawReflectType = (ReferenceType)world.resolve(javaUtilHashMap ); + assertEquals(rawType.getDelegate().getDeclaredMethods().length, rawReflectType.getDelegate().getDeclaredMethods().length); + } + // todo: array of int protected void setUp() throws Exception { This results in: junit.framework.AssertionFailedError: expected:&lt;41&gt; but was:&lt;29&gt; at junit.framework.Assert.fail(Assert.java:47) at junit.framework.Assert.failNotEquals(Assert.java:282) at junit.framework.Assert.assertEquals(Assert.java:64) at junit.framework.Assert.assertEquals(Assert.java:201) at junit.framework.Assert.assertEquals(Assert.java:207) at org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateTest.testCompareSubclassDelegates(ReflectionBasedReferenceTypeDelegateTest.java:250) at java.lang.reflect.Method.invoke(Native Method) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult$1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)
Inconsistent Implementations of I am running into a problem in load-time weaving when I use reflection delegates because the weaver is generating an incorrect bridge method when I perform an inter-type declaration on for the init method. On investigation, the BCEL world is recognizing this as an overriding method, because its version of is returning the declared methods for all ancestor superclasses. However, the reflection world is returning only the declared methods for this one class. It therefore appears that the weaver expects to return all of them (making the name quite misleading). I think previously the method was being implemented inconsistently between 1.5 reflection and &lt;1.5 reflection delegates. But it looks like it needs to be handled consistently to include all superclass methods. However, I don?t know what other places (e.g., the MAP) are really expecting getDeclaredMethods and its siblings to behave like Java reflection's version? I started work on adding a method to and delegates, as an alternative to provide the weaver the ability to check method overriding as in this case, but it's a little bit involved and I wanted to flag the issue first. Here's a test that fails and illustrates the issue: Index: 
******
weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.createResolvedConstructor(Constructor, World),True
weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.testGetDeclaredMethods(),True
weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.testCompareSubclassDelegates(),False,new_method|test_method
weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.createGenericConstructorMember(Constructor),True
#####
AspectJ
120351
979124d0fe6ac23df1dd5ee41838056bbaed6789
"cflowbelow issue when binding, in @AJ" Sam wrote: &gt; I'm trying something and it works from .aj but not from .java. When &gt; I try it with annotation based stuff I get a nasty exception: &gt; &gt; [iajc] trouble in: &gt; [iajc] public class gsc.repository.IdentifierTest extends &gt; junit.framework.TestCase: &gt; [iajc] private static final org.aspectj.lang.JoinPoint &gt; $StaticPart ajc$tjp_0 &gt; [iajc] public void &lt;init&gt;(): &gt; [iajc] ALOAD_0 &gt; [iajc] INVOKESPECIAL &gt; junit.framework.TestCase.&lt;init&gt; ()V &gt; [iajc] constructor-execution(void &gt; gsc.repository.IdentifierTest.&lt;init&gt;()) &gt; [iajc] | RETURN &gt; [iajc] constructor-execution(void &gt; gsc.repository.IdentifierTest.&lt;init&gt;()) &gt; [iajc] end public void &lt;init&gt;() &gt; &gt; [iajc] public void testIdentifierExactMatch() throws &gt; java.security.NoSuchAlgorithmException, java.io.IOException: &gt; [iajc] method-execution(void &gt; gsc.repository.IdentifierTest.testIdentifierExactMatch()) &gt; [iajc] | NEW java.io.File &gt; [iajc] | DUP &gt; [iajc] | LDC "test-repository/ant-test/jars/ &gt; ant-1.6.2.jar" &gt; [iajc] | INVOKESPECIAL java.io.File.&lt;init&gt; &gt; (Ljava/lang/String;)V &gt; [iajc] | INVOKESTATIC &gt; gsc.repository.Identifier.interrogate (Ljava/io/File;)Ljava/util/List; &gt; [iajc] | ASTORE_1 &gt; [iajc] | ALOAD_1 &gt; [iajc] | ICONST_0 &gt; [iajc] | INVOKEINTERFACE java.util.List.get &gt; (I)Ljava/lang/Object; &gt; [iajc] | CHECKCAST gsc.repository.ejb.Jar &gt; [iajc] | ASTORE_2 &gt; [iajc] | ALOAD_2 &gt; [iajc] | INVOKEVIRTUAL &gt; gsc.repository.ejb.Jar.getVersion ()Ljava/lang/String; &gt; [iajc] | LDC "1.6.2" &gt; [iajc] | INVOKESTATIC &gt; gsc.repository.IdentifierTest.assertEquals (Ljava/lang/String;Ljava/ &gt; lang/String;)V &gt; [iajc] | RETURN &gt; [iajc] method-execution(void &gt; gsc.repository.IdentifierTest.testIdentifierExactMatch()) &gt; [iajc] end public void testIdentifierExactMatch() throws &gt; java.security.NoSuchAlgorithmException, java.io.IOException &gt; &gt; [iajc] public void testIdentifierExactSameClasses() throws &gt; java.security.NoSuchAlgorithmException, java.io.IOException: &gt; [iajc] method-execution(void &gt; gsc.repository.IdentifierTest.testIdentifierExactSameClasses()) &gt; [iajc] | NEW java.io.File &gt; [iajc] | DUP &gt; [iajc] | LDC "test-jars/ant-1.6.2-test.jar" &gt; [iajc] | INVOKESPECIAL java.io.File.&lt;init&gt; &gt; (Ljava/lang/String;)V &gt; [iajc] | INVOKESTATIC &gt; gsc.repository.Identifier.interrogate (Ljava/io/File;)Ljava/util/List; &gt; [iajc] | ASTORE_1 &gt; [iajc] | ALOAD_1 &gt; [iajc] | ICONST_0 &gt; [iajc] | INVOKEINTERFACE java.util.List.get &gt; (I)Ljava/lang/Object; &gt; [iajc] | CHECKCAST gsc.repository.ejb.Jar &gt; [iajc] | ASTORE_2 &gt; [iajc] | ALOAD_2 &gt; [iajc] | INVOKEVIRTUAL &gt; gsc.repository.ejb.Jar.getVersion ()Ljava/lang/String; &gt; [iajc] | LDC "1.6.2" &gt; [iajc] | INVOKESTATIC &gt; gsc.repository.IdentifierTest.assertEquals (Ljava/lang/String;Ljava/ &gt; lang/String;)V &gt; [iajc] | RETURN &gt; [iajc] method-execution(void &gt; gsc.repository.IdentifierTest.testIdentifierExactSameClasses()) &gt; [iajc] end public void testIdentifierExactSameClasses() &gt; throws java.security.NoSuchAlgorithmException, java.io.IOException &gt; &gt; [iajc] public void testIdentifierMixedUp() throws &gt; java.security.NoSuchAlgorithmException, java.io.IOException: &gt; [iajc] method-execution(void &gt; gsc.repository.IdentifierTest.testIdentifierMixedUp()) &gt; [iajc] | NEW java.io.File &gt; [iajc] | DUP &gt; [iajc] | LDC "test-jars/groovy-1.0-beta-4-and- &gt; commons-logging-1.0.2.jar" &gt; [iajc] | INVOKESPECIAL java.io.File.&lt;init&gt; &gt; (Ljava/lang/String;)V &gt; [iajc] | INVOKESTATIC &gt; gsc.repository.Identifier.interrogate (Ljava/io/File;)Ljava/util/List; &gt; [iajc] | ASTORE_1 &gt; [iajc] | ALOAD_1 &gt; [iajc] | INVOKEINTERFACE java.util.List.size ()I &gt; [iajc] | ICONST_2 &gt; [iajc] | INVOKESTATIC &gt; gsc.repository.IdentifierTest.assertEquals (II)V &gt; [iajc] | ICONST_2 &gt; [iajc] | ISTORE_2 &gt; [iajc] | ALOAD_1 &gt; [iajc] | INVOKEINTERFACE &gt; java.util.List.iterator ()Ljava/util/Iterator; &gt; [iajc] | ASTORE_3 &gt; [iajc] | L0: ALOAD_3 &gt; [iajc] | INVOKEINTERFACE &gt; java.util.Iterator.hasNext ()Z &gt; [iajc] | IFEQ L3 &gt; [iajc] | ALOAD_3 &gt; [iajc] | INVOKEINTERFACE &gt; java.util.Iterator.next ()Ljava/lang/Object; &gt; [iajc] | CHECKCAST gsc.repository.ejb.Jar &gt; [iajc] | ASTORE 4 &gt; [iajc] | ALOAD 4 &gt; [iajc] | INVOKEVIRTUAL &gt; gsc.repository.ejb.Jar.getGroupid ()Ljava/lang/String; &gt; [iajc] | LDC "groovy" &gt; [iajc] | INVOKEVIRTUAL &gt; java.lang.String.equals (Ljava/lang/Object;)Z &gt; [iajc] | IFEQ L1 &gt; [iajc] | ALOAD 4 &gt; [iajc] | INVOKEVIRTUAL &gt; gsc.repository.ejb.Jar.getGroupid ()Ljava/lang/String; &gt; [iajc] | LDC "groovy" &gt; [iajc] | INVOKESTATIC &gt; gsc.repository.IdentifierTest.assertEquals (Ljava/lang/String;Ljava/ &gt; lang/String;)V &gt; [iajc] | ALOAD 4 &gt; [iajc] | INVOKEVIRTUAL &gt; gsc.repository.ejb.Jar.getArtifactid ()Ljava/lang/String; &gt; [iajc] | LDC "groovy" &gt; [iajc] | INVOKESTATIC &gt; gsc.repository.IdentifierTest.assertEquals (Ljava/lang/String;Ljava/ &gt; lang/String;)V &gt; [iajc] | ALOAD 4 &gt; [iajc] | INVOKEVIRTUAL &gt; gsc.repository.ejb.Jar.getVersion ()Ljava/lang/String; &gt; [iajc] | LDC "1.0-beta-4" &gt; [iajc] | INVOKESTATIC &gt; gsc.repository.IdentifierTest.assertEquals (Ljava/lang/String;Ljava/ &gt; lang/String;)V &gt; [iajc] | IINC 2 -1 &gt; [iajc] | GOTO L2 &gt; [iajc] | L1: ALOAD 4 &gt; [iajc] | INVOKEVIRTUAL &gt; gsc.repository.ejb.Jar.getGroupid ()Ljava/lang/String; &gt; [iajc] | LDC "commons-logging" &gt; [iajc] | INVOKESTATIC &gt; gsc.repository.IdentifierTest.assertEquals (Ljava/lang/String;Ljava/ &gt; lang/String;)V &gt; [iajc] | ALOAD 4 &gt; [iajc] | INVOKEVIRTUAL &gt; gsc.repository.ejb.Jar.getArtifactid ()Ljava/lang/String; &gt; [iajc] | LDC "commons-logging" &gt; [iajc] | INVOKESTATIC &gt; gsc.repository.IdentifierTest.assertEquals (Ljava/lang/String;Ljava/ &gt; lang/String;)V &gt; [iajc] | ALOAD 4 &gt; [iajc] | INVOKEVIRTUAL &gt; gsc.repository.ejb.Jar.getVersion ()Ljava/lang/String; &gt; [iajc] | LDC "1.0.2" &gt; [iajc] | INVOKESTATIC &gt; gsc.repository.IdentifierTest.assertEquals (Ljava/lang/String;Ljava/ &gt; lang/String;)V &gt; [iajc] | IINC 2 -1 &gt; [iajc] | L2: GOTO L0 &gt; [iajc] | L3: ILOAD_2 &gt; [iajc] | ICONST_0 &gt; [iajc] | INVOKESTATIC &gt; gsc.repository.IdentifierTest.assertEquals (II)V &gt; [iajc] | RETURN &gt; [iajc] method-execution(void &gt; gsc.repository.IdentifierTest.testIdentifierMixedUp()) &gt; [iajc] end public void testIdentifierMixedUp() throws &gt; java.security.NoSuchAlgorithmException, java.io.IOException &gt; &gt; [iajc] end public class gsc.repository.IdentifierTest &gt; &gt; [iajc] &gt; [iajc] Exception thrown from AspectJ 1.5.0M5 &gt; &gt; [iajc] This might be logged as a bug already -- find current &gt; bugs at &gt; [iajc] http://bugs.eclipse.org/bugs/buglist.cgi? &gt; product=AspectJ&amp;component=Compiler &gt; &gt; [iajc] Bugs for exceptions thrown have titles File:line from &gt; the top stack, &gt; [iajc] e.g., "SomeFile.java:243" &gt; &gt; [iajc] If you don't find the exception below in a bug, please &gt; add a new bug &gt; [iajc] at http://bugs.eclipse.org/bugs/enter_bug.cgi? &gt; product=AspectJ &gt; [iajc] To make the bug a priority, please include a test program &gt; [iajc] that can reproduce this exception. &gt; [iajc] Incorrectly attempting counter operation on stacked cflow &gt; &gt; [iajc] when implementing on shadow method-execution(void &gt; gsc.repository.IdentifierTest.testIdentifierExactMatch()) &gt; [iajc] when weaving type gsc.repository.IdentifierTest &gt; [iajc] when weaving classes &gt; [iajc] when weaving &gt; [iajc] when batch building with classpath: /Users/sam/Library/ &gt; Java/Extensions/jsk-policy.jar:/System/Library/Java/Extensions/ &gt; CoreAudio.jar:/System/Library/Java/Extensions/dns_sd.jar:/System/ &gt; Library/Java/Extensions/j3daudio.jar:/System/Library/Java/Extensions/ &gt; j3dcore.jar:/System/Library/Java/Extensions/j3dutils.jar:/System/ &gt; Library/Java/Extensions/jai_codec.jar:/System/Library/Java/Extensions/ &gt; jai_core.jar:/System/Library/Java/Extensions/mlibwrapper_jai.jar:/ &gt; System/Library/Java/Extensions/MRJToolkit.jar:/System/Library/Java/ &gt; Extensions/QTJava.zip:/System/Library/Java/Extensions/QTJSupport.jar:/ &gt; System/Library/Java/Extensions/vecmath.jar:/System/Library/Frameworks/ &gt; JavaVM.framework/Versions/1.5.0/Home/lib/ext/apple_provider.jar:/ &gt; System/Library/Frameworks/JavaVM.framework/Versions/1.5.0/Home/lib/ &gt; ext/dnsns.jar:/System/Library/Frameworks/JavaVM.framework/Versions/ &gt; 1.5.0/Home/lib/ext/localedata.jar:/System/Library/Frameworks/ &gt; JavaVM.framework/Versions/1.5.0/Home/lib/ext/sunjce_provider.jar:/ &gt; Users/sam/gs/squire/jardb/.aspectj-lib/aspectjrt-1.5.0_M5.jar:/Users/ &gt; sam/gs/squire/jardb/.aspectj-lib/aspectjtools-1.5.0_M5.jar:/Users/sam/ &gt; gs/squire/jardb/target/classes:/Users/sam/gs/squire/jardb/target/test- &gt; classes:/Users/sam/gs/squire/jardb/.lib/antlr-2.7.5.jar:/Users/sam/gs/ &gt; squire/jardb/.lib/asm-1.5.3.jar:/Users/sam/gs/squire/jardb/.lib/ &gt; cglib-2.1_2.jar:/Users/sam/gs/squire/jardb/.lib/commons- &gt; collections-2.1.1.jar:/Users/sam/gs/squire/jardb/.lib/commons- &gt; logging-1.0.4.jar:/Users/sam/gs/squire/jardb/.lib/dom4j-1.6.jar:/ &gt; Users/sam/gs/squire/jardb/.lib/ehcache-1.1.jar:/Users/sam/gs/squire/ &gt; jardb/.lib/ejb3-persistence-pr.jar:/Users/sam/gs/squire/jardb/.lib/ &gt; emma-2.0.latest.jar:/Users/sam/gs/squire/jardb/.lib/ &gt; emma_ant-2.0.latest.jar:/Users/sam/gs/squire/jardb/.lib/ &gt; hibernate-3.1alpha1.jar:/Users/sam/gs/squire/jardb/.lib/hibernate- &gt; annotations-3.1beta3.jar:/Users/sam/gs/squire/jardb/.lib/hibernate- &gt; entitymanager-3.1beta1.jar:/Users/sam/gs/squire/jardb/.lib/ &gt; jta-1.0.jar:/Users/sam/gs/squire/jardb/.lib/junit-3.8.1.jar:/Users/ &gt; sam/gs/squire/jardb/.lib/postgresql-7.4.1-jdbc3.jar:/Users/sam/gs/ &gt; squire/jardb/.lib/svn-javahl-1.2.0.jar:/Users/sam/gs/squire/jardb/lib/ &gt; testng-4.2-jdk15.jar:/Users/sam/gs/squire/jardb/target/aspects.jar: &gt; [iajc] Incorrectly attempting counter operation on stacked cflow &gt; [iajc] java.lang.RuntimeException: Incorrectly attempting &gt; counter operation on stacked cflow &gt; [iajc] at org.aspectj.weaver.bcel.BcelShadow.weaveCflowEntry &gt; (BcelShadow.java:1890) &gt; [iajc] at org.aspectj.weaver.bcel.BcelAdvice.implementOn &gt; (BcelAdvice.java:231) &gt; [iajc] at org.aspectj.weaver.Shadow.implementMungers &gt; (Shadow.java:514) &gt; [iajc] at org.aspectj.weaver.Shadow.implement(Shadow.java:391) &gt; [iajc] at org.aspectj.weaver.bcel.BcelClassWeaver.implement &gt; (BcelClassWeaver.java:2142) &gt; [iajc] at org.aspectj.weaver.bcel.BcelClassWeaver.weave &gt; (BcelClassWeaver.java:467) &gt; [iajc] at org.aspectj.weaver.bcel.BcelClassWeaver.weave &gt; (BcelClassWeaver.java:102) &gt; [iajc] at org.aspectj.weaver.bcel.BcelWeaver.weave &gt; (BcelWeaver.java:1534) &gt; [iajc] at &gt; org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java: &gt; 1485) &gt; [iajc] at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify &gt; (BcelWeaver.java:1266) &gt; [iajc] at org.aspectj.weaver.bcel.BcelWeaver.weave &gt; (BcelWeaver.java:1088) &gt; [iajc] at &gt; org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave &gt; (AjCompilerAdapter.java:300) &gt; [iajc] at &gt; org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling &gt; (AjCompilerAdapter.java:178) &gt; [iajc] at &gt; org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning &gt; $org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0 &gt; (CompilerAdapter.aj:70) &gt; [iajc] at &gt; org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile &gt; (Compiler.java:367) &gt; [iajc] at &gt; org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation &gt; (AjBuildManager.java:809) &gt; [iajc] at &gt; org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild &gt; (AjBuildManager.java:230) &gt; [iajc] at &gt; org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild &gt; (AjBuildManager.java:156) &gt; [iajc] at org.aspectj.ajdt.ajc.AjdtCommand.doCommand &gt; (AjdtCommand.java:112) &gt; [iajc] at org.aspectj.ajdt.ajc.AjdtCommand.runCommand &gt; (AjdtCommand.java:60) &gt; [iajc] at org.aspectj.tools.ajc.Main.run(Main.java:326) &gt; [iajc] at org.aspectj.tools.ajc.Main.runMain(Main.java:240) &gt; [iajc] at &gt; org.aspectj.tools.ant.taskdefs.AjcTask.executeInSameVM(AjcTask.java: &gt; 1210) &gt; [iajc] at org.aspectj.tools.ant.taskdefs.AjcTask.execute &gt; (AjcTask.java:1001) &gt; [iajc] at org.apache.tools.ant.UnknownElement.execute &gt; (UnknownElement.java:275) &gt; [iajc] at org.apache.tools.ant.Task.perform(Task.java:364) &gt; [iajc] at org.apache.tools.ant.taskdefs.Sequential.execute &gt; (Sequential.java:64) &gt; [iajc] at org.apache.tools.ant.UnknownElement.execute &gt; (UnknownElement.java:275) &gt; [iajc] at org.apache.tools.ant.Task.perform(Task.java:364) &gt; [iajc] at &gt; org.apache.tools.ant.taskdefs.MacroInstance.execute &gt; (MacroInstance.java:378) &gt; [iajc] at org.apache.tools.ant.UnknownElement.execute &gt; (UnknownElement.java:275) &gt; [iajc] at org.apache.tools.ant.Task.perform(Task.java:364) &gt; [iajc] at org.apache.tools.ant.Target.execute(Target.java:341) &gt; [iajc] at org.apache.tools.ant.Target.performTasks &gt; (Target.java:369) &gt; [iajc] at org.apache.tools.ant.Project.executeSortedTargets &gt; (Project.java:1216) &gt; [iajc] at org.apache.tools.ant.Project.executeTarget &gt; (Project.java:1185) &gt; [iajc] at &gt; org.apache.tools.ant.helper.DefaultExecutor.executeTargets &gt; (DefaultExecutor.java:40) &gt; [iajc] at org.apache.tools.ant.Project.executeTargets &gt; (Project.java:1068) &gt; [iajc] at org.apache.tools.ant.Main.runBuild(Main.java:668) &gt; [iajc] at org.apache.tools.ant.Main.startAnt(Main.java:187) &gt; [iajc] at org.apache.tools.ant.launch.Launcher.run &gt; (Launcher.java:246) &gt; [iajc] at org.apache.tools.ant.launch.Launcher.main &gt; (Launcher.java:67) &gt; &gt; &gt; package gsc.aspects.testing; &gt; &gt; import junit.framework.*; &gt; import java.io.*; &gt; import java.util.*; &gt; &gt; import org.aspectj.lang.annotation.Pointcut; &gt; import org.aspectj.lang.annotation.Before; &gt; import org.aspectj.lang.annotation.Aspect; &gt; import org.aspectj.lang.annotation.After; &gt; import org.aspectj.lang.JoinPoint; &gt; &gt; @Aspect &gt; public class TestMethodMapperAnnotations { &gt; &gt; @Pointcut("this(testCase) &amp;&amp; this(TestCase) &amp;&amp; execution(void &gt; test*())") &gt; public void inTestClass(TestCase testCase) { &gt; } &gt; &gt; private Map&lt;String, Map&lt;String, Integer&gt;&gt; coverage; &gt; &gt; @Before("cflowbelow(inTestClass(testCase)) &amp;&amp; execution(* *(..))") &gt; public void beforeMethodExecution(JoinPoint thisJoinPoint, &gt; TestCase testCase) { &gt; String testname = testCase.getClass().getName(); &gt; String methodSignature = thisJoinPoint.getStaticPart &gt; ().getSignature().toString(); &gt; Map&lt;String, Integer&gt; tests = coverage.get(methodSignature); &gt; if (tests == null) { &gt; tests = new HashMap&lt;String, Integer&gt;(); &gt; coverage.put(methodSignature, tests); &gt; } &gt; Integer count = tests.get(testname); &gt; if (count == null) { &gt; count = 1; &gt; } else { &gt; count++; &gt; } &gt; tests.put(testname, count); &gt; } &gt; &gt; @Before("inTestClass(testCase)") &gt; public void beforeExecutingTestMethod(TestCase testCase) { &gt; try { &gt; File file = new File("results.ser"); &gt; if (file.exists()) { &gt; ObjectInputStream ois = new ObjectInputStream(new &gt; FileInputStream(file)); &gt; coverage = (Map&lt;String, Map&lt;String, Integer&gt;&gt;) &gt; ois.readObject(); &gt; ois.close(); &gt; } else { &gt; coverage = new HashMap&lt;String, Map&lt;String, Integer&gt;&gt;(); &gt; } &gt; } catch (Exception e) { &gt; e.printStackTrace(); &gt; } &gt; } &gt; &gt; @After("inTestClass(testCase)") &gt; public void afterExecutingTestMethod(TestCase testCase) { &gt; try { &gt; File file = new File("results.ser"); &gt; ObjectOutputStream oos = new ObjectOutputStream(new &gt; FileOutputStream(file)); &gt; oos.writeObject(coverage); &gt; oos.close(); &gt; } catch (Exception e) { &gt; e.printStackTrace(); &gt; } &gt; } &gt; &gt; } &gt; &gt; vs. &gt; &gt; package gsc.aspects.testing; &gt; &gt; import junit.framework.*; &gt; import java.io.*; &gt; import java.util.*; &gt; &gt; public aspect TestMethodMapper { &gt; &gt; pointcut inTestClass(TestCase testCase) : this(testCase) &amp;&amp; this &gt; (TestCase) &amp;&amp; execution(void test*()); &gt; private Map&lt;String, Map&lt;String, Integer&gt;&gt; coverage; &gt; &gt; before(TestCase testCase) : cflowbelow(inTestClass(testCase)) &amp;&amp; &gt; execution(* *(..)) { &gt; String testname = testCase.getClass().getName(); &gt; String methodSignature = thisJoinPointStaticPart.getSignature &gt; ().toString(); &gt; Map&lt;String, Integer&gt; tests = coverage.get(methodSignature); &gt; if (tests == null) { &gt; tests = new HashMap&lt;String, Integer&gt;(); &gt; coverage.put(methodSignature, tests); &gt; } &gt; Integer count = tests.get(testname); &gt; if (count == null) { &gt; count = 1; &gt; } else { &gt; count++; &gt; } &gt; tests.put(testname, count); &gt; } &gt; &gt; before(TestCase testCase) : inTestClass(testCase) { &gt; try { &gt; File file = new File("results.ser"); &gt; if (file.exists()) { &gt; ObjectInputStream ois = new ObjectInputStream(new FileInputStream &gt; (file)); &gt; coverage = (Map&lt;String, Map&lt;String, Integer&gt;&gt;) ois.readObject(); &gt; ois.close(); &gt; } else { &gt; coverage = new HashMap&lt;String, Map&lt;String, Integer&gt;&gt;(); &gt; } &gt; } catch (Exception e) { &gt; e.printStackTrace(); &gt; } &gt; } &gt; &gt; after(TestCase testCase) : inTestClass(testCase) { &gt; try { &gt; File file = new File("results.ser"); &gt; ObjectOutputStream oos = new ObjectOutputStream(new &gt; FileOutputStream(file)); &gt; oos.writeObject(coverage); &gt; oos.close(); &gt; } catch (Exception e) { &gt; e.printStackTrace(); &gt; } &gt; } &gt; &gt; } &gt; &gt; &gt;
issue when binding, in @AJ" Sam wrote: &gt; I'm trying something and it works from .aj but not from .java. When &gt; I try it with annotation based stuff I get a nasty exception:  Bugs for exceptions thrown have titles File:line from &gt; the top stack, If you don't find the exception below in a bug, please add a new bug To make the bug a priority, please include a test program that can reproduce this exception. Incorrectly attempting counter operation on stacked cflow when implementing on shadow when weaving type when weaving classes when weaving when batch building with classpath
******
tests/java5/ataspectj/ataspectj/bugs/CflowBelowStackTest.testMe(),False,new_method|test_method
tests/java5/ataspectj/ataspectj/bugs/CflowBelowStackTest.main(String[]),False,new_method|test_method
tests/java5/ataspectj/ataspectj/bugs/CflowBelowStackTest.suite(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.testCflowBelowStack(),False,new_method|test_method
weaver/src/org/aspectj/weaver/bcel/BcelAdvice.getExposedStateAsBcelVars(),True
weaver/src/org/aspectj/weaver/bcel/BcelAdvice.getExposedStateAsBcelVars(boolean),False,new_method
weaver/src/org/aspectj/weaver/bcel/BcelShadow.weaveCflowEntry(BcelAdvice, Member),True
weaver/src/org/aspectj/weaver/bcel/BcelShadow.getAdviceInstructions(BcelShadow, BcelVar, InstructionHandle),True
weaver/src/org/aspectj/weaver/bcel/BcelShadow.getRedoneProceedCall(InstructionFactory, LazyMethodGen, BcelAdvice, LazyMethodGen, List),True
weaver/src/org/aspectj/weaver/bcel/BcelShadow.weaveAroundClosure(BcelAdvice, boolean),True
#####
AspectJ
119451
5f8d2cdff480ac9d04cc73a4a69eb11563a0bb01
AJDoc produces incorrect warning for package accessed aspects // Main.java package bug; public class Main { } aspect LogMain { } Generating ajdoc through Eclipse (AJDT 1.3.0.20051206092602, AspectJ 1.5.0.20051206103951) generate incorrect warning for the LogMain aspect: &gt; Calling ajc... &gt; Building signature files... &gt; Calling javadoc... Loading source file C:\work\aop\src\ajdocworkingdir\bug\Main.java... Constructing Javadoc information... C:\work\aop\src\ajdocworkingdir\bug\Main.java:11: class LogMain is public, should be declared in a file named LogMain.java public class LogMain { ^ Standard Doclet version 1.5.0_04 Building tree for all the packages and classes... Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\bug/\LogMain.html... Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\bug/\Main.html... Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\bug/\package-frame.html... Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\bug/\package-summary.html... Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\bug/\package-tree.html... Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\constant-values.html... Building index for all the packages and classes... Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\overview-tree.html... Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\index-all.html... Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\deprecated-list.html... Building index for all classes... Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\allclasses-frame.html... Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\allclasses-noframe.html... Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\index.html... Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\help-doc.html... Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\stylesheet.css... 1 warning &gt; Decorating html files... &gt; Decorating C:\work\aop\src\workspace\AJDocPackageAspect\doc\bug\Main.html... &gt; Removing generated tags (this may take a while)... &gt; Finished.
produces incorrect warning for package accessed aspects // Generating ajdoc through Eclipse (AJDT 1.3.0.20051206092602, AspectJ 1.5.0.20051206103951) generate incorrect warning for the LogMain aspect: &gt; Calling ajc... &gt; Building signature files... &gt; Calling javadoc... Loading source file Constructing Javadoc information... : class is public, should be declared in a file named { ^ Standard Doclet version 1.5.0_04 Building tree for all the packages and classes... Generating Removing generated tags (this may take a while)... &gt; Finished.
******
ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.testAspectAccessibility(),False,test_method
ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.genSourceSignature(IProgramElement),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.printHeader(int, StringBuffer),True
#####
AspectJ
120543
9d32b76c9b48e6a2593bff77dc120eb8c5f17cff
Issue version message during load-time weaving It would be very useful to know exactly which version of the weaver is being used for LTW. An informational message could be issued when each WeavingAdaptor instance is created (it is possible to have multiple versions of AspectJ in a system). This message could be similar to the that issued by "ajc -version".
Issue version message during load-time weaving It would be very useful to know exactly which version of the weaver is being used for LTW. An informational message could be issued when each instance is created (it is possible to have multiple versions of AspectJ in a system). This message could be similar to the that issued by "ajc -version".
******
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.createMessageHandler(),True
#####
AspectJ
120474
3339edbae5d6891cfbde6952329a4ff2808a7901
Don't dump stack trace when loading $Proxy classes I am seeing a BCException that gets caught and prints a stack trace in Aj.preProcess when loading a class named "$Proxy4" This occurs in UnresolvedType.nameToSignature because the string it receives from ResolvedType.getDeclaringType is "" (i.e., it strips off the leading $, treating the type as if it were a nested type of nothing). I'm not sure of the best resolution, but maybe the loop in ResolvedType should just say while (lastDollar &gt; 0). This would handle the "leading $" case as an identifier rather than trying to look up the empty string. This might help with Hibernate's $$ types too... Here is the stack when it happens: UnresolvedType.nameToSignature(String) line: 774 UnresolvedType.forName(String) line: 309 ReferenceType(ResolvedType).getDeclaringType() line: 1255 WithinPointcut.isWithinType(ResolvedType) line: 50 WithinPointcut.fastMatch(FastMatchInfo) line: 67 AndPointcut.fastMatch(FastMatchInfo) line: 51 AndPointcut.fastMatch(FastMatchInfo) line: 51 AndPointcut.fastMatch(FastMatchInfo) line: 51 AndPointcut.fastMatch(FastMatchInfo) line: 51 AndPointcut.fastMatch(FastMatchInfo) line: 51 BcelWeaver.fastMatch(List, ResolvedType) line: 1635 BcelWeaver.weave(UnwovenClassFile, BcelObjectType, boolean) line: 1516 BcelWeaver.weaveWithoutDump(UnwovenClassFile, BcelObjectType) line: 1494 BcelWeaver.weaveAndNotify(UnwovenClassFile, BcelObjectType, IWeaveRequestor) line: 1275 BcelWeaver.weave(IClassFileProvider) line: 1097 ClassLoaderWeavingAdaptor(WeavingAdaptor).getWovenBytes(String, byte[]) line: 261 ClassLoaderWeavingAdaptor(WeavingAdaptor).weaveClass(String, byte[]) line: 194 Aj.preProcess(String, byte[], ClassLoader) line: 65
Don't dump stack trace when loading $Proxy classes I am seeing a that gets caught and prints a stack trace in when loading a class named "$Proxy4" This occurs in because the string it receives from is "" (i.e., it strips off the leading $, treating the type as if it were a nested type of nothing). I'm not sure of the best resolution, but maybe the loop in should just say . This would handle the "leading $" case as an identifier rather than trying to look up the empty string. This might help with Hibernate's $$ types too... Here is the stack when it happens: line: 65
******
tests/bugs150/pr120474/$Proxy4.foo(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.testDollarClasses_pr120474(),False,new_method|test_method
weaver/src/org/aspectj/weaver/ResolvedType.getDeclaringType(),True
#####
AspectJ
120363
9edb4b6f9e8ca59b309ac382e6049321832d0700
LTW weaver include and exclude does not behave correctly According to the specification (http://www.eclipse.org/aspectj/doc/next/adk15notebook/ltw-configuration.html) "The set of types to be woven are those types matched by at least one weaver include element and not matched by any weaver exclude element." However if an includ elemement can be fast matched e.g. "com.foo..*" any exclude elements are ignored (see bug 117854). There is no explicit test in the harness for this feature.
LTW weaver include and exclude does not behave correctly According to the specification (http://www.eclipse.org/aspectj/doc/next/adk15notebook/ltw-configuration.html) "The set of types to be woven are those types matched by at least one weaver include element and not matched by any weaver exclude element." However if an includ elemement can be fast matched e.g. any exclude elements are ignored (see bug 117854). There is no explicit test in the harness for this feature.
******
loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.accept(String, byte[]),True
tests/java5/ataspectj/com/foo/bar/Test$$EnhancerByCGLIB$$12345.main(String[]),False,test_method
tests/java5/ataspectj/com/foo/bar/Test.main(String[]),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.testLTWDumpBeforeAndAfter(),False,test_method
tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.testLTWDumpProxy(),False,test_method
#####
AspectJ
120401
3ac46270398a3e9ddde620e03c9dc2123cbe78d0
add signature to UnresolvedType.parameterize(..) exception I keep getting UnresolvedType UnsupportedOperationException unhelpful message "resolve this type first," so I'm adding the signature to the message (without permission, hence the bug as notice). throw new UnsupportedOperationException("unable to parameterize unresolved type: " + signature); ------------------------------- java.lang.UnsupportedOperationException at org.aspectj.weaver.UnresolvedType.parameterize(UnresolvedType.java:218) at org.aspectj.weaver.patterns.ExactTypePattern.parameterizeWith(ExactTypePattern.java:242) at org.aspectj.weaver.patterns.TypePatternList.parameterizeWith(TypePatternList.java:195) at org.aspectj.weaver.patterns.DeclareParents.parameterizeWith(DeclareParents.java:77) at org.aspectj.weaver.ReferenceType.getDeclares(ReferenceType.java:484) at org.aspectj.weaver.ResolvedType.collectDeclares(ResolvedType.java:523) at org.aspectj.weaver.ResolvedType.collectCrosscuttingMembers(ResolvedType.java:488) at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect(CrosscuttingMembersSet.java:60) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.addCrosscuttingStructures(AjLookupEnvironment.java:378) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.addCrosscuttingStructures(AjLookupEnvironment.java:388) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.collectAllITDsAndDeclares(AjLookupEnvironment.java:314) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:168) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:185) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:163) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) UnsupportedOperationException thrown: resolve this type first
add signature to exception I keep getting unhelpful message "resolve this type first," so I'm adding the signature to the message (without permission, hence the bug as notice). resolve this type first
******
weaver/src/org/aspectj/weaver/UnresolvedType.parameterize(Map),True
#####
AspectJ
113257
40f0b2a58c02bb3071ab7ddebfae056e9fe35764
Incremental Compilation Bug: parameter not bound with no parameter I keep getting an incremental compilation error on this pointcut when I save other files (in AJDT): public pointcut scope() : within(DoMonitorErrors+) || ((within(pkg1..*)|| within(pkg2..*) || within(pkg3..*)) &amp;&amp; !within(pkg1.monitoring..*)); It is used as follows: after() throwing (Throwable t) : publicMethodExec() &amp;&amp; scope() &amp;&amp; adviceEnabled() { ... recordThrowable(t, thisJoinPointStaticPart, thisEnclosingJoinPointStaticPart); } before(Throwable t) : handler(*) &amp;&amp; args(t) &amp;&amp; scope() &amp;&amp; adviceEnabled() { ... recordThrowable(t, thisJoinPointStaticPart, thisEnclosingJoinPointStaticPart); } The resulting incremental compilation produces an error which requires a full rebuild to clear: the parameter t is not bound in [all branches of] pointcut ErrorMonitor.aj aspectjSupport/src/pkg1/monitoring line 58
Incremental Compilation Bug: parameter not bound with no parameter I keep getting an incremental compilation error on this pointcut when I save other files (in AJDT): The resulting incremental compilation produces an error which requires a full rebuild to clear: the parameter t is not bound in [all branches of]
******
tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.testPr113257(),False,new_method|test_method
weaver/src/org/aspectj/weaver/patterns/PointcutRewriter.rewrite(Pointcut),True
weaver/src/org/aspectj/weaver/patterns/PointcutRewriter.rewrite(Pointcut,boolean),False,new_method
weaver/src/org/aspectj/weaver/patterns/PointcutRewriter.isDNF(Pointcut),False,new_method
weaver/src/org/aspectj/weaver/patterns/PointcutRewriter.isDNFHelper(Pointcut,boolean),False,new_method
weaver/src/org/aspectj/weaver/patterns/PointcutRewriter.format(Pointcut),False,new_method
weaver/src/org/aspectj/weaver/patterns/PointcutRewriter.distributeNot(Pointcut),True
weaver/src/org/aspectj/weaver/patterns/PointcutRewriter.not(Pointcut),False,new_method
weaver/src/org/aspectj/weaver/patterns/PointcutRewriter.createAndsFor(Pointcut[]),False,new_method
weaver/src/org/aspectj/weaver/patterns/PointcutRewriter.simplifyAnds(Pointcut),True
weaver/src/org/aspectj/weaver/patterns/PointcutRewriter.removeNothings(Pointcut),False,new_method
weaver/testsrc/org/aspectj/weaver/patterns/PointcutRewriterTest.testDistributeNot(),False,test_method
#####
AspectJ
119749
b7929e91659708dc27141f587ad236af7bfa8287;a29212c28921626874bc1c6cbb38ddc72c773280
execution incorrectly matching based on overridden method throws clause Per user email "after() throwing matching on interface" and the code below, the execution PCD is matching based on a throws clause declared in the overridden method of a supertype. While this tracks the multiple-signature model for the execution join point, it's not correct to say that the method will throw the exceptions declared by the method it overrides, unless it explicitly declares them, so it seems like a bug. (We should also document the difference between call and execution in this respect.) In the code below, all warnings are matched by all method implementations because they implement MyInterface. -------------------- bugs/InheritedThrows.java package bugs; public class InheritedThrows { static aspect A { declare warning : execution (* *.*(..) throws Ex1) : "one"; declare warning : execution (* *.*(..) throws Ex2) : "two"; declare warning : execution (* *.*(..) throws !(Ex1||Ex2)) : "neither"; declare warning : execution (* *.*(..) throws Ex1, Ex2) : "both"; } public static class Ex1 extends Exception {} public static class Ex2 extends Exception {} public interface MyInterface { public void m() throws Ex1, Ex2; } private static class NestedClass1 implements MyInterface { public void m() throws Ex1 {} } private static class NestedClass2 implements MyInterface { public void m() throws Ex2 {} } private static class NestedClassBoth implements MyInterface { public void m() throws Ex1, Ex2 {} } private static class NestedClassNeither implements MyInterface { public void m() {} } }
execution incorrectly matching based on overridden method throws clause Per user email " throwing matching on interface" and the code below, the execution PCD is matching based on a throws clause declared in the overridden method of a supertype. While this tracks the multiple-signature model for the execution join point, it's not correct to say that the method will throw the exceptions declared by the method it overrides, unless it explicitly declares them, so it seems like a bug. (We should also document the difference between call and execution in this respect.) In the code below, all warnings are matched by all method implementations because they implement.
******
tests/bugs150/pr119749/InheritedThrows.m(),False,test_method
tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.testModifierOverrides(),False,new_method|test_method
weaver/src/org/aspectj/weaver/patterns/SignaturePattern.matches(Member, World, boolean),True
weaver/src/org/aspectj/weaver/patterns/SignaturePattern.matchesExactlyMethod(JoinPointSignature, World),True
weaver/src/org/aspectj/weaver/patterns/SignaturePattern.matchesAnnotations(ResolvedMember, World),True
weaver/testsrc/org/aspectj/weaver/patterns/SignaturePatternTestCase.testThrowsMatch(),False,test_method
weaver/src/org/aspectj/weaver/Advice.match(Shadow shadow, World),True
weaver/src/org/aspectj/weaver/ResolvedType.isException(),False,new_method
weaver/src/org/aspectj/weaver/ResolvedType.isCheckedException(),False,new_method
#####
AspectJ
120909
9abfc4044b23629af408459a3a5c638d7978e443
Test failures using IBM Java 51. ReflectionBasedReferenceTypeDelegateTest.testCompareSubclassDelegates() junit.framework.AssertionFailedError: Errors:Couldn't find void java.util.HashMap.onEntry() in the bcel set Couldn't find void java.util.HashMap.onExit() in the bcel set Couldn't find void java.util.HashMap.transfer0(java.util.HashMap$Entry[]) in the bcel set ? ? ? ? at junit.framework.Assert.fail(Assert.java:47) ? ? ? ? at junit.framework.Assert.assertTrue(Assert.java:20) ? ? ? ? at org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateTest.testCompareSubclassDelegates(ReflectionBasedReferenceTypeDelegateTest.java:278) ? ? ? ? at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ? ? ? ? at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64) ? ? ? ? at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ? ? ? ? at java.lang.reflect.Method.invoke(Method.java:615) ? ? ? ? at junit.framework.TestCase.runTest(TestCase.java:154) ? ? ? ? at junit.framework.TestCase.runBare(TestCase.java:127) ? ? ? ? at junit.framework.TestResult$1.protect(TestResult.java:106) ? ? ? ? at junit.framework.TestResult.runProtected(TestResult.java:124) ? ? ? ? at junit.framework.TestResult.run(TestResult.java:109) ? ? ? ? at junit.framework.TestCase.run(TestCase.java:118) ? ? ? ? at junit.framework.TestSuite.runTest(TestSuite.java:208) ? ? ? ? at junit.framework.TestSuite.run(TestSuite.java:203) ? ? ? ? at junit.framework.TestSuite.runTest(TestSuite.java:208) ? ? ? ? at junit.framework.TestSuite.run(TestSuite.java:203) ? ? ? ? at junit.framework.TestSuite.runTest(TestSuite.java:208) ? ? ? ? at junit.framework.TestSuite.run(TestSuite.java:203) ? ? ? ? at junit.framework.TestSuite.runTest(TestSuite.java:208) ? ? ? ? at junit.framework.TestSuite.run(TestSuite.java:203) ? ? ? ? at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478) ? ? ? ? at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344) ? ? ? ? at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) This failure occures because when we compare BeclWorld with ReflectionWorld we are still picking up the default (Sun) version of HashMap in JRE15_LIB for BCEL. The solution is to create both worlds with the same class loader. 2. Ajc150Tests.testModifierOverrides() junit.framework.AssertionFailedError: Expecting output: execution(void pr119749.C.m()): execMe[@pr119749$Me()] execution(void pr119749.C.m()): execEx But found output: execution(void pr119749.C.m()): execMe[@pr119749.Me()] execution(void pr119749.C.m()): execEx First difference is on line 1 ? ? ? ? at junit.framework.Assert.fail(Assert.java:47) ? ? ? ? at org.aspectj.testing.OutputSpec.matchAgainst(OutputSpec.java:58) ? ? ? ? at org.aspectj.testing.RunSpec.execute(RunSpec.java:61) ? ? ? ? at org.aspectj.testing.AjcTest.runTest(AjcTest.java:68) ? ? ? ? at org.aspectj.testing.XMLBasedAjcTestCase.runTest(XMLBasedAjcTestCase.java:111) ? ? ? ? at org.aspectj.systemtest.ajc150.Ajc150Tests.testModifierOverrides(Ajc150Tests.java:852) ? ? ? ? at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ? ? ? ? at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64) ? ? ? ? at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ? ? ? ? at java.lang.reflect.Method.invoke(Method.java:615) ? ? ? ? at junit.framework.TestCase.runTest(TestCase.java:154) ? ? ? ? at junit.framework.TestCase.runBare(TestCase.java:127) ? ? ? ? at junit.framework.TestResult$1.protect(TestResult.java:106) ? ? ? ? at junit.framework.TestResult.runProtected(TestResult.java:124) ? ? ? ? at junit.framework.TestResult.run(TestResult.java:109) ? ? ? ? at junit.framework.TestCase.run(TestCase.java:118) ? ? ? ? at junit.framework.TestSuite.runTest(TestSuite.java:208) ? ? ? ? at junit.framework.TestSuite.run(TestSuite.java:203) ? ? ? ? at junit.framework.TestSuite.runTest(TestSuite.java:208) ? ? ? ? at junit.framework.TestSuite.run(TestSuite.java:203) ? ? ? ? at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22) ? ? ? ? at junit.extensions.TestSetup$1.protect(TestSetup.java:19) ? ? ? ? at junit.framework.TestResult.runProtected(TestResult.java:124) ? ? ? ? at junit.extensions.TestSetup.run(TestSetup.java:23) ? ? ? ? at junit.framework.TestSuite.runTest(TestSuite.java:208) ? ? ? ? at junit.framework.TestSuite.run(TestSuite.java:203) ? ? ? ? at junit.framework.TestSuite.runTest(TestSuite.java:208) ? ? ? ? at junit.framework.TestSuite.run(TestSuite.java:203) ? ? ? ? at junit.framework.TestSuite.runTest(TestSuite.java:208) ? ? ? ? at junit.framework.TestSuite.run(TestSuite.java:203) ? ? ? ? at junit.framework.TestSuite.runTest(TestSuite.java:208) ? ? ? ? at junit.framework.TestSuite.run(TestSuite.java:203) ? ? ? ? at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478) ? ? ? ? at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344) ? ? ? ? at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) This failure is due a difference between JDKs in the implementation of toString() for annotations.
Test failures using IBM Java 51. This failure occures because when we compare with we are still picking up the default (Sun) version of  in JRE15_LIB for BCEL. The solution is to create both worlds with the same class loader. 2.  This failure is due a difference between JDKs in the implementation of for annotations.
******
loadtime/src/org/aspectj/weaver/loadtime/DefaultWeavingContext.DefaultWeavingContext(),True
weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.ReflectionWorld(),False,access_level_change
weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.testCompareSubclassDelegates(),True
weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.setUp(),True
weaver/testsrc/org/aspectj/weaver/reflect/ReflectionWorldTest.testDelegateCreation(),True
weaver/testsrc/org/aspectj/weaver/reflect/ReflectionWorldTest.testArrayTypes(),True
weaver/testsrc/org/aspectj/weaver/reflect/ReflectionWorldTest.testPrimitiveTypes(),True
#####
AspectJ
119539
a9abf53e92cc92a49c0c3924ad076c4f37596c0d
generic pertypewithin advice fails to match though pointcut does Get compiler xlint adviceDidNotMatch when using parameterized type to specify type pattern for pertypewithin clause. Parameterized type works in pointcuts, and the pointcut matches staticly (with deow). Same result for before or around advice. Also, the permitted uses for the type parameter of a parameterized aspect in the adk15notebook section on point. Resolutions could be: - not a bug b/c the code below is wrong - not permitted to use type parameter in pertypewithin; doc updated - permitted, fixed ... AspectJ version 1.5.0.20051206103951, via AJDT ----------------------------------------- sample package bugs; public class GenericPerTypeWithin { public static void main(String[] args) { new C(); // fyi, compiler does nothing absent this call? } public static abstract aspect Singleton&lt;Target&gt; pertypewithin(Target) { pointcut creation() : execution(Target+.new()) ; // adviceDoesNotMatch - same for before advice Target around() : creation() { return proceed(); } // picks out constructor-execution below declare warning : creation() : "Singleton.creation()"; } static class C { C(){} } static aspect A extends Singleton&lt;C&gt; {} }
generic advice fails to match though pointcut does Get compiler xlint  when using parameterized type to specify type pattern for clause. Parameterized type works in pointcuts, and the pointcut matches staticly (with deow). Same result for before or around advice. Also, the permitted uses for the type parameter of a parameterized aspect in the adk15notebook section on point. Resolutions could be: - not a bug b/c the code below is wrong - not permitted to use type parameter in pertypewithin; doc updated - permitted, fixed ... AspectJ version 1.5.0.20051206103951, via AJDT ----------------------------------------- // fyi, compiler does nothing absent this call?; //  - same for before advice Target // picks out constructor-execution below declare warning : 
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.getPerClause(),True
tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.testGenericPTW_pr119539_1(),False,test_method
tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.testGenericPTW_pr119539_2(),False,test_method
tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.testGenericPTW_pr119539_3(),False,test_method
tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.testPr117882_2(),False,test_method
weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.addOrReplaceAspect(ResolvedType),True
weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.addOrReplaceDescendantsOf(ResolvedType),True
weaver/src/org/aspectj/weaver/ReferenceType.getPerClause(),True

weaver/src/org/aspectj/weaver/patterns/CflowPointcut.findResidueInternal(Shadow, ExposedState),True
weaver/src/org/aspectj/weaver/patterns/CflowPointcut.concretize1(ResolvedType, ResolvedType, IntMap),True
weaver/src/org/aspectj/weaver/patterns/CflowPointcut.getCflowfield(Pointcut),True
weaver/src/org/aspectj/weaver/patterns/CflowPointcut.getKey(Pointcut, ResolvedType),False,new_method
weaver/src/org/aspectj/weaver/patterns/CflowPointcut.getCflowfield(Pointcut, ResolvedType),False,new_method
weaver/src/org/aspectj/weaver/patterns/CflowPointcut.putCflowfield(Pointcut, Object),True
weaver/src/org/aspectj/weaver/patterns/CflowPointcut.putCflowfield(Pointcut, ResolvedType, Object),False,new_method
weaver/src/org/aspectj/weaver/patterns/CflowPointcut.clearCaches(ResolvedType),False,new_method
weaver/src/org/aspectj/weaver/patterns/CflowPointcut.wipeKeys(String, Hashtable),False,new_method
#####
AspectJ
124105
60c848e2ef6d8fb6bd1022f390a95ee83e4cd2ba
-XhasMember doesn't appear to work well with types in packages See Jeppe's post on the mailing list... will append more here soon.
-XhasMember doesn't appear to work well with types in packages See Jeppe's post on the mailing list... will append more here soon.
******
weaver/src/org/aspectj/weaver/patterns/HasMemberTypePattern.resolveBindings(IScope, Bindings, boolean, boolean),True
#####
AspectJ
123695
3a315d0a21d3c4b57436a8d77ab980f910ac17e5
Internal nullptr exception with complex declare annotation statement that affects injected methods I have an aspect that declares an annotation on a method based on a complex condition : declare @method : !@(Write || Read) public !static * (@MarkMyMethods *).*(..) : @Write; Basically that means that every type that is annotated with @MarkMyMethods should have all of its public non static methods be annotated with either @Read or @Write. If neither of @Read nor @Write is present on such a method, @Write is added by default. I have another aspect that makes every type annotated with @InjectName implement the Named interface : public Interface Named { public String getName(); } public aspect NameAspect { declare parents: @InjectName * implements Named; private String Named.name; public String Named.getName() { return name; } } As soon as I annotate a class with both @MarkMyMethods and @InjectName, I get an internal null pointer exception at weave time. However if I change the first aspect to say : declare @method : !@(Read) public !static * (@MarkMyMethods *).*(..) : @Write; or declare @method : !@(Write) public !static * (@MarkMyMethods *).*(..) : @Write; instead of the !@(Read || Write) one, everything compiles fine. Here is a link to a small application that exhibits the bug. : http://www.cs.mcgill.ca/~jlegar/src_jslegare.zip ========== Here is the error output : java.lang.NullPointerException at org.aspectj.weaver.patterns.WildAnnotationTypePattern.matches(WildAnnotationTypePattern.java:61) at org.aspectj.weaver.patterns.NotAnnotationTypePattern.matches(NotAnnotationTypePattern.java:35) at org.aspectj.weaver.patterns.SignaturePattern.matchesAnnotations(SignaturePattern.java:488) at org.aspectj.weaver.patterns.SignaturePattern.matchesExactly(SignaturePattern.java:331) at org.aspectj.weaver.patterns.SignaturePattern.matches(SignaturePattern.java:288) at org.aspectj.weaver.patterns.DeclareAnnotation.matches(DeclareAnnotation.java:247) at org.aspectj.weaver.bcel.BcelClassWeaver.weaveAtMethodOnITDSRepeatedly(BcelClassWeaver.java:995) at org.aspectj.weaver.bcel.BcelClassWeaver.weaveDeclareAtMethodCtor(BcelClassWeaver.java:730) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:430) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:102) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1543) at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1494) at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1275) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1078) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:300) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:178) at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:156) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) trouble in: public class NameAspect extends java.lang.Object: TypeMungers: [(BcelTypeMunger ResolvedTypeMunger(Method, java.lang.String Named.getName())), (BcelTypeMunger ResolvedTypeMunger(Field, java.lang.String Named.name))] declares: [declare parents: @InjectName * extends (Named);] private static Throwable ajc$initFailureCause public static final NameAspect ajc$perSingletonInstance static void &lt;clinit&gt;(): catch java.lang.Throwable -&gt; E0 | INVOKESTATIC NameAspect.ajc$postClinit ()V (line 2) catch java.lang.Throwable -&gt; E0 GOTO L0 E0: ASTORE_0 ALOAD_0 PUTSTATIC NameAspect.ajc$initFailureCause Ljava/lang/Throwable; L0: RETURN end static void &lt;clinit&gt;() public void &lt;init&gt;(): ALOAD_0 // NameAspect this (line 2) INVOKESPECIAL java.lang.Object.&lt;init&gt; ()V RETURN end public void &lt;init&gt;() void ajc$declare_parents_1() org.aspectj.weaver.MethodDeclarationLineNumber: 5:40 : RETURN (line 5) end void ajc$declare_parents_1() public static String ajc$interMethod$NameAspect$Named$getName(Named) EffectiveSignatureAttribute(java.lang.String Named.getName(), method-execution) : ALOAD_0 // Named ajc$this_ (line 11) INVOKESTATIC NameAspect.ajc$interFieldGetDispatch$NameAspect$Named$name (LNamed;)Ljava/lang/String; ARETURN end public static String ajc$interMethod$NameAspect$Named$getName(Named) public static String ajc$interMethodDispatch1$NameAspect$Named$getName(Named) EffectiveSignatureAttribute(java.lang.String Named.getName(), method-call) : ALOAD_0 INVOKEINTERFACE Named.getName ()Ljava/lang/String; ARETURN end public static String ajc$interMethodDispatch1$NameAspect$Named$getName(Named) public static void ajc$interFieldInit$NameAspect$Named$name(Named) org.aspectj.weaver.MethodDeclarationLineNumber: 12:279 : RETURN (line 12) end public static void ajc$interFieldInit$NameAspect$Named$name(Named) public static String ajc$interFieldGetDispatch$NameAspect$Named$name(Named) EffectiveSignatureAttribute(java.lang.String Named.name, field-get) : ALOAD_0 INVOKEINTERFACE Named.ajc$interFieldGet$NameAspect$Named$name ()Ljava/lang/String; ARETURN end public static String ajc$interFieldGetDispatch$NameAspect$Named$name(Named) public static void ajc$interFieldSetDispatch$NameAspect$Named$name(Named, String) EffectiveSignatureAttribute(java.lang.String Named.name, field-set) : ALOAD_0 ALOAD_1 INVOKEINTERFACE Named.ajc$interFieldSet$NameAspect$Named$name (Ljava/lang/String;)V RETURN end public static void ajc$interFieldSetDispatch$NameAspect$Named$name(Named, String) public void ajc$after$NameAspect$1$dd96786a(Named) AdviceAttribute(after, (execution(Named+.new(..)) &amp;&amp; target(BindingTypePattern(Named, 0))), 0, 296) : GETSTATIC java.lang.System.out Ljava/io/PrintStream; (line 15) LDC "A new name was created" INVOKEVIRTUAL java.io.PrintStream.println (Ljava/lang/String;)V ALOAD_1 // Named newinstance (line 16) LDC "TikaTikaSlimShady" INVOKESTATIC NameAspect.ajc$interFieldSetDispatch$NameAspect$Named$name (LNamed;Ljava/lang/String;)V RETURN (line 17) end public void ajc$after$NameAspect$1$dd96786a(Named) public static NameAspect aspectOf() org.aspectj.weaver.AjAttribute$AjSynthetic@14d92f0 : GETSTATIC NameAspect.ajc$perSingletonInstance LNameAspect; IFNONNULL L0 NEW org.aspectj.lang.NoAspectBoundException DUP LDC "NameAspect" GETSTATIC NameAspect.ajc$initFailureCause Ljava/lang/Throwable; INVOKESPECIAL org.aspectj.lang.NoAspectBoundException.&lt;init&gt; (Ljava/lang/String;Ljava/lang/Throwable;)V ATHROW L0: GETSTATIC NameAspect.ajc$perSingletonInstance LNameAspect; ARETURN end public static NameAspect aspectOf() public static boolean hasAspect() org.aspectj.weaver.AjAttribute$AjSynthetic@12e2f2e : GETSTATIC NameAspect.ajc$perSingletonInstance LNameAspect; IFNULL L0 ICONST_1 IRETURN L0: ICONST_0 IRETURN end public static boolean hasAspect() private static void ajc$postClinit() org.aspectj.weaver.AjAttribute$AjSynthetic@1f0523b : NEW NameAspect DUP INVOKESPECIAL NameAspect.&lt;init&gt; ()V PUTSTATIC NameAspect.ajc$perSingletonInstance LNameAspect; RETURN end private static void ajc$postClinit() end public class NameAspect when weaving type NameAspect when weaving aspects when weaving when batch building BuildConfig[D:\workspace\.metadata\.plugins\org.eclipse.ajdt.core\AspectSandBox.generated.lst] #Files=8
Internal exception with complex declare annotation statement that affects injected methods I have an aspect that declares an annotation on a method based on a complex condition : Basically that means that every type that is annotated with should have all of its public non static methods be annotated with either. If neither of nor is present on such a method, is added by default. I have another aspect that makes every type annotated with implement the Named interface :  As soon as I annotate a class with both and , I get an internal null pointer exception at weave time. However if I change the first aspect to say : : ; instead of the  one, everything compiles fine. Here is a link to a small application that exhibits the bug. : http://www.cs.mcgill.ca/~jlegar/src_jslegare.zip ========== Here is the errorwhen weaving type when weaving aspects when weaving when batch building 
******
weaver/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.matches(AnnotatedElement),True
#####
AspectJ
122728
d69ce9aebb3ed4410f07e9992105748b69a0ff5e
ajdoc crashes When trying to run ajdoc on a moderate size code base (266 classes / interfaces / aspects), ajdoc crashes. Here's what happens: D:\work\napa\jnapa\core&gt;ajdoc -source 1.5 -classpath D:\work\napa\jnapa\core\lib\aspectjrt.jar;D:\work\napa\jnapa\core\l ib\dom4j-1.5.2.jar;D:\work\napa\jnapa\core\lib\groovy-all-1.0-jsr-03.jar -d D:\work\napa\jnapa\core\build\doc\internal - author -package -argfile D:\work\napa\jnapa\core\jnapafilelist34352.lst &gt; Calling ajc... D:\work\napa\jnapa\commons\utils\src\fi\napa\util\aspects\CachingAspect.aj:72 [warning] advice defined in fi.napa.util.a spects.CachingAspect has not been applied [Xlint:adviceDidNotMatch] 1 warning &gt; Building signature files... An internal error occured in ajdoc Please copy the following text into an email message and send it, along with any additional information you can add to: aspectj-dev@eclipse.org java.lang.IndexOutOfBoundsException: Index: 3, Size: 3 java.lang.IndexOutOfBoundsException: Index: 3, Size: 3 at java.util.ArrayList.RangeCheck(ArrayList.java:546) at java.util.ArrayList.get(ArrayList.java:321) at org.aspectj.tools.ajdoc.StubFileGenerator.processMembers(StubFileGenerator.java:124) at org.aspectj.tools.ajdoc.StubFileGenerator.processTypeDeclaration(StubFileGenerator.java:99) at org.aspectj.tools.ajdoc.StubFileGenerator.processMembers(StubFileGenerator.java:113) at org.aspectj.tools.ajdoc.StubFileGenerator.processTypeDeclaration(StubFileGenerator.java:99) at org.aspectj.tools.ajdoc.StubFileGenerator.processFile(StubFileGenerator.java:61) at org.aspectj.tools.ajdoc.StubFileGenerator.doFiles(StubFileGenerator.java:38) at org.aspectj.tools.ajdoc.Main.main(Main.java:157) The file jnapafilelist34352.lst contains only file entries w/ absolute paths, e.g. D:\work\napa\jnapa\core\src\fi\napa\core\tableprocessing\transfer\mapping\Transformation.java I am using ajc and ajdoc 1.5.0 release version. I'll be happy to provide any other information that may help in solving this issue. D:\work\napa\jnapa\core&gt;ajdoc -v ajdoc version 1.5.0 D:\work\napa\jnapa\core&gt;ajc -v AspectJ Compiler 1.5.0 built on Tuesday Dec 20, 2005 at 12:05:54 GMT
ajdoc crashes When trying to run ajdoc on a moderate size code base (266 classes / interfaces / aspects), ajdoc crashes. Here's what happens:  has not been applied 1 warning &gt; Building signature files... An internal error occured in ajdoc Please copy the following text into an email message and send it, along with any additional information you can add to: aspectj-dev@eclipse.org The file contains only file entries w/ absolute paths, e.g. I am using ajc and ajdoc 1.5.0 release version. I'll be happy to provide any other information that may help in solving this issue. 
******
ajdoc/testdata/pr122728/src/pack/MyEnum,False,test
ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.processMembers(List, PrintWriter, boolean),True
ajdoc/testdata/pr122728/src/pack/ClassWithInnerEnum.somemethod(),False,new_method|test_method
ajdoc/testdata/pr122728/src/pack/EnumWithMethods.EnumWithMethods(),False,new_method|test_method
ajdoc/testsrc/org/aspectj/tools/ajdoc/AjdocTests.suite(),False,new_method|test_method
ajdoc/testsrc/org/aspectj/tools/ajdoc/EnumTest.setUp(),False,new_method|test_method
ajdoc/testsrc/org/aspectj/tools/ajdoc/EnumTest.tearDown(),False,new_method|test_method
ajdoc/testsrc/org/aspectj/tools/ajdoc/EnumTest.testEnum(),False,new_method|test_method
ajdoc/testsrc/org/aspectj/tools/ajdoc/EnumTest.testInlinedEnum(),False,new_method|test_method
ajdoc/testsrc/org/aspectj/tools/ajdoc/EnumTest.testEnumWithMethods(),False,new_method|test_method
#####
AspectJ
58520
bbdd4966a79864ea9979da81ca4725d6471b2fa9
ajdoc doesn't navigate to target details in some cases When a file is advised, javadoc uses the following naming convention for setting its "A NAME": convertCheckedException(java.lang.Throwable) However, ajdoc uses the unqualified name for the argument, resuting in the follwing in-file anchor link: &lt;class-name&gt;.html#convertCheckedException(Throwable)? Which fails to navigate to the anchor within the file, although it does always go to the right file.
ajdoc doesn't navigate to target details in some cases When a file is advised, javadoc uses the following naming convention for setting its "A NAME": However, ajdoc uses the unqualified name for the argument, resuting in the follwing in-file anchor link: &lt;class-name&gt;.html# Which fails to navigate to the anchor within the file, although it does always go to the right file.
******
ajdoc/testdata/pr119453/src/pack/C.method3(String),False,new_method|test_method
ajdoc/testsrc/org/aspectj/tools/ajdoc/AjdocTests.suite(),False,test_method
ajdoc/testsrc/org/aspectj/tools/ajdoc/FullyQualifiedArgumentTest.setUp(),False,new_method|test_method
ajdoc/testsrc/org/aspectj/tools/ajdoc/FullyQualifiedArgumentTest.tearDown(),False,new_method|test_method
ajdoc/testsrc/org/aspectj/tools/ajdoc/FullyQualifiedArgumentTest.testPr58520(),False,new_method|test_method
ajdoc/testsrc/org/aspectj/tools/ajdoc/FullyQualifiedArgumentTest.checkContentsOfA(),False,new_method|test_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmElementFormatter.setParameters(MethodDeclaration, IProgramElement),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.visit(MethodDeclaration, ClassScope),True
#####
AspectJ
123612
ab2f89bd7314680eda5ff5efeb7e97409ff878d1
ArrayIndexOutOfBoundsException with incremental and declare @type Given the following code: ------------------------------------------------- public aspect A { declare @type : C : @MyAnnotation; } @interface MyAnnotation { } class C { } ------------------------------------------------- if you comment out the declare @type statement and do an incremental build, then the following ArrayIndexOutOfBoundsException occurs: java.lang.ArrayIndexOutOfBoundsException: 0 at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.doDeclareAnnotations(AjLookupEnvironment.java:754) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:571) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveIntertypes(AjLookupEnvironment.java:357) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:209) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:254) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:163) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) This is against the latest code in HEAD.
with incremental and declare Given the following code: ------------------------------------------------- ------------------------------------------------- if you comment out the declare @type statement and do an incremental build, then the following This is against the latest code in HEAD.
******
tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.testPr123612(),False,new_method|test_method
weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.clearCaches(),True
#####
AspectJ
124808
01a8b2eb36e1a34c80697c2034f9657b74dc281a
[generics] detecting field-get of field of parameterized type. Hi, Here is the second generics issue: Java code: ========== public class Test&lt;T extends Integer&gt; { Set&lt;T&gt; ints = new HashSet&lt;T&gt;(); public Set&lt;T&gt; foo() { return ints; } public static void main(String[] args) { Test&lt;Integer&gt; t = new Test&lt;Integer&gt;(); Set&lt;Integer&gt; ints = t.foo(); } } Aspect: ======= public privileged aspect TestAspect { pointcut gettingMemberCollection(Test t) : target(t) &amp;&amp; get(!public Set&lt;Number+&gt; com.mprv.secsph.*.*) &amp;&amp; !within(TestAspect); after (Test test) : gettingMemberCollection(test) { System.out.println("GO Aspects!"); } } Compiler output: ================ warning at after (Test test) : gettingMemberCollection(test) { ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /root/IdeaProjects/aspectsTest/src/com/mprv/secsph/TestAspect.aj:19:0::0 advice defined in com.mprv.secsph.TestAspect has not been applied [Xlint:adviceDidNotMatch] I would expect "gettingMemberCollection" to catch access to "ints" member of "Test" ... Thanks a lot! Misha.
[generics] detecting field-get of field of parameterized type. Hi, Here is the second generics issue: has not been applied [] I would expect "" to catch access to "ints" member of "Test" ... Thanks a lot! Misha.
******
tests/bugs151/pr124808/Test.foo(),False,new_method|test_method
tests/bugs151/pr124808/Test.main(String[]),False,new_method|test_method
tests/bugs151/pr124808/TestAspect.gettingMemberCollection(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.testParameterizedCollectionFieldMatching_pr124808(),False,new_method|test_method
weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.matchesTypeVariable(TypeVariableReferenceType),True
weaver/src/org/aspectj/weaver/patterns/TypePattern.matchesSubtypes(ResolvedType),True
#####
AspectJ
124654
28f8c695ccc8513e9dcbe0c4fb6ebdc71cf84313
Capture method annotation in generic aspect does not compile The following aspect won't compile with aspect 1.5: package aj; import java.lang.annotation.Annotation; public abstract aspect GenericAnnotation&lt;A extends Annotation&gt; { pointcut annotatedCall(A a) : call(@A * *.*(..)) &amp;&amp; @annotation(a); /* does not compile */ before(A a) : annotatedCall(a) { System.out.println(a.annotationType()); } /* */ /* OK */ before(A a) : call(@A * *.*(..)) &amp;&amp; @annotation(a) { System.out.println(a.annotationType()); } } ---------------------- &gt;ajc -1.5 -d aj src\aj\* ...\src\aj\GenericAnnotation.aj:10 [error] incompatible type, expected java.lang.annotation.Annotation found BindingTypePattern(TA;, 0). Check the type specified in your pointcut before(A a) : annotatedCall(a) { 1 error ---------------- Commenting out the first advice lets this program run as expected: package aj; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; public class Main { @Retention(RetentionPolicy.RUNTIME) @interface MyAnnotation { } static aspect ConcreteAnnotation extends GenericAnnotation&lt;MyAnnotation&gt; { } public static void main(String[] args) { someMethod(); } @MyAnnotation private static void someMethod() { } }
Capture method annotation in generic aspect does not compile The following aspect won't compile with aspect 1.5: package aj; import java.lang.annotation.Annotation; ---------------------- :10 [error] incompatible type, expected . Check the type specified in your pointcut  ---------------- Commenting out the first advice lets this program run as expected: 
******
tests/bugs151/pr124654/GenericAnnotation.annotatedCall(A),False,new_method|test_method
tests/bugs151/pr124654/TestSubAspect.main(String),False,new_method|test_method
tests/bugs151/pr124654/TestSubAspect.run(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.testGenericAspectsAndAnnotations_pr124654(),False,new_method|test_method
weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.resolveBindings(IScope, Bindings),True
#####
AspectJ
124999
a4bd19d25597a31e1b76cc5fc188c3112bf0f5ff
[generics] Incorrect call to generic inherited method in around advice The following case produces a runtime error: package aj; public abstract aspect GenericInheritedMethod&lt;T&gt; { protected final T getSomething() { return null; } } package aj; aspect UseInheritedMethod extends GenericInheritedMethod&lt;Integer&gt; { // works as expected before() : execution(void someMethod()) { System.out.println(getSomething()); } // Runtime Error void around() : execution(void someMethod()) { System.out.println(getSomething()); } public static void main(String[] args) { someMethod(); } private static void someMethod() { } } &gt;java aj.UseInheritedMethod null Exception in thread "main" java.lang.NoSuchMethodError: aj.UseInheritedMethod.getSomething()Ljava/lang/Integer; at aj.UseInheritedMethod.ajc$inlineAccessMethod$aj_UseInheritedMethod$aj_UseInheritedMethod$getSomething(UseInheritedMethod.aj) at aj.UseInheritedMethod.ajc$around$aj_UseInheritedMethod$2$c74e36b7(UseInheritedMethod.aj:12) at aj.UseInheritedMethod.someMethod(UseInheritedMethod.aj:1) at aj.UseInheritedMethod.main(UseInheritedMethod.aj:16) The "inlineAccessMethod" should call "getSomething()Ljava/lang/Object;" as the before advice does.
[generics] Incorrect call to generic inherited method in around advice The following case produces a runtime error: The "" should call  as the before advice does.
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.getAccessibleMethod(MethodBinding, TypeBinding),True
tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.testCallInheritedGenericMethod_pr124999(),False,new_method|test_method
#####
AspectJ
121395
551b446bec83bef0f7df1f57353fdb4297bc14a6
invalid aspectj path throws filenotfoundexception An invalid aspectj path (missing jar file) throws an filenotfoundexception: java.io.FileNotFoundException at java.io.FileInputStream.open(Native Method) at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:106) at org.aspectj.weaver.bcel.BcelWeaver.addAspectsFromJarFile(BcelWeaver.java:202) at org.aspectj.weaver.bcel.BcelWeaver.addLibraryJarFile(BcelWeaver.java:192) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.initBcelWorld(AjBuildManager.java:623) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:209) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:185) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:163) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) FileNotFoundException thrown: /Users/frankstolle/Documents/workspace/lib_aspects/deploy/lib_aspects.jar (No such file or directory) should generate an problem entry in the problems-list.
invalid aspectj path throws An invalid aspectj path (missing jar file) throws an (No such file or directory) should generate an problem entry in the problems-list.
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.initBcelWorld(IMessageHandler),True
tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.configureAspectPath(Set),False,new_method|test_method
tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.reset(),False,new_method|test_method
tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.setAspectpath(Set),False,new_method|test_method
tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.getAspectPath(),False,test_method
tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.testInvalidAspectpath_pr121395(),False,new_method|test_method
#####
AspectJ
125101
efb20c5a3eeecb85c059110b3494f7b39593ab28
StackOverFlow in ReferenceType.isAssignableFrom() Hi. I am weaving two aspects into a jar file "jar-to-jar". ajc 1.5.0 gives me a huge error message (see attachement). Would be great if I could get any recommendations on this. Thanks! Eric
in Hi. I am weaving two aspects into a jar file "jar-to-jar". ajc 1.5.0 gives me a huge error message (see attachement). Would be great if I could get any recommendations on this. Thanks! Eric
******
weaver/src/org/aspectj/weaver/bcel/BcelWorld.addSourceObjectType(JavaClass),False,comments
#####
AspectJ
125405
2602c786913715b1b0530037d43cf47e682637cc
Bad user template code can lead to exception thrown message To reproduce: Create a new AspectJ project, and create a new aspect: package test; public aspect ATest { // main public static void main(String[] args) { } } ==== Then, write ATest&lt;T&gt; instead of just ATest and then save. You should now get the warning: 2 only abstract aspects can have type parameters ATest.aj So far so good. Now, remove the newly added "&lt;T&gt;" and save again. This should happen: java.lang.IllegalStateException at org.aspectj.weaver.ResolvedMemberImpl.parameterizedWith(ResolvedMemberImpl.java:605) at org.aspectj.weaver.ResolvedMemberImpl.parameterizedWith(ResolvedMemberImpl.java:590) at org.aspectj.weaver.ReferenceType.getDeclaredMethods(ReferenceType.java:421) at org.aspectj.weaver.ResolvedType.getDeclaredAdvice(ResolvedType.java:699) at org.aspectj.weaver.ResolvedType.getDeclaredShadowMungers(ResolvedType.java:736) at org.aspectj.weaver.ResolvedType.collectShadowMungers(ResolvedType.java:572) at org.aspectj.weaver.ResolvedType.collectCrosscuttingMembers(ResolvedType.java:501) at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect(CrosscuttingMembersSet.java:66) at org.aspectj.weaver.bcel.BcelWeaver.prepareForWeave(BcelWeaver.java:439) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:283) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:178) at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:254) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:163) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) IllegalStateException thrown: Can't ask to parameterize a member of non-generic type: test.ATest kind(raw)
Bad user template code can lead to exception thrown message To reproduce: Create a new AspectJ project, and create a new aspect: //  ==== Then, write; instead of just and then save. You should now get the warning: 2 only abstract aspects can have type parameters So far so good. Now, remove the newly added ;" and save again. This should happen: : Can't ask to parameterize a member of non-generic type:
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.addSourceTypeBinding(SourceTypeBinding, CompilationUnitDeclaration),True
tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.testPr125405(),False,new_method|test_method
tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.checkForError(String),False,new_method|test_method
weaver/src/org/aspectj/weaver/ReferenceType.demoteToSimpleType(),False,new_method
#####
AspectJ
125810
795cd9eadc225d0c1c6d0297853bcd5ca8937be4
Missing error when inherited abstract pointcut not made concrete in sub-@aspect An error is issued when a sub-aspect does not implement an inherited abstract pointcut. This is missing for a sub-@aspect.
Missing error when inherited abstract pointcut not made concrete in sub-@aspect An error is issued when a sub-aspect does not implement an inherited abstract pointcut. This is missing for a sub-@aspect.
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.resolvePointcutDeclarations(ClassScope),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.isAnnotationStyleAspectDeclaration(TypeDeclaration),False,new_method
#####
AspectJ
126328
8933b6a6c18860da97a4c89eb113d44bc67525ad
IlegalStateException : zip file closed If there are &gt; 1000 jars on the combination of classpath, aspectpath, and inpath, it is possible for a ZipFile to be closed and not successfully reopened before trying to read from it again.
zip file closed If there are &gt; 1000 jars on the combination of ,, and , it is possible for a to be closed and not successfully reopened before trying to read from it again.
******
weaver/src/org/aspectj/weaver/bcel/ClassPathManager.ensureOpen(),True
weaver/src/org/aspectj/weaver/bcel/ClassPathManager.isReallyOpen(),False,new_method
#####
AspectJ
123212
d856e4fedb65e12104851967690ef751b2c7b09b
Skip subversion resources when copying files from input to output folders Exception when compile a project under svn. java.io.FileNotFoundException at java.io.FileOutputStream.open(Native Method) at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:179) at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:131) at org.aspectj.util.FileUtil.makeOutputStream(FileUtil.java:1258) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.writeResource(AjBuildManager.java:466) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.copyResourcesFromFile(AjBuildManager.java:444) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.copyResourcesToDestination(AjBuildManager.java:386) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:298) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:185) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:163) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) FileNotFoundException thrown: /home/chomats/Fede/svn/fede-repos/Tool.Product.ProductServer/classes/.svn/format (Permission non accord¨¦e)
Skip subversion resources when copying files from input to output folders Exception when compile a project under svn.  (Permission non accorde)
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.acceptResource(String),True
#####
AspectJ
120356
f743fb210e1b7aa8cdb45e7bda53aa336f912edf
@AJ decl err/warn does not show cross structure view Perhaps an issue in the ASM struct for DEOW since cross struct. is empty in AJDT , despite error / warning gutter and message is ok.
@AJ decl err/warn does not show cross structure view Perhaps an issue in the ASM struct for DEOW since cross struct. is empty in AJDT , despite error / warning gutter and message is ok.
******
tests/bugs151/pr120356/A,False,test
tests/bugs151/pr120356/C.warningMethod(),False,new_method|test_method
tests/bugs151/pr120356/C.badMethod(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.testAtAspectDEOWInStructureModel_pr120356(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.testAtAspectNoNPEWithDEOWWithoutStructureModel_pr120356(),False,new_method|test_method
weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.setDeclareErrorOrWarningLocation(DeclareErrorOrWarning, AjAttributeFieldStruct),False,new_method
#####
AspectJ
125475
deaa590e83b2e7707fecd5281f342d13246b36d0
[@AspectJ] ajc cannot compile empty @Pointcut I get this error: C:\temp\ajcSandbox\ajcTest27856.tmp\TestEmptyPointcutAtAspect.java:8:0::0 Method annotated with @Pointcut() for abstract pointcut must be abstract when compiling this aspect with ajc (it's fine with javac): @Aspect public class TestEmptyPointcutAtAspect { @Pointcut("") protected void scope () {} }
[@AspectJ] ajc cannot compile empty I get this error: Method annotated with for abstract pointcut must be abstract when compiling this aspect with ajc (it's fine with javac):
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.convertToPointcutDeclaration(MethodDeclaration, ClassScope),True
weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.handlePointcutAnnotation(RuntimeAnnotations, AjAttributeMethodStruct),True
#####
AspectJ
122370
e87458179ab929aae2bc6966a6e092813bdd14a3
[@AspectJ] @DeclareParents/declare parents not equivalent Adding a setter to the Moody example makes it clear that the annotation style (@DeclareParents) results in different behavior than the classic (declare parents) style. Calling the setter in a "declare parents"-advised object behaves as one would expect. However, calling the setter with a "@DeclareParents"-advised object has no effect -- that is, you can call the setter (and see that it's been called) and immediately call the getter, only to find that the value didn't change. The following examples (all in "package moody;") illustrate: public enum Mood { HAPPY, JOLLY } Classic style: ------------- public aspect ClassicMoodIndicator { public interface Moody { Mood getMood(); void setMood(Mood mood); } private Mood Moody.mood = Mood.HAPPY; public Mood Moody.getMood() { return mood; } public void Moody.setMood(Mood mood) { this.mood = mood; } declare parents : moody.ClassicMoodImplementor implements Moody; } public class ClassicMoodImplementor { } Annotation style: ---------------- import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.DeclareParents; @Aspect public class AnnotationMoodIndicator { public interface Moody { Mood getMood(); void setMood(Mood mood); } public static class MoodyImpl implements Moody { private Mood mood = Mood.HAPPY; public Mood getMood() { return mood; } public void setMood(Mood mood) { this.mood = mood; } } @DeclareParents(value="moody.AnnotationMoodImplementor",defaultImpl=MoodyImpl.class) private Moody implementedInterface; } public class AnnotationMoodImplementor { } JUnit TestCase: -------------- import junit.framework.TestCase; public class MoodTester extends TestCase { public MoodTester(String name) { super(name); } public void testClassic() { ClassicMoodImplementor cmi0 = new ClassicMoodImplementor(); ClassicMoodImplementor cmi1 = new ClassicMoodImplementor(); assertEquals("cmi0 should be HAPPY", Mood.HAPPY, cmi0.getMood()); cmi1.setMood(Mood.JOLLY); assertEquals("cmi1 should be JOLLY", Mood.JOLLY, cmi1.getMood()); assertEquals("cmi0 should be *still* be HAPPY", Mood.HAPPY, cmi0.getMood()); } public void testAnnotation() { AnnotationMoodImplementor ami0 = new AnnotationMoodImplementor(); AnnotationMoodImplementor ami1 = new AnnotationMoodImplementor(); assertEquals("ami0 should be HAPPY", Mood.HAPPY, ((AnnotationMoodIndicator.Moody) ami0).getMood()); ((AnnotationMoodIndicator.Moody) ami1).setMood(Mood.JOLLY); assertEquals("ami1 should be JOLLY", Mood.JOLLY, ((AnnotationMoodIndicator.Moody) ami1).getMood()); assertEquals("ami0 should be *still* be HAPPY", Mood.HAPPY, ((AnnotationMoodIndicator.Moody) ami0).getMood()); } } Result: ------ The test run is as follows: ..F Time: 0.021 There was 1 failure: 1) testAnnotation(moody.MoodTester)junit.framework.AssertionFailedError: ami1 should be JOLLY expected:&lt;JOLLY&gt; but was:&lt;HAPPY&gt; at moody.MoodTester.testAnnotation(MoodTester.java:27) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at moody.MoodTester.main(MoodTester.java:7) FAILURES!!! Tests run: 2, Failures: 1, Errors: 0 For classic, you can see that cmi1.setMood was successful and cmi0/cmi1 are decoupled (that is, calling setMood on cmi1 has no impact on cmi0). The annotation style, however, fails because ami1.setMood appears to have done nothing. The result should have been that ami1 is JOLLY and ami0 HAPPY (I include the second assert because both ami0 &amp; ami1 ended up JOLLY in RC1). The current behavior makes @DeclareParents unusable for retaining field state (near as I can tell, it retains state throughout the method invocation, but not beyond it, like it is creating and discarding a backing object with each method invocation).
[] /declare parents not equivalent Adding a setter to the Moody example makes it clear that the annotation style () results in different behavior than the classic (declare parents) style. Calling the setter in a "declare parents"-advised object behaves as one would expect. However, calling the setter with a ""-advised object has no effect -- that is, you can call the setter (and see that it's been called) and immediately call the getter, only to find that the value didn't change. The following examples (all in ";") ------ The test run is as follows: ..F Time: 0.021 There was 1 failure: 1)  FAILURES!!! Tests run: 2, Failures: 1, Errors: 0 For classic, you can see that was successful and cmi0/cmi1 are decoupled (that is, calling setMood on cmi1 has no impact on cmi0). The annotation style, however, fails because appears to have done nothing. The result should have been that ami1 is JOLLY and ami0 HAPPY (I include the second assert because both ami0 &amp; ami1 ended up JOLLY in RC1). The current behavior makes unusable for retaining field state (near as I can tell, it retains state throughout the method invocation, but not beyond it, like it is creating and discarding a backing object with each method invocation).
******
tests/bugs151/pr122370/moody/AnnotationMoodImplementor,False,new_class|test_class
tests/bugs151/pr122370/moody/AnnotationMoodIndicator.getMood(),False,new_method|test_method
tests/bugs151/pr122370/moody/AnnotationMoodIndicator.setMood(Mood),False,new_method|test_method
tests/bugs151/pr122370/moody/MainClass.main(String[]),False,new_method|test_method
tests/bugs151/pr122370/moody/Mood,False,new_class|test_class
tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.testAtAspectDeclareParentsRetainsFieldState_pr122370(),False,new_method|test_method
weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.mungeMethodDelegate(BcelClassWeaver, MethodDelegateTypeMunger),True
#####
AspectJ
128128
da562415d5349c7e1bb7e7d794cbc7c463e5a5ca
iajc doesn't fail Ant build when compile errors occur. The iajc ant task doesn't failonerror anymore. The most relevant line is AjcTask.java:1256 with holder.numMessages(IMessage.ERROR, false) always returning 0. The holder:MessageHandler instance delegates messages to an interceptor AntMessageHandler. The AntMessageHandler is (almost) always consuming the messages, leaving the MessageHandler.java:108 to return without recording any messages itself. I would have liked to submit a patch with this bug report but I'm not yet sure what the correct interceptor.handleMessage(message) behavior should be in this case. Note: The AntMessageHandler properly reporting message priorities ("error" vs. "warn") is welcome functionality - thanks.
iajc doesn't fail Ant build when compile errors occur. The iajc ant task doesn't anymore. The most relevant line is :1256 with always returning 0. The instance delegates messages to an interceptor . The is (almost) always consuming the messages, leaving the :108 to return without recording any messages itself. I would have liked to submit a patch with this bug report but I'm not yet sure what the correct  behavior should be in this case. Note: The properly reporting message priorities ("error" vs. "warn") is welcome functionality - thanks.
******
taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.executeInSameVM(String[]),True
taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.AntMessageHandler(TaskLogger, boolean),True
taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.AntMessageHandler(TaskLogger, boolean, boolean),False,new_method
#####
AspectJ
128699
f95d2c96edd293b98c27a19bb9f3cc2748b365cb
"Incorrect error on ""declare"" statements" The error associated with the declare construct is incorrect. The current message is: "expected one of error, warning, parents, soft, dominates" dominates should be changed to "precendence" and new annotation related declararions should be mentioned. Here is a suggestion: "expected one of error, warning, parents, soft, precedence, @type, @method, @constructor, @field"
"Incorrect error on ""declare"" statements" The error associated with the declare construct is incorrect. The current message is: "expected one of error, warning, parents, soft, dominates" dominates should be changed to "precendence" and new annotation related declararions should be mentioned. Here is a suggestion: "expected one of error, warning, parents, soft, precedence, "
******
weaver/src/org/aspectj/weaver/patterns/PatternParser.parseDeclare(),True
#####
AspectJ
128655
7279108648417c97156e45dbe2ceeb46cdf51d9f
[annotations]Compiler crashes (possibly due to declare @type) AJDT version: 1.3.1 (20060214104738) AspectJ version: 1.5.1.20060131132251 Not very sure of the reason and couldn't reproduce on a smaller code base. The compiler crashes on incremental compilation, but never when I do full "clean" build. Here is the stack trace: java.lang.NullPointerException at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.MethodBinding.getAnnotationTagBits(MethodBinding.java:447) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.doDeclareAnnotations(AjLookupEnvironment.java:754) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:571) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:498) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.doPendingWeaves(AjLookupEnvironment.java:365) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:179) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:824) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:258) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:164) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) NullPointerException thrown: null
[annotations]Compiler crashes (possibly due to declare @type) AJDT version: 1.3.1 (20060214104738) AspectJ version: 1.5.1.20060131132251 Not very sure of the reason and couldn't reproduce on a smaller code base. The compiler crashes on incremental compilation, but never when I do full "clean" build. Here is the stack trace: thrown: null
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.doDeclareAnnotations(DeclareAnnotation, SourceTypeBinding, boolean),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.createAnnotationFromBcelAnnotation(AnnotationX, int, EclipseFactory),False,new_method
#####
AspectJ
128744
7a2087ef985e8af73045bac1e7e0195bb87c7f40
LTW doesn't work using JRE1.4 in Eclipse LTW doesn't work using JRE1.4 in Eclipse now I want to support JRE1.4 when LTW. I defined a aop.xml file in application META-INF path, it works fine using JRE1.4 in command-line, aop.xml file is used when LTW, the command as below: "D:\work\BTM\eclipse 3.1.1\eclipse-SDK-3.1.1-win32\eclipse-1.4.2\jre\bin\java" -classpath "C:\aspectj1.5\lib\aspectjweaver.jar" "-Djava.system.class.loader=org.aspectj.weaver.loadtime.WeavingURLClassLoader" "-Daj.class.path=D:\work\BTM\eclipse 3.1.1\jre1.4.2\myTest;C:\aspectj1.5\doc\examples\armtest\jar\btm-deps-e3.1.jar;C:\aspectj1.5\doc\examples\armtest\jar\btm-rt.jar" Hello but it doesn't work in Eclipse, I added upper command to VM arguments, it can't find aop.xml, because if I changed aop.xml to be wrong, there is no any error when execute the application in Eclipse , but there will be error when execute it in command-line, based on this point, I think that aop.xml didn't be used in Eclipse, I also tried to add "-Daj.aspect.path=D:\work\BTM\eclipse 3.1.1\jre1.4.2\myTest", but it is still. so I want to confirm if AspectJ only supports command-line for JRE1.4? doesn't support Eclipse for JRE1.4? BTW, my Eclipse env: eclipse 3.1.1 + ajdt_1.3_for_eclipse_3.1 + Sun JDK 1.4.2. I also tried to use eclipse 3.1.2, but this problem is still existed.
LTW doesn't work using JRE1.4 in Eclipse LTW doesn't work using JRE1.4 in Eclipse now I want to support JRE1.4 when LTW. I defined a aop.xml file in application META-INF path, it works fine using JRE1.4 in command-line, aop.xml file is used when LTW, the command as below: "D:\work\BTM\eclipse 3.1.1\eclipse-SDK-3.1.1-win32\eclipse-1.4.2\jre\bin\java" -classpath "C:\aspectj1.5\lib\aspectjweaver.jar" "-Djava.system.class.loader=org.aspectj.weaver.loadtime.WeavingURLClassLoader" "-Daj.class.path=D:\work\BTM\eclipse 3.1.1\jre1.4.2\myTest;C:\aspectj1.5\doc\examples\armtest\jar\btm-deps-e3.1.jar;C:\aspectj1.5\doc\examples\armtest\jar\btm-rt.jar" Hello but it doesn't work in Eclipse, I added upper command to VM arguments, it can't find aop.xml, because if I changed aop.xml to be wrong, there is no any error when execute the application in Eclipse , but there will be error when execute it in command-line, based on this point, I think that aop.xml didn't be used in Eclipse, I also tried to add "-Daj.aspect.path=D:\work\BTM\eclipse 3.1.1\jre1.4.2\myTest", but it is still. so I want to confirm if AspectJ only supports command-line for JRE1.4? doesn't support Eclipse for JRE1.4? BTW, my Eclipse env: eclipse 3.1.1 + ajdt_1.3_for_eclipse_3.1 + Sun JDK 1.4.2. I also tried to use eclipse 3.1.2, but this problem is still existed.
******
loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.validate(),True
tests/bugs151/pr128744/Hello.main(String[]),False,new_method|test_method
tests/bugs151/pr128744/Hello.sayHello(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.testBrokenLTW_pr128744(),False,new_method|test_method
#####
AspectJ
122742
3fa1bddb79a5e20a38cb39555e932df46f3d4dfa
[@AspectJ] VerifyError with @AfterThrowing/@AfterReturning and extra JoinPoint argument If an @AspectJ aspect advises itself using after throwing advice that itself throws an exception running the resulting program causes a VerifyError: java.lang.VerifyError: (class: A, method: stop signature: ()V) catch_type not a subclass of Throwable at java.lang.Class.getDeclaredMethods0(Native Method) at java.lang.Class.privateGetDeclaredMethods(Class.java:2365) at java.lang.Class.getMethod0(Class.java:2611) at java.lang.Class.getMethod(Class.java:1579) at org.aspectj.tools.ajc.AjcTestCase.run(AjcTestCase.java:608) at org.aspectj.testing.RunSpec.execute(RunSpec.java:56) at org.aspectj.testing.AjcTest.runTest(AjcTest.java:68) at org.aspectj.testing.XMLBasedAjcTestCase.runTest(XMLBasedAjcTestCase.java:111) at org.aspectj.systemtest.ajc150.Ajc150Tests.testError(Ajc150Tests.java:877) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult$1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)
with and extra argument If an @AspectJ aspect advises itself using after throwing advice that itself throws an exception running the resulting program causes a
******
tests/bugs151/pr122742/AfterReturningTest.main(String[]),False,new_method|test_method
tests/bugs151/pr122742/AfterReturningTest.afterJP(JoinPoint, B1),False,new_method|test_method
tests/bugs151/pr122742/AfterReturningTest.afterJPSP(JoinPoint.StaticPart, B1),False,new_method|test_method
tests/bugs151/pr122742/AfterReturningTest.afterJPESP(JoinPoint.EnclosingStaticPart, B1),False,new_method|test_method
tests/bugs151/pr122742/AfterReturningTest.afterJPESP2(JoinPoint, JoinPoint.EnclosingStaticPart, B1),False,new_method|test_method
tests/bugs151/pr122742/AfterReturningTest.afterJP2(B1, JoinPoint),False,new_method|test_method
tests/bugs151/pr122742/AfterReturningTest.start(),False,new_method|test_method
tests/bugs151/pr122742/AfterReturningTest.stop(),False,new_method|test_method
tests/bugs151/pr122742/AfterThrowingTest.main(String[]),False,new_method|test_method
tests/bugs151/pr122742/AfterThrowingTest.handleExceptionJP(JoinPoint, Exception),False,new_method|test_method
tests/bugs151/pr122742/AfterThrowingTest.handleExceptionJPESP(JoinPoint.EnclosingStaticPart, Exception),False,new_method|test_method
tests/bugs151/pr122742/AfterThrowingTest.handleExceptionJPESP(JoinPoint, JoinPoint.EnclosingStaticPart, Exception),False,new_method|test_method
tests/bugs151/pr122742/AfterThrowingTest.handleExceptionJP2(JoinPoint, Exception),False,new_method|test_method
tests/bugs151/pr122742/AfterThrowingTest.start(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.testAtAspectVerifyErrorWithAfterThrowingAndthisJoinPoint_pr122742(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.testAtAspectVerifyErrorWithAfterReturningAndthisJoinPoint_pr122742(),False,new_method|test_method
weaver/src/org/aspectj/weaver/Advice.getExtraParameterType(),True
#####
AspectJ
128618
89d66dc89110db0f89538a7b78308db61e5539cc
[incremental] XLint warnings in the wrong place with incremental compilation The zip file I am about to attach contains two AspectJ project, one depending on the other. If you make a small change to MainClass.java in 'Test Project' and save you will see a strange warning in that class - "advice defined in ras.FFDC has not been applied [Xlint:adviceDidNotMatch]". If you do a full build the warning goes away. Note that the error would be on line 36 if there were 36 lines in the class, which relates to a line in the FFDC aspect that contains advice.
[incremental] warnings in the wrong place with incremental compilation The zip file I am about to attach contains two AspectJ project, one depending on the other. If you make a small change to MainClass.java in 'Test Project' and save you will see a strange warning in that class - "advice defined in has not been applied [:]". If you do a full build the warning goes away. Note that the error would be on line 36 if there were 36 lines in the class, which relates to a line in the FFDC aspect that contains advice.
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverMessageHandler.handleMessage(IMessage),True
tests/multiIncremental/PR128618_2/base/mainpackage/MainClass.amethod(),False,new_method|test_method
tests/multiIncremental/PR128618_2/inc1/mainpackage/MainClass.amethod(),False,new_method|test_method
tests/multiIncremental/PR128618_2/inc1/mainpackage/MainClass.anotherMethod(),False,new_method|test_method
tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.testPr128618(),False,new_method|test_method
#####
AspectJ
128237
ba42a09551519a4b611ab06edb161ecb0c629f53
[@AspectJ] NPE on @AJ code with pointcut which contains logical OR operation. I got NullPointerException during compilation of any @AspectJ code with pointcut which contains logical OR operation. -----Here is my test case for this bug---------------- import java.io.IOException; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Pointcut; @Aspect class AbstractTracer { @Pointcut("(execution(public * Foo+.* (..)) || execution(public * Foo+.blablabla (..)))&amp;&amp; !execution(public Foo+.new (..))") // @Pointcut("(execution(public * Foo+.* (..)))&amp;&amp; !execution(public Foo+.new (..))") protected void methodCall(){}; @Pointcut("methodCall()&amp;&amp; this(obj)") private void objectCall(Object obj) { }; @Around("objectCall(obj)") public Object aroundMethodCall(ProceedingJoinPoint thisJoinPoint, Object obj) throws Throwable { System.out.println("Before "+thisJoinPoint.getSignature().toString()); if ( thisJoinPoint.getSignature().toString().indexOf("A")!= -1) { throw new IOException("Hello from Aspect!"); // throw new Exception("Hello from Aspect!"); } Object result = thisJoinPoint.proceed(); System.out.println("After "+thisJoinPoint.getSignature().toString()); return result; } } public class Foo { public void methodA() throws IOException { throw new IOException("Foo.methodA"); } public void methodB(boolean b) throws Exception { if ( b ) { throw new Exception("Foo.methodB"); } } /** * @param args */ public static void main(String[] args) { Foo obj = new Foo(); try { obj.methodA(); System.out.println("Something going wrong!"); } catch ( IOException e) { System.out.println("All right! We got exception"); e.printStackTrace(System.out); } try { obj.methodB(false); System.out.println("All right!"); } catch ( Exception e) { System.out.println("Something going wrong! We got exception"); e.printStackTrace(System.out); } } } ------------------------------------------------------ and here is acj error log ------------------------------------------------------ ---- AspectJ Properties --- AspectJ Compiler 1.5.0 built on Tuesday Dec 20, 2005 at 12:05:54 GMT ---- Dump Properties --- Dump file: ajcore.20060216.175147.608.txt Dump reason: java.lang.NullPointerException Dump on exception: true Dump at exit condition: abort ---- Exception Information --- java.lang.NullPointerException at org.aspectj.weaver.bcel.BcelWeaver.validateOrBranch(BcelWeaver.java:611) at org.aspectj.weaver.bcel.BcelWeaver.validateBindings(BcelWeaver.java:579) at org.aspectj.weaver.bcel.BcelWeaver.rewritePointcuts(BcelWeaver.java:511) at org.aspectj.weaver.bcel.BcelWeaver.prepareForWeave(BcelWeaver.java:449) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:283) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:178) at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:156) at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112) at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60) at org.aspectj.tools.ajc.Main.run(Main.java:326) at org.aspectj.tools.ajc.Main.runMain(Main.java:240) at org.aspectj.tools.ajc.Main.main(Main.java:83) ---- System Properties --- java.runtime.name=Java(TM) 2 Runtime Environment, Standard Edition sun.boot.library.path=/opt/Java/jdk1.5.0_04/jre/lib/i386 java.vm.version=1.5.0_04-b05 java.vm.vendor=Sun Microsystems Inc. java.vendor.url=http://java.sun.com/ path.separator=: java.vm.name=Java HotSpot(TM) Client VM file.encoding.pkg=sun.io user.country=RU sun.os.patch.level=unknown java.vm.specification.name=Java Virtual Machine Specification user.dir=/home/kei/ajdt-workspace/AspectJTests java.runtime.version=1.5.0_04-b05 java.awt.graphicsenv=sun.awt.X11GraphicsEnvironment java.endorsed.dirs=/opt/Java/jdk1.5.0_04/jre/lib/endorsed os.arch=i386 java.io.tmpdir=/tmp line.separator= java.vm.specification.vendor=Sun Microsystems Inc. os.name=Linux sun.jnu.encoding=UTF-8 java.library.path=/opt/Java/jdk1.5.0_04/jre/lib/i386/client:/opt/Java/jdk1.5.0_04/jre/lib/i386:/opt/Java/jdk1.5.0_04/jre/../lib/i386:.: java.specification.name=Java Platform API Specification java.class.version=49.0 sun.management.compiler=HotSpot Client Compiler os.version=2.6.15-1.1831_FC4 user.home=/home/kei user.timezone=Europe/Kiev java.awt.printerjob=sun.print.PSPrinterJob file.encoding=UTF-8 java.specification.version=1.5 java.class.path=components/aspectjweaver.jar:components/aspectjtools.jar:components/aspectjrt.jar:components/aspectjlib.jar:/build/auroratest.jar:/opt/Java/aspectj1.5/lib/aspectjtools.jar:/opt/Java/jdk1.5.0_04/lib/tools.jar user.name=kei java.vm.specification.version=1.0 java.home=/opt/Java/jdk1.5.0_04/jre sun.arch.data.model=32 user.language=ru java.specification.vendor=Sun Microsystems Inc. java.vm.info=mixed mode, sharing java.version=1.5.0_04 java.ext.dirs=/opt/Java/jdk1.5.0_04/jre/lib/ext sun.boot.class.path=/opt/Java/jdk1.5.0_04/jre/lib/rt.jar:/opt/Java/jdk1.5.0_04/jre/lib/i18n.jar:/opt/Java/jdk1.5.0_04/jre/lib/sunrsasign.jar:/opt/Java/jdk1.5.0_04/jre/lib/jsse.jar:/opt/Java/jdk1.5.0_04/jre/lib/jce.jar:/opt/Java/jdk1.5.0_04/jre/lib/charsets.jar:/opt/Java/jdk1.5.0_04/jre/classes java.vendor=Sun Microsystems Inc. file.separator=/ java.vendor.url.bug=http://java.sun.com/cgi-bin/bugreport.cgi sun.io.unicode.encoding=UnicodeLittle sun.cpu.endian=little sun.cpu.isalist= ---- Command Line --- -1.5 Foo.java ---- Full Classpath --- /opt/Java/jdk1.5.0_04/jre/lib/rt.jar(39713589 bytes) /opt/Java/jdk1.5.0_04/jre/lib/i18n.jar(missing) /opt/Java/jdk1.5.0_04/jre/lib/sunrsasign.jar(missing) /opt/Java/jdk1.5.0_04/jre/lib/jsse.jar(549315 bytes) /opt/Java/jdk1.5.0_04/jre/lib/jce.jar(81799 bytes) /opt/Java/jdk1.5.0_04/jre/lib/charsets.jar(8627836 bytes) /opt/Java/jdk1.5.0_04/jre/classes(missing) /opt/Java/jdk1.5.0_04/jre/lib/ext/localedata.jar(802502 bytes) /opt/Java/jdk1.5.0_04/jre/lib/ext/sunpkcs11.jar(175414 bytes) /opt/Java/jdk1.5.0_04/jre/lib/ext/dnsns.jar(8176 bytes) /opt/Java/jdk1.5.0_04/jre/lib/ext/sunjce_provider.jar(153235 bytes) /opt/Java/jdk1.5.0_04/jre/lib/ext/bctsp-jdk15-129.jar(38357 bytes) /opt/Java/jdk1.5.0_04/jre/lib/ext/bcprov-jdk15-129.jar(1168795 bytes) /opt/Java/jdk1.5.0_04/jre/lib/ext/j3daudio.jar(1386793 bytes) /opt/Java/jdk1.5.0_04/jre/lib/ext/bcmail-jdk15-129.jar(124831 bytes) /opt/Java/jdk1.5.0_04/jre/lib/ext/j3dcore.jar(2514820 bytes) /opt/Java/jdk1.5.0_04/jre/lib/ext/j3dutils.jar(1401997 bytes) /opt/Java/jdk1.5.0_04/jre/lib/ext/vecmath.jar(290018 bytes) /opt/Java/jdk1.5.0_04/jre/lib/ext/bcprov-jdk14-129.jar(1157625 bytes) /opt/Java/jdk1.5.0_04/jre/lib/ext/bcmail-jdk14-129.jar(126679 bytes) /home/kei/ajdt-workspace/AspectJTests/components/aspectjweaver.jar(1746917 bytes) /home/kei/ajdt-workspace/AspectJTests/components/aspectjrt.jar(108647 bytes) /home/kei/ajdt-workspace/AspectJTests/components/aspectjlib.jar(7845 bytes) /build/auroratest.jar(missing) /opt/Java/jdk1.5.0_04/lib/tools.jar(7015499 bytes) /opt/Java/jdk1.5.0_04/jre/lib/ext/localedata.jar(802502 bytes) /opt/Java/jdk1.5.0_04/jre/lib/ext/sunpkcs11.jar(175414 bytes) /opt/Java/jdk1.5.0_04/jre/lib/ext/dnsns.jar(8176 bytes) /opt/Java/jdk1.5.0_04/jre/lib/ext/sunjce_provider.jar(153235 bytes) /opt/Java/jdk1.5.0_04/jre/lib/ext/bctsp-jdk15-129.jar(38357 bytes) /opt/Java/jdk1.5.0_04/jre/lib/ext/bcprov-jdk15-129.jar(1168795 bytes) /opt/Java/jdk1.5.0_04/jre/lib/ext/j3daudio.jar(1386793 bytes) /opt/Java/jdk1.5.0_04/jre/lib/ext/bcmail-jdk15-129.jar(124831 bytes) /opt/Java/jdk1.5.0_04/jre/lib/ext/j3dcore.jar(2514820 bytes) /opt/Java/jdk1.5.0_04/jre/lib/ext/j3dutils.jar(1401997 bytes) /opt/Java/jdk1.5.0_04/jre/lib/ext/vecmath.jar(290018 bytes) /opt/Java/jdk1.5.0_04/jre/lib/ext/bcprov-jdk14-129.jar(1157625 bytes) /opt/Java/jdk1.5.0_04/jre/lib/ext/bcmail-jdk14-129.jar(126679 bytes) /home/kei/ajdt-workspace/AspectJTests/components/aspectjweaver.jar(1746917 bytes) /home/kei/ajdt-workspace/AspectJTests/components/aspectjrt.jar(108647 bytes) /home/kei/ajdt-workspace/AspectJTests/components/aspectjlib.jar(7845 bytes) /build/auroratest.jar(missing) /opt/Java/jdk1.5.0_04/lib/tools.jar(7015499 bytes) ---- Compiler Messages --- abort ABORT -- (NullPointerException) null null java.lang.NullPointerException at org.aspectj.weaver.bcel.BcelWeaver.validateOrBranch(BcelWeaver.java:611) at org.aspectj.weaver.bcel.BcelWeaver.validateBindings(BcelWeaver.java:579) at org.aspectj.weaver.bcel.BcelWeaver.rewritePointcuts(BcelWeaver.java:511) at org.aspectj.weaver.bcel.BcelWeaver.prepareForWeave(BcelWeaver.java:449) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:283) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:178) at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:156) at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112) at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60) at org.aspectj.tools.ajc.Main.run(Main.java:326) at org.aspectj.tools.ajc.Main.runMain(Main.java:240) at org.aspectj.tools.ajc.Main.main(Main.java:83) ---- org.aspectj.weaver.bcel.BcelWorld ---- Shadow mungers: (around(extraFlags: 2): (persingleton(AbstractTracer) &amp;&amp; (((execution(public * Foo+.*(..)) || execution(public * Foo+.blablabla(..))) &amp;&amp; !execution(public Foo+.new(..))) &amp;&amp; this(BindingTypePattern(java.lang.Object, 1))))-&gt;java.lang.Object AbstractTracer.aroundMethodCall(org.aspectj.lang.ProceedingJoinPoint, java.lang.Object)) Type mungers: (BcelTypeMunger null) (BcelTypeMunger ResolvedTypeMunger(PrivilegedAccess, void java.lang.Object.())) Late Type mungers: (BcelTypeMunger null) ------------------------------------------------------------------ I got same error with latest (aspectj-DEVELOPMENT-20060216105006) night build.
[] NPE on code with pointcut which contains logical OR operation. I got during compilation of any  code with pointcut which contains logical OR operation. -----Here is my test case for this bug---------------- ------------------------------------------------------ and here is acj error log ------------------------------------------------------ ---- AspectJ Properties --- AspectJ Compiler 1.5.0 built on Tuesday Dec 20, 2005 at 12:05:54 GMT ---- Dump Properties --- Dump file: (7015499 bytes) ---- Compiler Messages --- abort ABORT -------------------------------------------------------------------- I got same error with latest (aspectj-DEVELOPMENT-20060216105006) night build.
******
tests/bugs151/pr128237.methodA(),False,new_method|test_method
tests/bugs151/pr128237.anotherMethod(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.testAtAspectNoNPEWithPcdContainingOrThisAndWildcard_pr128237(),False,new_method|test_method
weaver/src/org/aspectj/weaver/bcel/BcelWeaver.validateOrBranch(OrPointcut, Pointcut, int, String[], Pointcut[], Pointcut[]),True
#####
AspectJ
121616
d4219e12eaa86ed810392364931a92324dc2a67f
[@AspectJ]Lacking import for JoinPoint crahes the compiler Encountered during a JavaPolis demo. I was using a pre-release development version. However, reproducable with latest post-release development version as well. Create the following source file: package banking; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Pointcut; public class Main { public static void main(String[] args) { System.out.println("Main"); } } @Aspect class MainLogger { @Pointcut("execution(* main(..))") public void log(JoinPoint thisJoinPoint) { System.out.println("Before " thisJoinPoint"); } } Note that the import statement for JoinPoint is lacking. Compiling this source file crahses the compiler. Adding import statement for JoinPoint makes it work fine. C:\work\aop\src\workspace\CallDebugBug&gt;ajc -version AspectJ Compiler DEVELOPMENT built on Tuesday Dec 20, 2005 at 13:58:29 GMT C:\work\aop\src\workspace\CallDebugBug&gt;ajc -1.5 banking\Main.java C:\work\aop\src\workspace\CallDebugBug\banking\Main.java [error] Internal compil er error java.lang.NullPointerException at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVi sitor.buildFormalAdviceBindingsFrom(ValidateAtAspectJAnnotationsVisitor.java:417 ) at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVi sitor.convertToPointcutDeclaration(ValidateAtAspectJAnnotationsVisitor.java:513) at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVi sitor.visit(ValidateAtAspectJAnnotationsVisitor.java:188) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.t raverse(MethodDeclaration.java:185) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.tra verse(TypeDeclaration.java:1195) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDecl aration.traverse(CompilationUnitDeclaration.java:339) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.beforeAnalysing( AjCompilerAdapter.java:154) at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$before$org_asp ectj_ajdt_internal_compiler_CompilerAdapter$7$db78446d(CompilerAdapter.aj:101) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compil er.java:517) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compil er.java:329) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilat ion(AjBuildManager.java:811) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuild Manager.java:230) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBu ildManager.java:156) at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112) at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60) at org.aspectj.tools.ajc.Main.run(Main.java:326) at org.aspectj.tools.ajc.Main.runMain(Main.java:240) at org.aspectj.tools.ajc.Main.main(Main.java:83) (no source information available) C:\work\aop\src\workspace\CallDebugBug\banking\Main.java:16 [error] JoinPoint ca nnot be resolved to a type public void log(JoinPoint thisJoinPoint) { ^^^^^^^ C:\work\aop\src\workspace\CallDebugBug\banking\Main.java:17 [error] Syntax error , insert ")" to complete MethodInvocation System.out.println("Before " thisJoinPoint"); C:\work\aop\src\workspace\CallDebugBug\banking\Main.java:17 [error] Syntax error , insert ";" to complete BlockStatements System.out.println("Before " thisJoinPoint"); ABORT Exception thrown from AspectJ DEVELOPMENT This might be logged as a bug already -- find current bugs at http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler Bugs for exceptions thrown have titles File:line from the top stack, e.g., "SomeFile.java:243" If you don't find the exception below in a bug, please add a new bug at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ To make the bug a priority, please include a test program that can reproduce this exception. when validating @AspectJ annotations log when analysing types defined in compilation unit C:\work\aop\src\workspace\CallD ebugBug\banking\Main.java when processing compilation unit C:\work\aop\src\workspace\CallDebugBug\banking\ Main.java when batch building with classpath: c:\java\jdk1.5.0_04\jre\lib\ext\dnsns.jar;c: \java\jdk1.5.0_04\jre\lib\ext\localedata.jar;c:\java\jdk1.5.0_04\jre\lib\ext\sun jce_provider.jar;c:\java\jdk1.5.0_04\jre\lib\ext\sunpkcs11.jar;c:\java\jdk1.5.0_ 04\lib\tools.jar;c:\java\jdk1.5.0_04\jre\lib\rt.jar;C:\java\aspectj\aspectj5\lib \aspectjrt.jar;C:\java\log4j\jakarta-log4j-1.2.8\dist\lib\log4j-1.2.8.jar;C:\jav a\jess\Jess61p5\jess.jar;c:\java\j2sdkee1.3.1\lib\system\cloudscape.jar;c:\java\ j2sdkee1.3.1\lib\system\tools.jar;c:\java\j2sdkee1.3.1\lib\cloudscape\RmiJdbc.ja r;c:\java\j2sdkee1.3.1\lib\cloudscape\cloudclient.jar;c:\java\j2sdkee1.3.1\lib\c lasses;c:\java\j2sdkee1.3.1\classes;c:\java\j2sdkee1.3.1\lib\j2ee.jar;c:\java\j2 sdkee1.3.1\lib\toolclasses;c:\java\j2sdkee1.3.1\lib\j2eetools.jar;c:\java\j2sdke e1.3.1\lib\locale;c:\java\j2sdkee1.3.1\lib\j2ee.jar;c:\java\j2sdkee1.3.1\lib\jha ll.jar;c:\java\j2sdkee1.3.1\lib\locale;c:\java\jdk1.5.0_04\lib\tools.jar;c:\java \j2sdkee1.3.1\lib\jhall.jar;C:\java\ws\axis\axis-1_1\lib\axis.jar;C:\java\ws\axi s\axis-1_1\lib\axis-ant.jar;C:\java\ws\axis\axis-1_1\lib\commons-discovery.jar;C :\java\ws\axis\axis-1_1\lib\commons-logging.jar;C:\java\ws\axis\axis-1_1\lib\jax rpc.jar;C:\java\ws\axis\axis-1_1\lib\saaj.jar;C:\java\ws\axis\axis-1_1\lib\log4j -1.2.8.jar;C:\java\ws\axis\axis-1_1\lib\wsdl4j.jar;C:\java\concurrency\concurren cy.jar;C:\java\junit\junit3.8.1\junit.jar;.; null java.lang.NullPointerException at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVi sitor.buildFormalAdviceBindingsFrom(ValidateAtAspectJAnnotationsVisitor.java:417 ) at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVi sitor.convertToPointcutDeclaration(ValidateAtAspectJAnnotationsVisitor.java:513) at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVi sitor.visit(ValidateAtAspectJAnnotationsVisitor.java:188) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.t raverse(MethodDeclaration.java:185) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.tra verse(TypeDeclaration.java:1195) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDecl aration.traverse(CompilationUnitDeclaration.java:339) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.beforeAnalysing( AjCompilerAdapter.java:154) at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$before$org_asp ectj_ajdt_internal_compiler_CompilerAdapter$7$db78446d(CompilerAdapter.aj:101) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compil er.java:517) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compil er.java:329) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilat ion(AjBuildManager.java:811) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuild Manager.java:230) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBu ildManager.java:156) at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112) at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60) at org.aspectj.tools.ajc.Main.run(Main.java:326) at org.aspectj.tools.ajc.Main.runMain(Main.java:240) at org.aspectj.tools.ajc.Main.main(Main.java:83) 1 fail|abort, 4 errors
[@AspectJ]Lacking import for JoinPoint crahes the compiler Encountered during a JavaPolis demo. I was using a pre-release development version. However, reproducable with latest post-release development version as well. Create the following source file: ABORT Exception thrown from AspectJ DEVELOPMENT This might be logged as a bug already -- find current bugs at http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler Bugs for exceptions thrown have titles File:line from the top stack, e.g., "SomeFile.java:243" If you don't find the exception below in a bug, please add a new bug at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ To make the bug a priority, please include a test program that can reproduce this exception. when validating @AspectJ annotations log when analysing types defined in compilation unit 1 fail|abort, 4 errors
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.visit(MethodDeclaration, ClassScope),True
tests/bugs151/pr121616.main(String[]),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.testAtAspectWithoutJoinPointImport_pr121616(),False,new_method|test_method
#####
AspectJ
125699
15930e7f92e2d4be1866509a8550373a4bcea978;1d41626c3d8489acf9a630d9236a9ecdf912363d
[@AspectJ]@Aspect cannot inherit advice using this PCD and thisJoinPoint Inherting the following advice in an @aspect causes an unexpected error. before (Object obj) : execution(* *(..)) &amp;&amp; this(obj) { System.out.println(thisJoinPoint); } "erre the parameter thisJoinPoint is not bound in [all branches of] pointcut"
cannot inherit advice using this and Inherting the following advice in an causes an unexpected error. "erre the parameter  is not bound in [all branches of] "
******
tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.testAtAspectInheritsAdviceWithTJPAndThis_pr125699(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.testAtAspectInheritsAdviceWithTJPAndThis_pr125699_2(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.testAtAspectInheritsAbstractPointcut_pr125810(),False,new_method|test_method
weaver/src/org/aspectj/weaver/bcel/BcelWeaver.rewritePointcuts(List),True
#####
AspectJ
131933
f2cd94f88a9976fc98786955a764522a8ccb37f1
grotty ClassCastException on referring to pointcut in generic type import java.util.List; public aspect Slide71 { before(): GenericType&lt;String&gt;.foo() {} before(): GenericType&lt;MyList&gt;.foo() {} //before(): GenericType.foo() {} } class GenericType&lt;T&gt; { public pointcut foo(): execution(* T.*(..)); } that programs gives: (because MyList is not a known type) java.lang.ClassCastException at org.aspectj.weaver.patterns.TypePattern.resolveExactType(TypePattern.java:193) at org.aspectj.weaver.patterns.ReferencePointcut.resolveBindings(ReferencePointcut.java:130) at org.aspectj.weaver.patterns.Pointcut.resolve(Pointcut.java:194) at org.aspectj.ajdt.internal.compiler.ast.PointcutDesignator.finishResolveTypes(PointcutDesignator.java:84) at org.aspectj.ajdt.internal.compiler.ast.AdviceDeclaration.resolveStatements(AdviceDeclaration.java:118) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:400) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1088) at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.resolve(AspectDeclaration.java:116) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1137) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:305) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:514) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:843) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:268) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:170) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) ClassCastException thrown: org.aspectj.weaver.patterns.WildTypePattern
grotty on referring to pointcut in generic type public aspect Slide71
******
tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.testGenericAspectWithUnknownType_pr131933(),False,new_method|test_method
weaver/src/org/aspectj/weaver/patterns/TypePattern.resolveExactType(IScope, Bindings),True
#####
AspectJ
131932
e2703cf67fe6c68cc0e91aecdbfa4e07e51c6fc7
structure model bug: generic method ITD import java.util.List; public aspect Slide74 { public X Bar&lt;X&gt;.getFirst() { return lts.get(0); } static class Bar&lt;T&gt; { List&lt;T&gt; lts; } } in AJDT, this program incorrectly shows the relationship from the TYPE to the Bar class rather than from the ITD to the Bar class.
structure model bug: generic method ITD in AJDT, this program incorrectly shows the relationship from the TYPE to the class rather than from the ITD to the class.
******
tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.testStructureModelForGenericITD_pr131932(),False,new_method|test_method
weaver/src/org/aspectj/weaver/NewConstructorTypeMunger.parameterizedFor(ResolvedType,True
weaver/src/org/aspectj/weaver/NewFieldTypeMunger.parameterizedFor(ResolvedType),True
weaver/src/org/aspectj/weaver/NewMethodTypeMunger.parameterizedFor(ResolvedType),True
#####
AspectJ
132130
9dca72e7c63a5623f3d442bf43bb88810368a65a
Missing relationship for declare @method when annotating a co-located method For this program (when all entered into *one* file) I don't see a marker from the declare to the annotated method. If the annotated method is in another file, I do... (not sure if fields/ctors/types are also a problem..) public aspect basic { declare @method: * debit(..): @Secured(role="supervisor"); } class BankAccount { public void debit(long accId,long amount) { } } @interface Secured { String role(); }
Missing relationship for declare @method when annotating a co-located method For this program (when all entered into *one* file) I don't see a marker from the declare to the annotated method. If the annotated method is in another file, I do... (not sure if fields/ctors/types are also a problem..)
******
ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.testAdvice(),False,test_method|formatting
ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.testPointcuts(),False,test_method|formatting
ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.testInterTypeMemberDeclares(),False,test_method|formatting
ajde/testsrc/org/aspectj/ajde/AsmRelationshipsTest.testInterTypeDeclarations(),False,test_method
ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.testAdviceNamingCoverage(),False,test_method|formatting
asm/src/org/aspectj/asm/internal/ProgramElement.toSignatureString(boolean),False,formatting
tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.testDeclareAnnotationAppearsInStructureModel_pr132130(),False,new_method|test_method
#####
AspectJ
129566
0748a02f3e581dcff1c70f3f82e935871d2a36a9
ArrayIndexOutOfBoundsException with regular Java class After "upgrading" to eclipse 3.2M5a and AJDT 20060224163227 I repeatedly get the following stack trace on a regular Java class: java.lang.ArrayIndexOutOfBoundsException at org.aspectj.weaver.ReferenceType.determineThoseTypesToUse(ReferenceType.java:465) at org.aspectj.weaver.ReferenceType.getDeclaredInterfaces(ReferenceType.java:411) at org.aspectj.weaver.bcel.BcelWeaver.weaveParentsFor(BcelWeaver.java:1199) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1047) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:300) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:178) at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:824) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:234) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:157) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) ArrayIndexOutOfBoundsException thrown: -1 This happens even when the class is the only file in a fresh project (without any aspects!); existing AJ projects work fine as soon as this class is excluded from the build path. When the class is moved into a different project and referenced as dependency everything works as expected. This used to work fine with previous versions of AJDT up to the last release for eclipse 3.1.
with regular Java class After "upgrading" to eclipse 3.2M5a and AJDT 20060224163227 I repeatedly get the following stack trace on a regular Java class: This happens even when the class is the only file in a fresh project (without any aspects!); existing AJ projects work fine as soon as this class is excluded from the build path. When the class is moved into a different project and referenced as dependency everything works as expected. This used to work fine with previous versions of AJDT up to the last release for eclipse 3.1.
******
weaver/src/org/aspectj/weaver/ReferenceType.determineThoseTypesToUse(ResolvedType, UnresolvedType[]),True
#####
AspectJ
133307
c9a60e519d73bb7aa4d8cf4615445089202bd3ad
declare parents implementing generic interface referencing same type I have the following construct: public interface TestIF&lt;T extends TestIF&gt; {} public class TestClass {} public aspect TestAspect { declare parents: TestClass implements TestIF&lt;TestClass&gt;; } The later aspect does not compile, although public class TestClass implements TestIF&lt;TestClass&gt; { } is a valid class.
declare parents implementing generic interface referencing same type I have the following construct: The later aspect does not compile, although is a valid class.
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.completeTypeBindings(),True
tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.testCircularGenerics_pr133307(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.testDeca(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.testDeca2(),False,new_method|test_method
weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.reset(),True
weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.recordNecessaryCheck(IVerificationRequired),False,new_method
weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.verify(),False,new_method
weaver/src/org/aspectj/weaver/patterns/IVerificationRequired..verify(),False,new_method
weaver/src/org/aspectj/weaver/patterns/WildTypePattern.verifyTypeParameters(ResolvedType, IScope, boolean),True
weaver/src/org/aspectj/weaver/patterns/WildTypePattern.checkBoundsOK(IScope, ResolvedType, boolean),True
VerifyBoundsForTypePattern(IScope, ResolvedType, boolean, TypePatternList, ISourceLocation),False,new_method
weaver/src/org/aspectj/weaver/patterns/WildTypePattern.verify(),False,new_method
weaver/src/org/aspectj/weaver/patterns/WildTypePattern.checkBoundsOK(IScope, ResolvedType, boolean),False,new_method
#####
AspectJ
131505
b3cd01d587219969e7c7b58ecda5b1aeb7722c2e
Generated aop.xml files contain aspects for all the projects ever built Using the -outxml option in AJDT the generated aop.xml files are not correct after the first build and contain all the aspects that have ever been built (including those in different projects and duplicates if an aspect has been built twice). It seems that there is a global list of aspects (aspectNames in AjBuildManager) that is never cleared.
Generated files contain aspects for all the projects ever built Using the -outxml option in AJDT the generated files are not correct after the first build and contain all the aspects that have ever been built (including those in different projects and duplicates if an aspect has been built twice). It seems that there is a global list of aspects ( in) that is never cleared.
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.writeOutxmlFile(),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.addAspectName(String),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.getAspectNames(),False,new_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.initializeAspectNamesList(),False,new_method
tests/multiIncremental/PR131505/base/C.method1(),False,new_method|test_method
tests/multiIncremental/PR131505/base/C.method2(),False,new_method|test_method
tests/multiIncremental/PR131505/inc2/C.method1(),False,new_method|test_method
tests/multiIncremental/PR131505/inc2/C.method2(),False,new_method|test_method
tests/multiIncremental/PR131505/inc2/C.method3(),False,new_method|test_method
tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.testPr131505(),False,new_method|test_method
tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.checkXMLAspectCount(String, String, int),False,new_method|test_method
#####
AspectJ
130869
103733b9c277f980d30db27710ea359974e45c81
Pointcut resolution fails against type variables Ok, so I'm on the bleeding edge of aspect design here... but I have a generic aspect of the form public abstract aspect MyAspect&lt;T extends Bar&gt; { declare warning : T.somePC() : "a match"; } and Bar is defined as: public abstract aspect Bar { public abstract pointcut somePC(); } (yes, what that enables is indeed unbelievably cool). We fail (perhaps unsurprisingly) when compiling the generic aspect because we can't find the pointcut somePC in T. We should of course be looking in the upper bound when searching for a pointcut in a type variable...
resolution fails against type variables Ok, so I'm on the bleeding edge of aspect design here... but I have a generic aspect of the form (yes, what that enables is indeed unbelievably cool). We fail (perhaps unsurprisingly) when compiling the generic aspect because we can't find the in T. We should of course be looking in the upper bound when searching for a pointcut in a type variable...
******
tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.testGenericAspectsWithAnnotationTypeParameters(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.testPointcutInterfaces_pr130869(),False,new_method|test_method
weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.resolveBindings(IScope, Bindings),True
weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.concretize1(ResolvedType, ResolvedType, IntMap),True
#####
AspectJ
130837
41f1f3a4174de86413942cd8f2c2e7c45d9824d7
Exception while trying to edit Annotation based Aspect Class (normal Java class) java.lang.NullPointerException at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVisitor.buildFormalAdviceBindingsFrom(ValidateAtAspectJAnnotationsVisitor.java:417) at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVisitor.resolveAndSetPointcut(ValidateAtAspectJAnnotationsVisitor.java:364) at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVisitor.validateAdvice(ValidateAtAspectJAnnotationsVisitor.java:336) at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVisitor.visit(ValidateAtAspectJAnnotationsVisitor.java:186) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:185) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1195) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:339) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.beforeAnalysing(AjCompilerAdapter.java:154) at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$before$org_aspectj_ajdt_internal_compiler_CompilerAdapter$7$db78446d(CompilerAdapter.aj:101) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:517) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:824) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:234) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:189) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:164) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) NullPointerException thrown: null
Exception while trying to edit Annotation based Aspect Class (normal Java class)
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.buildFormalAdviceBindingsFrom(MethodDeclaration),True
#####
AspectJ
132926
2fb86fe604b613774492df5185b1c5717c434d29
Compiler crashes processing annotations Just upgraded to latest AJDT (Version: 1.3.1, Build id: 20060322082516 AspectJ version: 1.5.1.20060320075953) and the compiler crashed while rebulding the project (which used to work fine using using the March 16th version). Retrying with 'clean' build produced the same crash. java.lang.NullPointerException at org.aspectj.weaver.AnnotationX.ensureAtTargetInitialized(AnnotationX.java:158) at org.aspectj.weaver.AnnotationX.specifiesTarget(AnnotationX.java:98) at org.aspectj.weaver.bcel.BcelWeaver.verifyTargetIsOK(BcelWeaver.java:1450) at org.aspectj.weaver.bcel.BcelWeaver.applyDeclareAtType(BcelWeaver.java:1417) at org.aspectj.weaver.bcel.BcelWeaver.weaveParentTypeMungers(BcelWeaver.java:1366) at org.aspectj.weaver.bcel.BcelWeaver.weaveParentsFor(BcelWeaver.java:1223) at org.aspectj.weaver.bcel.BcelWeaver.weaveParentsFor(BcelWeaver.java:1211) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1058) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:311) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:183) at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:845) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:241) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:161) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) NullPointerException thrown: null
Compiler crashes processing annotations Just upgraded to latest AJDT (Version: 1.3.1, Build id: 20060322082516 AspectJ version: 1.5.1.20060320075953) and the compiler crashed while rebulding the project (which used to work fine using using the March 16th version). Retrying with 'clean' build produced the same crash.
******
tests/bugs151/pr132926/AffectedType.main(String[]),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.testDeca(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.testCrashingWithASM_pr132926_1(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.testCrashingWithASM_pr132926_2(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.testCrashingWithASM_pr132926_3(),False,new_method|test_method
weaver/src/org/aspectj/weaver/AnnotationX.ensureAtTargetInitialized(),True
weaver/src/org/aspectj/weaver/AnnotationX.getTargets(),False,new_method
#####
AspectJ
135001
1a6f69583137f03d2a8052148a17eebe8e79e162
NPE at at org.aspectj.weaver.bcel.BcelShadow.weaveAroundInline java.lang.NullPointerException at org.aspectj.weaver.bcel.BcelShadow.weaveAroundInline(BcelShadow.java:2109) at org.aspectj.weaver.bcel.BcelAdvice.implementOn(BcelAdvice.java:232) at org.aspectj.weaver.Shadow.implementMungers(Shadow.java:639) at org.aspectj.weaver.Shadow.implement(Shadow.java:456) at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:2236) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:491) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:109) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1560) at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1511) at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1291) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1113) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:311) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:183) at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:862) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:242) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:161) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)
NPE at at 
******
tests/bugs152/pr135001/AbstractAspect.scope(),False,new_method|test_method
tests/bugs152/pr135001/Foo.main(String[]),False,new_method|test_method
tests/bugs152/pr135001/Foo.foo(),False,new_method|test_method
tests/src/org/aspectj/systemtest/AllTests15.suite(),False,test_method
tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.testAspectLibrariesAndASM_pr135001(),False,test_method
tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.suite(),False,test_method
tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.getSpecFile(),False,test_method
tests/src/org/aspectj/systemtest/ajc152/AllTestsAspectJ152.suite(),False,test_method
weaver/src/org/aspectj/weaver/bcel/BcelShadow.weaveAroundInline(BcelAdvice, boolean),True
weaver/src/org/aspectj/weaver/bcel/BcelWorld.resolve(Type),False,formatting
weaver/src/org/aspectj/weaver/bcel/BcelWorld.resolveDelegate(ReferenceType),True
weaver/testsrc/org/aspectj/weaver/bcel/AsmDelegateTests.testWeDontGoBang(),True
weaver/testsrc/org/aspectj/weaver/bcel/AsmDelegateTests.testLoadingAttributesForTypes(),True
#####
AspectJ
134541
94d8b82fbf3cb18a14d77508b3adad6d50434080
adviceDidNotMatch's line number doesn't keep up with line number of advice When advice doesn't match in a 1.5.0 enabled project, there is an adviceDidNotMatch warning against the line number of the advice. If you insert a line before this advice and save then the warning stays associated with the original line and not the new one. Full building puts the warning against the new line. This is a regression and didn't happen in AJ 1.5.0.
's line number doesn't keep up with line number of advice When advice doesn't match in a 1.5.0 enabled project, there is an warning against the line number of the advice. If you insert a line before this advice and save then the warning stays associated with the original line and not the new one. Full building puts the warning against the new line. This is a regression and didn't happen in AJ 1.5.0.
******
tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.testPr134541(),False,new_method|test_method
weaver/src/org/aspectj/weaver/CrosscuttingMembers.replaceWith(CrosscuttingMembers,boolean),True
weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.addOrReplaceAspect(ResolvedType, boolean),True
#####
AspectJ
136665
d1a252e911bd19747b0cd6815291f62706f202d6
Bug: ajc fails on missing classpath entries with fix [iajc] error at (no source information available) [iajc] File.aj:0::0 Internal compiler error [iajc] org.aspectj.weaver.BCException: Can't open archive: missingjar [iajc] when resolving types defined in compilation unit File.aj [iajc] when processing compilation unit File.aj [iajc] when batch building BuildConfig[null] #Files=14 [iajc] [iajc] at org.aspectj.weaver.bcel.ClassPathManager$ZipFileEntry.ensureO pen(ClassPathManager.java:258) [iajc] at org.aspectj.weaver.bcel.ClassPathManager$ZipFileEntry.find(Cl assPathManager.java:225) [iajc] at org.aspectj.weaver.bcel.ClassPathManager.find(ClassPathManage r.java:92) [iajc] at org.aspectj.weaver.bcel.BcelWorld.resolveDelegate(BcelWorld.j ava:287) [iajc] at org.aspectj.weaver.World.resolveToReferenceType(World.java:33 5) [iajc] at org.aspectj.weaver.World.resolve(World.java:251) [iajc] at org.aspectj.weaver.patterns.WildTypePattern.lookupTypeInWorld (WildTypePattern.java:716) [iajc] at org.aspectj.weaver.patterns.WildTypePattern.resolveBindingsFr omFullyQualifiedTypeName(WildTypePattern.java:690) [iajc] at org.aspectj.weaver.patterns.WildTypePattern.resolveBindings(W ildTypePattern.java:623) [iajc] at org.aspectj.weaver.patterns.SignaturePattern.resolveBindings( SignaturePattern.java:82) [iajc] at org.aspectj.weaver.patterns.KindedPointcut.resolveBindings(Ki ndedPointcut.java:259) [iajc] at org.aspectj.weaver.patterns.AndPointcut.resolveBindings(AndPo intcut.java:74) [iajc] at org.aspectj.weaver.patterns.Pointcut.resolve(Pointcut.java:19 4) [iajc] at org.aspectj.ajdt.internal.compiler.ast.PointcutDesignator.fin ishResolveTypes(PointcutDesignator.java:84) [iajc] at org.aspectj.ajdt.internal.compiler.ast.AdviceDeclaration.reso lveStatements(AdviceDeclaration.java:118) [iajc] at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMet hodDeclaration.resolve(AbstractMethodDeclaration.java:400) [iajc] at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclara tion.resolve(TypeDeclaration.java:1088) [iajc] at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.reso lve(AspectDeclaration.java:116) [iajc] at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclara tion.resolve(TypeDeclaration.java:1137) [iajc] at org.aspectj.org.eclipse.jdt.internal.compiler.ast.Compilation UnitDeclaration.resolve(CompilationUnitDeclaration.java:305) [iajc] at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.proces s(Compiler.java:514) [iajc] at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compil e(Compiler.java:329) [iajc] at org.aspectj.ajdt.internal.core.builder.AjBuildManager.perform Compilation(AjBuildManager.java:845) [iajc] at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild (AjBuildManager.java:241) [iajc] at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBu ild(AjBuildManager.java:161) [iajc] at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:1 12) [iajc] at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java: 60) [iajc] at org.aspectj.tools.ajc.Main.run(Main.java:356) [iajc] at org.aspectj.tools.ajc.Main.runMain(Main.java:246) [iajc] at org.aspectj.tools.ant.taskdefs.AjcTask.executeInSameVM(AjcTas k.java:1262) [iajc] at org.aspectj.tools.ant.taskdefs.AjcTask.execute(AjcTask.java:1 056) [iajc] at org.apache.tools.ant.UnknownElement.execute(UnknownElement.ja va:275) [iajc] at org.apache.tools.ant.Task.perform(Task.java:364) [iajc] at org.apache.tools.ant.Target.execute(Target.java:341) [iajc] at org.apache.tools.ant.Target.performTasks(Target.java:369) [iajc] at org.apache.tools.ant.Project.executeTarget(Project.java:1214) [iajc] at org.apache.tools.ant.taskdefs.Ant.execute(Ant.java:386) [iajc] at org.apache.tools.ant.taskdefs.CallTarget.execute(CallTarget.j ava:106) [iajc] at org.apache.tools.ant.UnknownElement.execute(UnknownElement.ja va:275) [iajc] at org.apache.tools.ant.Task.perform(Task.java:364) [iajc] at org.apache.tools.ant.Target.execute(Target.java:341) [iajc] at org.apache.tools.ant.Target.performTasks(Target.java:369) [iajc] at org.apache.tools.ant.Project.executeTarget(Project.java:1214) [iajc] at org.apache.tools.ant.Project.executeTargets(Project.java:1062 ) [iajc] at org.apache.tools.ant.Main.runBuild(Main.java:673) [iajc] at org.apache.tools.ant.Main.startAnt(Main.java:188) [iajc] at org.apache.tools.ant.launch.Launcher.run(Launcher.java:196) [iajc] at org.apache.tools.ant.launch.Launcher.main(Launcher.java:55) [iajc] Caused by: java.util.zip.ZipException: error in opening zip file [iajc] java.util.zip.ZipException: error in opening zip file [iajc] at java.util.zip.ZipFile.open(Native Method) [iajc] at java.util.zip.ZipFile.&lt;init&gt;(ZipFile.java:111) [iajc] at java.util.zip.ZipFile.&lt;init&gt;(ZipFile.java:127) [iajc] at org.aspectj.weaver.bcel.ClassPathManager$ZipFileEntry.ensureO pen(ClassPathManager.java:252) [iajc] at org.aspectj.weaver.bcel.ClassPathManager$ZipFileEntry.find(Cl assPathManager.java:225) [iajc] at org.aspectj.weaver.bcel.ClassPathManager.find(ClassPathManage r.java:92) [iajc] at org.aspectj.weaver.bcel.BcelWorld.resolveDelegate(BcelWorld.j ava:287) [iajc] at org.aspectj.weaver.World.resolveToReferenceType(World.java:33 5) [iajc] at org.aspectj.weaver.World.resolve(World.java:251) [iajc] at org.aspectj.weaver.patterns.WildTypePattern.lookupTypeInWorld (WildTypePattern.java:716) [iajc] at org.aspectj.weaver.patterns.WildTypePattern.resolveBindingsFr omFullyQualifiedTypeName(WildTypePattern.java:690) [iajc] at org.aspectj.weaver.patterns.WildTypePattern.resolveBindings(W ildTypePattern.java:623) [iajc] at org.aspectj.weaver.patterns.SignaturePattern.resolveBindings( SignaturePattern.java:82) [iajc] at org.aspectj.weaver.patterns.KindedPointcut.resolveBindings(Ki ndedPointcut.java:259) [iajc] at org.aspectj.weaver.patterns.AndPointcut.resolveBindings(AndPo intcut.java:74) [iajc] at org.aspectj.weaver.patterns.Pointcut.resolve(Pointcut.java:19 4) [iajc] at org.aspectj.ajdt.internal.compiler.ast.PointcutDesignator.fin ishResolveTypes(PointcutDesignator.java:84) [iajc] at org.aspectj.ajdt.internal.compiler.ast.AdviceDeclaration.reso lveStatements(AdviceDeclaration.java:118) [iajc] at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMet hodDeclaration.resolve(AbstractMethodDeclaration.java:400) [iajc] at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclara tion.resolve(TypeDeclaration.java:1088) [iajc] at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.reso lve(AspectDeclaration.java:116) [iajc] at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclara tion.resolve(TypeDeclaration.java:1137) [iajc] at org.aspectj.org.eclipse.jdt.internal.compiler.ast.Compilation UnitDeclaration.resolve(CompilationUnitDeclaration.java:305) [iajc] at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.proces s(Compiler.java:514) [iajc] at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compil e(Compiler.java:329) [iajc] at org.aspectj.ajdt.internal.core.builder.AjBuildManager.perform Compilation(AjBuildManager.java:845) [iajc] at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild (AjBuildManager.java:241) [iajc] at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBu ild(AjBuildManager.java:161) [iajc] at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:1 12) [iajc] at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java: 60) [iajc] at org.aspectj.tools.ajc.Main.run(Main.java:356) [iajc] at org.aspectj.tools.ajc.Main.runMain(Main.java:246) [iajc] at org.aspectj.tools.ant.taskdefs.AjcTask.executeInSameVM(AjcTas k.java:1262) [iajc] at org.aspectj.tools.ant.taskdefs.AjcTask.execute(AjcTask.java:1 056) [iajc] at org.apache.tools.ant.UnknownElement.execute(UnknownElement.ja va:275) [iajc] at org.apache.tools.ant.Task.perform(Task.java:364) [iajc] at org.apache.tools.ant.Target.execute(Target.java:341) [iajc] at org.apache.tools.ant.Target.performTasks(Target.java:369) [iajc] at org.apache.tools.ant.Project.executeTarget(Project.java:1214) [iajc] at org.apache.tools.ant.taskdefs.Ant.execute(Ant.java:386) [iajc] at org.apache.tools.ant.taskdefs.CallTarget.execute(CallTarget.j ava:106) [iajc] at org.apache.tools.ant.UnknownElement.execute(UnknownElement.ja va:275) [iajc] at org.apache.tools.ant.Task.perform(Task.java:364) [iajc] at org.apache.tools.ant.Target.execute(Target.java:341) [iajc] at org.apache.tools.ant.Target.performTasks(Target.java:369) [iajc] at org.apache.tools.ant.Project.executeTarget(Project.java:1214) [iajc] at org.apache.tools.ant.Project.executeTargets(Project.java:1062 ) [iajc] at org.apache.tools.ant.Main.runBuild(Main.java:673) [iajc] at org.apache.tools.ant.Main.startAnt(Main.java:188) [iajc] at org.apache.tools.ant.launch.Launcher.run(Launcher.java:196) [iajc] at org.apache.tools.ant.launch.Launcher.main(Launcher.java:55) [iajc] abort ABORT -- (BCException) Can't open archive: wissing.jar [iajc] when resolving types defined in compilation unit File.aj [iajc] when processing compilation unit File.aj [iajc] when batch building BuildConfig[null] #Files=14
Bug: fails on missing classpath entries with fix error at (no source information available)  Can't open archive: when resolving types defined in compilation unit when processing compilation unit when batch building error in opening zip file error in opening zip file  Can't open archive: when resolving types defined in compilation unit  when processing compilation unit when batch building 
******
weaver/src/org/aspectj/weaver/bcel/ClassPathManager.find(UnresolvedType),True
weaver/src/org/aspectj/weaver/bcel/ClassPathManager.getAllClassFiles(),True
weaver/src/org/aspectj/weaver/bcel/ClassPathManager.find(String,True
weaver/src/org/aspectj/weaver/bcel/ClassPathManager.getAllClassFiles(),True
weaver/src/org/aspectj/weaver/bcel/ClassPathManager.ensureOpen(),True
#####
AspectJ
138143
0d74ccfc6087a2bd8025c73e64467a4a8e442916
NullPointerException when duplicated method name is used When developing aspects as annotations, i get a NullPointerException when saving a source file which has duplicated method names. Obviously that also breaks the java code itself but it also pops up an aspectj message info. Here is a sample code: @Aspect public class AspectClass{ @Pointcut("call(@Incoming * *(..))") public void incomingMessage() { } @Pointcut("call(@Activity * *(..))") public void incomingMessage() { } } The npe is the following: java.lang.NullPointerException at org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.makeResolvedPointcutDefinition(EclipseSourceType.java:217) at org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.fillDeclaredMembers(EclipseSourceType.java:188) at org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.getDeclaredPointcuts(EclipseSourceType.java:250) at org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.checkPointcutDeclarations(EclipseSourceType.java:267) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.resolvePointcutDeclarations(AjLookupEnvironment.java:433) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:236) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:862) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:269) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:168) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) NullPointerException thrown: null regards Moritz Post
when duplicated method name is used When developing aspects as annotations, i get a when saving a source file which has duplicated method names. Obviously that also breaks the java code itself but it also pops up an aspectj message info. The npe is the following: null regards Moritz Post
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.fillDeclaredMembers(),True
makeResolvedPointcutDefinition(AbstractMethodDeclaration),True
#####
AspectJ
138540
99882cb91a94c468c185cf11cd6a728604e95bdb
Patch to add support for -Xset: options I needed to add X="set:activateLightweightDelegates=false? to my ant build configuration, to troubleshoot the out of memory permgen condition. However, the ant task support doesn't currently support adding the new -Xset style options Andy added. Here is a small patch to pass any -Xset: options through, that worked for me.
Patch to add support for -: options I needed to add to my ant build configuration, to troubleshoot the out of memory permgen condition. However, the ant task support doesn't currently support adding the new - style options Andy added. Here is a small patch to pass any -: options through, that worked for me.
******
taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.setX(String),True
#####
AspectJ
138286
c667bcb5088379d74b89c3dc8556b87429e4efb7
perthis() causes ClassCastException When using perthis() with an aspect, I see the following Internal Compiler AJDT 1.3.1 / AspectJ 1.5.1a Build 20060406092046 Eclipse 3.1.2, Windows XP, JDK 1.5 Error: java.lang.ClassCastException at org.aspectj.weaver.patterns.PerThisOrTargetPointcutVisitor.getPerTypePointcut(PerThisOrTargetPointcutVisitor.java:41) at org.aspectj.weaver.patterns.PerThisOrTargetPointcutVisitor.visit(PerThisOrTargetPointcutVisitor.java:108) at org.aspectj.weaver.patterns.AndPointcut.accept(AndPointcut.java:119) at org.aspectj.weaver.patterns.PerThisOrTargetPointcutVisitor.getPerTypePointcut(PerThisOrTargetPointcutVisitor.java:41) at org.aspectj.weaver.PerObjectInterfaceTypeMunger.getTestTypePattern(PerObjectInterfaceTypeMunger.java:64) at org.aspectj.weaver.PerObjectInterfaceTypeMunger.matches(PerObjectInterfaceTypeMunger.java:85) at org.aspectj.weaver.ConcreteTypeMunger.matches(ConcreteTypeMunger.java:65) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:508) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:109) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1560) at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1511) at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1291) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1089) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:311) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:183) at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:862) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:242) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:161) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:278) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:168) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) trouble in: public abstract class org.apache.tapestry.internal.aspects.AbstractClassTargetting extends java.lang.Object: public void &lt;init&gt;(): ALOAD_0 // Lorg/apache/tapestry/internal/aspects/AbstractClassTargetting; this (line 10) INVOKESPECIAL java.lang.Object.&lt;init&gt; ()V initialization(void org.apache.tapestry.internal.aspects.AbstractClassTargetting.&lt;init&gt;()) | ALOAD_0 | INVOKEVIRTUAL java.lang.Object.getClass ()Ljava/lang/Class; | LDC org.apache.tapestry.internal.annotations.Synchronized | INVOKEVIRTUAL java.lang.Class.isAnnotationPresent (Ljava/lang/Class;)Z | IFEQ L0 | ALOAD_0 | INVOKESTATIC org.apache.tapestry.internal.aspects.InternalSynchronization.ajc$perObjectBind (Ljava/lang/Object;)V | constructor-execution(void org.apache.tapestry.internal.aspects.AbstractClassTargetting.&lt;init&gt;()) | | L0: ALOAD_0 | | INVOKEVIRTUAL java.lang.Object.getClass ()Ljava/lang/Class; | | LDC org.apache.tapestry.internal.annotations.Synchronized | | INVOKEVIRTUAL java.lang.Class.isAnnotationPresent (Ljava/lang/Class;)Z | | IFEQ L1 | | ALOAD_0 | | INVOKESTATIC org.apache.tapestry.internal.aspects.InternalSynchronization.ajc$perObjectBind (Ljava/lang/Object;)V | | L1: RETURN | constructor-execution(void org.apache.tapestry.internal.aspects.AbstractClassTargetting.&lt;init&gt;()) initialization(void org.apache.tapestry.internal.aspects.AbstractClassTargetting.&lt;init&gt;()) end public void &lt;init&gt;() abstract void ajc$pointcut$$targetClasses$274() org.aspectj.weaver.MethodDeclarationLineNumber: 16:628 ; end public abstract class org.apache.tapestry.internal.aspects.AbstractClassTargetting when weaving type org.apache.tapestry.internal.aspects.AbstractClassTargetting when weaving aspects when weaving when batch building BuildConfig[C:\workspace\.metadata\.plugins\org.eclipse.ajdt.core\tapestry5.generated.lst] #Files=70 I'll attach the corresponding files.
causes  When using with an aspect, I see the following Internal Compiler when weaving type when weaving aspects when weaving when batch building  I'll attach the corresponding files.
******
tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.testNoClassCastExceptionWithPerThis_pr138286(),False,new_method|test_method
weaver/src/org/aspectj/weaver/patterns/PerThisOrTargetPointcutVisitor.visit(WithinAnnotationPointcut, Object),True
weaver/src/org/aspectj/weaver/patterns/PerThisOrTargetPointcutVisitor.visit(ThisOrTargetAnnotationPointcut, Object),True
#####
AspectJ
135780
cb5dfe759852d4965c692934ed7e14c41f61b715
Java 1.2 dependency in aspectjrt.jar bug with fix The thisJoinPoint.printString() fails on a 1.1 VM because it relies on a java.lang.ref.SoftReference. I need this to work because we're using AspectJ on an embedded device that is still using a pre-1.2 VM. The problem lies in org.aspectj.runtime.reflect.SignatureImpl. The attached patch fixes it and passes all the tests. I tested the failing program manually on a 1.1 VM, but automating the test would require adding a 1.1 VM to the regression test infrastructure. Sample: public aspect Java11Test { before() : execution(* *(..)) { System.out.println(thisJoinPoint.toString()); } public static void main(String args[]) {} } &gt;ajc -target 1.1 Java11Test.aj &gt;\java\jre1.1.8_010\bin\jre -cp .;%CLASSPATH% Java11Test Exception in thread "main" java.lang.NoClassDefFoundError: java/lang/ref/SoftRef erence at org.aspectj.runtime.reflect.JoinPointImpl$StaticPartImpl.toString(Joi nPointImpl.java:43) at org.aspectj.runtime.reflect.JoinPointImpl$StaticPartImpl.toString(Joi nPointImpl.java:48) at Java11Test.ajc$before$Java11Test$1$3444dde4(Java11Test.aj:3) at Java11Test.main(Java11Test.aj)
Java 1.2 dependency in bug with fix The fails on a 1.1 VM because it relies on a. I need this to work because we're using AspectJ on an embedded device that is still using a pre-1.2 VM. The problem lies in The attached patch fixes it and passes all the tests. I tested the failing program manually on a 1.1 VM, but automating the test would require adding a 1.1 VM to the regression test infrastructure. Sample
******
runtime/src/org/aspectj/runtime/reflect/SignatureImpl.toString(StringMaker),True
runtime/src/org/aspectj/runtime/reflect/SignatureImpl.get(int),True
runtime/src/org/aspectj/runtime/reflect/SignatureImpl.set(int, String),True
runtime/src/org/aspectj/runtime/reflect/SignatureImpl.CacheImpl(),True
runtime/src/org/aspectj/runtime/reflect/SignatureImpl.array(),True
#####
AspectJ
118781
a75b7fa48b233e41ed7aeb7d50fbdd411eadd8e6
[waiting-on-build]VerifyError in AspectJ I'm fairly new to AspectJ, so this is probably not going to be well explained. I've started working on a project that was working fine. Then I added methods to classes that take a 2-dimensional string array parameter and suddenly I'm getting a VerifyError exception. java.lang.VerifyError: (class: com/drkw/cpds/obligor/facades/version_1_00/ObligorDetailFacade_1_00, method: searchForObligorSummariesByGroup_aroundBody24 signature: (Lcom/drkw/cpds/obligor/facades/version_1_00/ObligorDetailFacade_1_00;[[[Ljava/lang/String;Ljava/lang/String;Ljava?(&amp;#130; at com.drkw.cpds.obligor.facades.version_1_00.obligor.ObligorManager.&lt;clinit&gt;(ObligorManager.java:48) at com.drkw.cpds.obligor.integration.version_1_00.obligor.GetObligorDetailsGroupingTest.testGetObligorDetailsUsingGroups(GetObligorDetailsGroupingTest.java:45) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
in AspectJ I'm fairly new to AspectJ, so this is probably not going to be well explained. I've started working on a project that was working fine. Then I added methods to classes that take a 2-dimensional string array parameter and suddenly I'm getting a exception.
******
tests/bugs150/pr118781/MyClass.getRandomInt(String[][]),False,new_method|test_method
tests/bugs150/pr118781/MyMain.main(String[]),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.testAroundAdviceArrayAdviceSigs_pr118781(),False,new_method|test_method
weaver/src/org/aspectj/weaver/World.resolve(UnresolvedType, boolean),True
weaver/src/org/aspectj/weaver/World.put(String, ResolvedType),True
#####
AspectJ
133117
3fa4d24ac16e94ee40b824fe27830fe7a34866a3
Lots of warnings with noGuardForLazyTjp When the noGuardForLazyTjp compiler option is set to warning or error and a piece of advice causes this warning to show up, you get one warning for every join point matched by the advice. I think just one would probably be enough...
Lots of warnings with noGuardForLazyTjp When the noGuardForLazyTjp compiler option is set to warning or error and a piece of advice causes this warning to show up, you get one warning for every join point matched by the advice. I think just one would probably be enough...
******
tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.testPr133117(),False,new_method|test_method
weaver/src/org/aspectj/weaver/bcel/BcelAdvice.specializeOn(Shadow),True
weaver/src/org/aspectj/weaver/Lint,True
#####
AspectJ
135068
9ffc63b51aa49fa3bb67a4a1c40dd7d1fe4c97ae
VerifyError with LTW and @AJ style aspects I get "VerifyError: Incompatible object argument for function call" error when using LTW with @Aspect stype aspects. Interestingly enough, LTW works as expected with equivalent .aj style aspect. Compile time weaving works with both aspect styles. Tested on Linux with AspectJ 1.5.0, 1.5.1 and DEVELOPMENT-20060404163823 and SUN 1.5.0_06 and IBM 1.5.0SR1 JVMs. I will attach example project shortly.
with LTW and style aspects I get ": Incompatible object argument for function call" error when using LTW with stype aspects. Interestingly enough, LTW works as expected with equivalent style aspect. Compile time weaving works with both aspect styles. Tested on Linux with AspectJ 1.5.0, 1.5.1 and DEVELOPMENT-20060404163823 and SUN 1.5.0_06 and IBM 1.5.0SR1 JVMs. I will attach example project shortly.
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.validateAdvice(MethodDeclaration),True
tests/bugs152/pr135068/Ajava.getAddress(),False,new_method|test_method
tests/bugs152/pr135068/Ajava2.getAddress(),False,new_method|test_method
tests/bugs152/pr135068/C.getAddress(),False,new_method|test_method
tests/bugs152/pr135068/C.main(String[]),False,new_method|test_method
tests/bugs152/pr135068/C2.getAddress(),False,new_method|test_method
tests/bugs152/pr135068/C2.main(String[]),False,new_method|test_method
tests/bugs152/pr135068/t/Ajava.getAddress(),False,new_method|test_method
tests/bugs152/pr135068/t/Ajava2.getAddress(),False,new_method|test_method
tests/bugs152/pr135068/t/C.getAddress(),False,new_method|test_method
tests/bugs152/pr135068/t/C.test(),False,new_method|test_method
tests/bugs152/pr135068/t/C.main(String[]),False,new_method|test_method
tests/bugs152/pr135068/t/C2.getAddress(),False,new_method|test_method
tests/bugs152/pr135068/t/C2.test(),False,new_method|test_method
tests/bugs152/pr135068/t/C2.main(String[]),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.testVerifyErrorLTW_pr135068(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.testVerifyErrorLTW_pr135068_2(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.testVerifyErrorLTW_pr135068_3(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.testVerifyErrorLTW_pr135068_4(),False,new_method|test_method
weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.readAj5MethodAttributes(Method, BcelMethod, ResolvedType, ResolvedPointcutDefinition, ISourceContext, IMessageHandler),True
#####
AspectJ
82570
b14d5e8a49519156f711d9e6ee15a6ff6c729b69;71966e3348a05cb99b88885b8e6b751cc61a638e
Weaved code does not include debug lines I am attempting to use AspectJ and output all classes in debug mode (required by our code coverage instrumentor). However any code introduced by our aspects to production classes does not include debug line information. Our ant script uses the iajc task as follows: &lt;iajc ... debug="true" .. /&gt; We have an aspect that introduces a public, no-arguments constructor into various classes. If I enable this aspect, then do a clean build, I get the following error from our code coverage tool: [jblanket] java.lang.UnsupportedOperationException: No line numbers detected in com.abmuk.oms.core.model.core.XMLObject.&lt;init&gt;. Either remove the 'oneLineFile' tag or turn debug on when compiling. If I remove that aspect, we get no errors about debug line information. I've tried debug="true" or debugLevel="lines,vars,source", with no success. This issue is preventing our Unit Test suite from executing. If you require any further information, please don't hesitate to email me. Cheers, Chris Nappin.
Weaved code does not include debug lines I am attempting to use AspectJ and output all classes in debug mode (required by our code coverage instrumentor). However any code introduced by our aspects to production classes does not include debug line information. Our ant script uses the iajc task as follows: &lt;iajc ... debug="true" .. /&gt; We have an aspect that introduces a public, no-arguments constructor into various classes. If I enable this aspect, then do a clean build, I get the following error from our code coverage tool: [jblanket] java.lang.UnsupportedOperationException: No line numbers detected in com.abmuk.oms.core.model.core.XMLObject.&lt;init&gt;. Either remove the 'oneLineFile' tag or turn debug on when compiling. If I remove that aspect, we get no errors about debug line information. I've tried debug="true" or debugLevel="lines,vars,source", with no success. This issue is preventing our Unit Test suite from executing. If you require any further information, please don't hesitate to email me. Cheers, Chris Nappin.
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AdviceDeclaration.generateProceedMethod(ClassScope, ClassFile),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.generateMethod(ClassFile classFile, MethodBinding methodBinding, List additionalAttributes/*ResolvedMember realMember*/, BodyGenerator),True
tests/bugs150/PR82570_1.main(String[]),False,new_method|test_method
tests/bugs150/PR82570_1.m(),False,new_method|test_method
PR82570_1.new(String),False,new_method|test_method
PR82570_1.itdMethod(String),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/Ajc150TestsNoHarness.testMissingDebugInfoForGeneratedMethods_pr82570(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/Ajc150TestsNoHarness.createRepos(File),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/Ajc150TestsNoHarness.getClassFrom(File, String),False,new_method|test_method
weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.packBody(MethodGen),True
#####
AspectJ
142165
7d9a7287ee1aef66ba2edf55ef2fec2bf95b0dc3
rewriting XML concretized pointcuts doesnt work for AND construct the scheme used to rewrite pointcuts defined in XML that use AND doesnt work, they get mangled.
rewriting XML concretized pointcuts doesnt work for AND construct the scheme used to rewrite pointcuts defined in XML that use AND doesnt work, they get mangled.
******
tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.testMisbehavingDeclareAnnotation_pr135865(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.testCompletelyBrokenAopConcretization_pr142165_1(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.testCompletelyBrokenAopConcretization_pr142165_2(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.testCompletelyBrokenAopConcretization_pr142165_3(),False,new_method|test_method
util/src/org/aspectj/util/LangUtil.replace(String, String, String),True
weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.parsePointcut(String, AjAttributeStruct, boolean),True
weaver/src/org/aspectj/weaver/patterns/PatternParser.checkEof(),False,new_method
#####
AspectJ
141956
5f6a6b12c560f80dd720a943c4c63cf8dc182cc3
Null Pointer Exception when trying to skip Parent Mungers. I don't know much about the internal workings of aspectJ but this bug keeps popping up so I went through the trouble of checking of trying to debug it so that I could hopefully provide enough information to get it fixed. This happens while using eclipse AJDT. It never happens if I fully do a clean before rebuild. It only seems to happen when doing incrmental builds (using the project-&gt;build automatically setting). The error happens in the iterator that recursively builds a list of methods to return for matching. The error is triggered here: // we need to know if it is an interface from Parent kind munger // as those are used for @AJ ITD and we precisely want to skip those boolean shouldSkip = false; for (int j = 0; j &lt; rtx.interTypeMungers.size(); j++) { ConcreteTypeMunger munger = (ConcreteTypeMunger) rtx.interTypeMungers.get(j); if (munger.getMunger().getKind() == ResolvedTypeMunger.Parent) { shouldSkip = true; break; } } munger.getMunger() returns null because the munger instance is a BcelPerClauseAspectAdder. My naive fix would be to check munger.getMunger() == null or check munger.getKind(). I'm assuming that BcelPerClausAspectAdder is one that should be skipped since it is related to @AJ ??? Again, I don't know very much about the internal architecture of the weaver magic so I hope this is enough information. I would appreciate it if someone who knows more of the internals could speculate as to why this bug would never pop up on a clean build but only on incremental builds? Also it's not on all incremental builds and I haven't been able to isolate what kind of changes or compiles it triggers this, although it seems that once I got the exception once, I keep getting it on every build until I do a clean. java.lang.NullPointerException at org.aspectj.weaver.ResolvedType.addAndRecurse(ResolvedType.java:288) at org.aspectj.weaver.ResolvedType.getMethodsWithoutIterator(ResolvedType.java:257) at org.aspectj.weaver.ResolvedType.lookupResolvedMember(ResolvedType.java:378) at org.aspectj.weaver.JoinPointSignatureIterator.findSignaturesFromSupertypes(JoinPointSignatureIterator.java:178) at org.aspectj.weaver.JoinPointSignatureIterator.hasNext(JoinPointSignatureIterator.java:69) at org.aspectj.weaver.patterns.SignaturePattern.matches(SignaturePattern.java:287) at org.aspectj.weaver.patterns.KindedPointcut.matchInternal(KindedPointcut.java:103) at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:144) at org.aspectj.weaver.patterns.AndPointcut.matchInternal(AndPointcut.java:51) at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:144) at org.aspectj.weaver.ShadowMunger.match(ShadowMunger.java:64) at org.aspectj.weaver.Advice.match(Advice.java:109) at org.aspectj.weaver.bcel.BcelAdvice.match(BcelAdvice.java:104) at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2210) at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:1752) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:479) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:109) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1574) at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1525) at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1305) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1127) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:321) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:192) at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:862) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:269) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:168) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)
when trying to skip Parent Mungers. I don't know much about the internal workings of aspectJ but this bug keeps popping up so I went through the trouble of checking of trying to debug it so that I could hopefully provide enough information to get it fixed. This happens while using eclipse AJDT. It never happens if I fully do a clean before rebuild. It only seems to happen when doing incrmental builds (using the project-&gt;build automatically setting). The error happens in the iterator that recursively builds a list of methods to return for matching. The error is triggered here: // we need to know if it is an interface from Parent kind munger // as those are used for returns null because the munger instance is a . My naive fix would be to check or check. I'm assuming that is one that should be skipped since it is related to ??? Again, I don't know very much about the internal architecture of the weaver magic so I hope this is enough information. I would appreciate it if someone who knows more of the internals could speculate as to why this bug would never pop up on a clean build but only on incremental builds? Also it's not on all incremental builds and I haven't been able to isolate what kind of changes or compiles it triggers this, although it seems that once I got the exception once, I keep getting it on every build until I do a clean. 
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.finishTypeMungers(),True
tests/multiIncremental/PR141956/base/A.touchBeforeExecute(),False,new_method|test_method
tests/multiIncremental/PR141956/base/C.main(String[]),False,new_method|test_method
tests/multiIncremental/PR141956/base/C.foo(),False,new_method|test_method
tests/multiIncremental/PR141956/inc1/C.main(String[]),False,new_method|test_method
tests/multiIncremental/PR141956/inc1/C.foo(),False,new_method|test_method
tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.testPr141956_IncrementallyCompilingAtAj(),False,new_method|test_method
weaver/src/org/aspectj/weaver/ResolvedType.addAndRecurse(Set, List, ResolvedType, boolean, boolean),True
#####
AspectJ
138171
bf5c6b8b011fa305ec446e1e9ff5c45ef64f8814
Internal compilation error while copying resources This is with 1.5.1a. I am developing a web application and I ran into this compiler crash. The resource to be copied (Thumbs.db) was in use and therefore could not be copied. However, AJC ended up producing an internal error instead of a warning or a normal error. java.io.FileNotFoundException at java.io.FileOutputStream.open(Native Method) at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:179) at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:131) at org.aspectj.util.FileUtil.makeOutputStream(FileUtil.java:1258) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.writeResource(AjBuildManager.java:504) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.copyResourcesFromFile(AjBuildManager.java:482) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.copyResourcesToDestination(AjBuildManager.java:424) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:320) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:161) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) FileNotFoundException thrown: C:\work\workspace\MyCompany\class\images\Thumbs.db (Access is denied)
Internal compilation error while copying resources This is with 1.5.1a. I am developing a web application and I ran into this compiler crash. The resource to be copied (Thumbs.db) was in use and therefore could not be copied. However, AJC ended up producing an internal error instead of a warning or a normal error.
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.writeResource(String, byte[], File),True
#####
AspectJ
125480
e1e919408d346b7ff985c4920de7ab2d777a9d3c
[ltw] aop.xml aspect generator treats abstract methods as pointcuts An aop.xml aspect cannot inherit an abstract method but it should inherit one that has already been made concrete in a super-aspect. At the moment an abstract method "test()" causes the follow error during LTW: info AspectJ Weaver Version DEVELOPMENT built on info register classloader org.aspectj.weaver.loadtime.WeavingURLClassLoader info using /C:/temp/ajcSandbox/ajcTest6462.tmp/META-INF/aop.xml error Abstract pointcut 'test' not configured: &lt;concrete-aspect name='TraceHelloWorld' extends='ConcreteMethods'/&gt; in aop.xml warning register definition failed -- (AbortException) Abstract pointcut 'test' not configured: &lt;concrete-aspect name='TraceHelloWorld' extends='ConcreteMethods'/&gt; in aop.xml Abstract pointcut 'test' not configured: &lt;concrete-aspect name='TraceHelloWorld' extends='ConcreteMethods'/&gt; in aop.xml Message: error Abstract pointcut 'test' not configured: &lt;concrete-aspect name='TraceHelloWorld' extends='ConcreteMethods'/&gt; in aop.xml org.aspectj.bridge.AbortException: Abstract pointcut 'test' not configured: &lt;concrete-aspect name='TraceHelloWorld' extends='ConcreteMethods'/&gt; in aop.xml
aspect generator treats abstract methods as pointcuts An aspect cannot inherit an abstract method but it should inherit one that has already been made concrete in a. At the moment an abstract method "" causes the follow error during LTW: info AspectJ Weaver Version DEVELOPMENT built on info register classloader org.aspectj.weaver.loadtime.WeavingURLClassLoader info using /C:/temp/ajcSandbox/ajcTest6462.tmp/META-INF/aop.xml error Abstract pointcut 'test' not configured: &lt;concrete-aspect name='TraceHelloWorld' extends='ConcreteMethods'/&gt; in aop.xml warning register definition failed -- (AbortException) Abstract pointcut 'test' not configured: &lt;concrete-aspect name='TraceHelloWorld' extends='ConcreteMethods'/&gt; in aop.xml Abstract pointcut 'test' not configured: &lt;concrete-aspect name='TraceHelloWorld' extends='ConcreteMethods'/&gt; in aop.xml Message: error Abstract pointcut 'test' not configured: &lt;concrete-aspect name='TraceHelloWorld' extends='ConcreteMethods'/&gt; in aop.xml org.aspectj.bridge.AbortException: Abstract pointcut 'test' not configured
******
loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.validate(),True
#####
AspectJ
132349
4dea3ad2411d5ea80b6f49ed342e96e52a39a91a
Inter-Type Declaration on nested class in generic type: IllegalStateException Using the 1.5 compiler from the 20th of December or Eclipse with the AJDT plugin 1.5.0.20051220093604 to compile the following code: public class TopLevelType&lt;E&gt; { public static class NestedType {} } aspect SomeAspect { public void TopLevelType.NestedType.someMethod() { } } results in: C:\Dokumente und Einstellungen\Michi\Eigene Dateien\Temp\tmp\TopLevelType.java [error] Internal compiler error java.lang.IllegalStateException: Use generic type, not parameterized type at org.aspectj.weaver.ResolvedTypeMunger.&lt;init&gt;(ResolvedTypeMunger.java:69) at org.aspectj.weaver.NewMethodTypeMunger.&lt;init&gt;(NewMethodTypeMunger.java:28) at org.aspectj.ajdt.internal.compiler.ast.InterTypeMethodDeclaration.build(InterTypeMethodDeclaration.java:197) at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTypeAndPerClause(AspectDeclaration.java:1066) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildInterTypeAndPerClause(AjLookupEnvironment.java:442) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.collectAllITDsAndDeclares(AjLookupEnvironment.java:326) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:168) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:156) at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112) at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60) at org.aspectj.tools.ajc.Main.run(Main.java:326) at org.aspectj.tools.ajc.Main.runMain(Main.java:240) at org.aspectj.tools.ajc.Main.main(Main.java:83) (no source information available) ABORT Exception thrown from AspectJ 1.5.0 This might be logged as a bug already -- find current bugs at http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler Bugs for exceptions thrown have titles File:line from the top stack, e.g., "SomeFile.java:243" If you don't find the exception below in a bug, please add a new bug at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ To make the bug a priority, please include a test program that can reproduce this exception. Use generic type, not parameterized type when collecting itds and declares SomeAspect when completing type bindings when batch building with classpath: C:\Programme\Java\jre1.5.0_06\lib\ext\dnsns.jar;C:\Programme\Java\jre1.5.0_06\lib\ext\localedata.jar;C:\Programme\Java\jre1.5.0_06\lib\ext\sunjce_provider.jar;C:\Programme\Java\jre1.5.0_06\lib\ext\sunpkcs11.jar;C:\Programme\Java\aspectj1.5\lib\aspectjrt.jar; Use generic type, not parameterized type java.lang.IllegalStateException: Use generic type, not parameterized type at org.aspectj.weaver.ResolvedTypeMunger.&lt;init&gt;(ResolvedTypeMunger.java:69) at org.aspectj.weaver.NewMethodTypeMunger.&lt;init&gt;(NewMethodTypeMunger.java:28) at org.aspectj.ajdt.internal.compiler.ast.InterTypeMethodDeclaration.build(InterTypeMethodDeclaration.java:197) at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTypeAndPerClause(AspectDeclaration.java:1066) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildInterTypeAndPerClause(AjLookupEnvironment.java:442) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.collectAllITDsAndDeclares(AjLookupEnvironment.java:326) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:168) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:156) at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112) at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60) at org.aspectj.tools.ajc.Main.run(Main.java:326) at org.aspectj.tools.ajc.Main.runMain(Main.java:240) at org.aspectj.tools.ajc.Main.main(Main.java:83) 1 fail|abort, 1 error
Inter-Type Declaration on nested class in generic type: IllegalStateException Using the 1.5 compiler from the 20th of December or Eclipse with the AJDT plugin 1.5.0.20051220093604 to compile the following code: public class TopLevelType&lt;E&gt; { public static class NestedType {} } aspect SomeAspect { public void TopLevelType.NestedType.someMethod() { } } results in: C:\Dokumente und Einstellungen\Michi\Eigene Dateien\Temp\tmp\TopLevelType.java [error] Internal compiler error java.lang.IllegalStateException: Use generic type, not parameterized type at  (no source information available) ABORT Exception thrown from AspectJ 1.5.0 This might be logged as a bug already -- find current bugs at http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&amp;component=Compiler Bugs for exceptions thrown have titles File:line from the top stack, e.g., "SomeFile.java:243" If you don't find the exception below in a bug, please add a new bug at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ To make the bug a priority, please include a test program that can reproduce this exception. Use generic type, not parameterized type when collecting itds and declares SomeAspect when completing type bindings when batch building with classpath:  Use generic type, not parameterized type: Use generic type, not parameterized type at 
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeDeclaration.resolveOnType(ClassScope),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeDeclaration.ensureScopeSetup(),True
tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.testItdOnInnerTypeOfGenericType_pr132349(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.testItdOnInnerTypeOfGenericType_pr132349_2(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.testItdOnInnerTypeOfGenericType_pr132349_3(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.testCovarianceAndDecp_pr128443_1(),False,new_method|test_method
#####
AspectJ
72528
27d204cf9f57a0cc06f4d7c5800c93eb55edc02a
around advice throws java.lang.VerifyError at runtime I have an aspect that captures around() a pcd and returns an Object[], though the actual methods being instrumented might return any valid POJO array, i understand that AspectJ will take care of casting at assignment. I expected the following code to work properly, but at runtime i get a java.lang.VerifyError as shown below: F:\wd\Hello&gt;ajbrowser HelloWorld.lst java.lang.VerifyError: (class: de/rohith/PrinterWorld, method: returnArrayWithCl oning signature: ()[Ljava/lang/Integer;) Incompatible argument to function at de.rohith.HelloWorld.main(HelloWorld.java:18) Exception in thread "main" I suspect the compiler fails to notice the return types of the methods being caught at compile time. I have tested this code with both ajbrowser as well as AJDT, both result in the same error output. -----------HelloWorldAspect.java--------------- package de.rohith; import java.lang.Object; public aspect HelloWorldAspect { private int callDepth = -1; public HelloWorldAspect() { } pointcut hello(): !within(HelloWorldAspect); pointcut method(): execution(public (*[]) de..*(..)); pointcut cloning(): call(* java.lang.Object.clone()); declare warning: method() &amp;&amp; hello(): "*[] returning method called" ; Object[] around(): cflow(method()) &amp;&amp; cloning() &amp;&amp; hello() { print("", thisEnclosingJoinPointStaticPart); Object[] ret = proceed(); return (Object[])ret.clone(); } private void print(String prefix, Object message) { for (int i = 0, spaces = callDepth * 2; i &lt; spaces; i++) { System.out.print(" "); } System.out.println(prefix + message); } } -----------PrinterWorld.java------------ package de.rohith; public class PrinterWorld { private Integer[] intArray = new Integer[2]; public PrinterWorld() { } public void print() { System.out.println("Hello World!"); } public Integer returnInt() { return new Integer(3); } public Integer[] returnArrayWithCloning() { for (int i = 0; i &lt; intArray.length; i++) { intArray[i] = new Integer(i++); } return (Integer[])intArray.clone(); } public Integer[] returnArrayWithoutCloning() { return intArray; } } -----------HelloWorld.java------------ package de.rohith; public class HelloWorld { public static void main(String[] args) { PrinterWorld p = new PrinterWorld(); p.print(); Integer i = p.returnInt(); Integer[] intArray = p.returnArrayWithCloning(); Integer[] array2 = p.returnArrayWithoutCloning(); } }
around advice throws at runtime I have an aspect that captures a pcd and returns an, though the actual methods being instrumented might return any valid POJO array, i understand that AspectJ will take care of casting at assignment. I expected the following code to work properly, but at runtime i get a as shown below: : (class: method: oning signature: Incompatible argument to function at Exception in thread "main" I suspect the compiler fails to notice the return types of the methods being caught at compile time. I have tested this code with both as well as AJDT, both result in the same error output. 
******
tests/bugs/ArrayCloning.main(String[]),False,new_method
tests/bugs/ArrayCloning.checkIdentical(Integer[] one, Integer[]),False,new_method
tests/bugs/ArrayCloning.ArrayCloning(),False,new_method
tests/bugs/ArrayCloning.clone1(),False,new_method
tests/bugs/ArrayCloning.clone2(),False,new_method
tests/bugs/ArrayCloning.clone3(),False,new_method
tests/bugs/ArrayCloning.clone4(),False,new_method
tests/bugs/ArrayCloning.clone5(),False,new_method
tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.test056_arrayCloning(),False,new_method|test_method
weaver/src/org/aspectj/weaver/ResolvedTypeX.getDeclaredMethods(),True
weaver/src/org/aspectj/weaver/bcel/BcelShadow.initializeTargetVar(),True
weaver/src/org/aspectj/weaver/bcel/BcelShadow.ensureTargetTypeIsCorrect(TypeX),False,new_method
weaver/src/org/aspectj/weaver/bcel/BcelShadow.createMethodGen(String, int),True
#####
AspectJ
120739
4513e921c89fb3b8f037418a901e49906724e7bd
LTW Optimization: Disable World if it has No Aspects This optimization disables weaving for a ClassLoader where there are no aspects defined. This is actually useful if you have aspect exclusions that exclude all the aspects defined in a parent class loader. It is also helpful in the trivial/rare case where there is an aop.xml definition with no aspect definitions.
LTW Optimization: Disable World if it has No Aspects This optimization disables weaving for a where there are no aspects defined. This is actually useful if you have aspect exclusions that exclude all the aspects defined in a parent class loader. It is also helpful in the trivial/rare case where there is an aop.xml definition with no aspect definitions.
******
loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.initialize(ClassLoader, IWeavingContext),True
loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.registerAspects(BcelWeaver, ClassLoader, List),True
tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.testNoAspects(),False,new_method|test_method
#####
AspectJ
145086
f821ca3dae5681758d23a2a0531d0d42f017152e
NPE when weak reference set in signature Simon ran into the same problem in setting the values. I will attach a patch to fix this, with test cases to properly verify it works in both cases. java.lang.NullPointerException at org.aspectj.runtime.reflect.SignatureImpl$CacheImpl.set(SignatureImpl.java:224) at org.aspectj.runtime.reflect.SignatureImpl.toString(SignatureImpl.java:57) at org.aspectj.runtime.reflect.SignatureImpl.toString(SignatureImpl.java:62)
NPE when weak reference set in signature Simon ran into the same problem in setting the values. I will attach a patch to fix this, with test cases to properly verify it works in both cases.
******
runtime/testsrc/org/aspectj/runtime/reflect/JoinPointImplTest,False,comment
runtime/src/org/aspectj/runtime/reflect/SignatureImpl.CacheImpl(),True
runtime/src/org/aspectj/runtime/reflect/SignatureImpl.get(int),True
runtime/src/org/aspectj/runtime/reflect/SignatureImpl.set(int, String),True
runtime/src/org/aspectj/runtime/reflect/SignatureImpl.array(),False,Formatting
runtime/src/org/aspectj/runtime/reflect/SignatureImpl.makeCache(),False,new_method
runtime/testsrc/org/aspectj/runtime/reflect/SignatureTest.testClearCache(),False,new_method|test_method
#####
AspectJ
145950
39bc21c734ee42b99644f30b78ec0f135483e414
-XaddSerialVersionUID doesn't work if there is an indirect route to Serializable in the hierarchy -XaddSerialVersionUID fails to add a serialversionuid field to a type if Serializable isn't a direct parent. this case fails: class X implements I { } // X will not get the field if woven interface I implements Serializable {} this works: class X implements Serializable {} // X will get the field if woven there is a mistake in the code that checks for the serializable interface
-XaddSerialVersionUID doesn't work if there is an indirect route to Serializable in the hierarchy -XaddSerialVersionUID fails to add a serialversionuid field to a type if Serializable isn't a direct parent. this case fails: class X implements I { } // X will not get the field if woven interface I implements Serializable {} this works: class X implements Serializable {} // X will get the field if woven there is a mistake in the code that checks for the serializable interface
******
weaver/src/org/aspectj/weaver/bcel/LazyClassGen.implementsSerializable(ResolvedType),True
#####
AspectJ
146546
38cc0dd2f77eaea1778ede835e7da0aa9d871de7
"Remove hard coded dependency on ""|"" in getFileName(..) methods" As part of bug 141730 we need to remove the hard coded dependency on "|" in methods which use handles to get the filename. These methods are: AsmManager.getFileName(String) AspectJElementHierarchy.getFileName(String)
"Remove hard coded dependency on ""|"" in methods" As part of bug 141730 we need to remove the hard coded dependency on "|" in methods which use handles to get the filename. These methods are: 
******
asm/src/org/aspectj/asm/AsmManager.getFilename(String),True
asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.getFilename(String),True
#####
AspectJ
122580
75afb31e38f75e61de5c15058d3332f3dac0df15
Fix &amp; Bug: Circularity Failure for Verbose Loading on JRockit 1.4.2_08 Agent Here is a stack trace I am getting when I try to use AspectJ 1.5.0 final release's load-time weaving with JRockIt 1.4.2_08 using -Xmanagement:class=org.aspectj.weaver.loadtime.JRockitAgent to load Weblogic Server 8.1 SP2. I debugged the code in Eclipse and discovered that the weaver was being initialized while loading IMessage$Kind, so the JRockIt VM simply hasn't run staticinitialization yet, making IMessage.INFO null. I was able to fix this stack trace by hoisting the check for loading AspectJ code up BEFORE initializing a weaving adaptor i.e., changing line 55 of Aj.java to be if (loader == null || className == null || className.startsWith("org/aspectj/")) { I then commented out line 251 of WeavingAdaptor to avoid a duplicate check: private boolean shouldWeaveName (String name) { return !((/*(name.startsWith("org.apache.bcel.")||//FIXME AV why ? bcel is wrapped in org.aspectj. name.startsWith("org.aspectj.")||*/ // now checked earlier, to avoid circularity issues in initialization name.startsWith("java.") || name.startsWith("javax.")) //|| name.startsWith("$Proxy")//JDK proxies//FIXME AV is that 1.3 proxy ? fe. ataspect.$Proxy0 is a java5 proxy... || name.startsWith("sun.reflect."));//JDK reflect } Note that this bug does NOT occur when using a JRockIt 1.5.0 VM, even with the -Xmanagement command line argument. Stack Trace: java.lang.IllegalArgumentException: null kind at org.aspectj.bridge.Message.&lt;init&gt;(Ljava/lang/String;Ljava/lang/String;Lorg/aspectj/bridge/IMessage$Kind;Lorg/aspectj/bridge/ISourceLocation;Ljava/lang/Throwable;[Lorg/aspectj/bridge/ISourceLocation;ZIII)V(Message.java:89) at org.aspectj.bridge.Message.&lt;init&gt;(Ljava/lang/String;Ljava/lang/String;Lorg/aspectj/bridge/IMessage$Kind;Lorg/aspectj/bridge/ISourceLocation;Ljava/lang/Throwable;[Lorg/aspectj/bridge/ISourceLocation;)V(Message.java:67) at org.aspectj.bridge.Message.&lt;init&gt;(Ljava/lang/String;Lorg/aspectj/bridge/IMessage$Kind;Ljava/lang/Throwable;Lorg/aspectj/bridge/ISourceLocation;)V(Message.java:110) at org.aspectj.bridge.MessageUtil.info(Ljava/lang/String;)Lorg/aspectj/bridge/IMessage;(MessageUtil.java:211) at org.aspectj.bridge.MessageUtil.info(Lorg/aspectj/bridge/IMessageHandler;Ljava/lang/String;)Z(MessageUtil.java:98) at org.aspectj.weaver.tools.WeavingAdaptor.info(Ljava/lang/String;)Z(WeavingAdaptor.java:343) at org.aspectj.weaver.tools.WeavingAdaptor.createMessageHandler()V(WeavingAdaptor.java:168) at org.aspectj.weaver.tools.WeavingAdaptor.&lt;init&gt;()V(WeavingAdaptor.java:80) at org.aspectj.weaver.loadtime.ClassLoaderWeavingAdaptor.&lt;init&gt;(Ljava/lang/ClassLoader;Lorg/aspectj/weaver/loadtime/IWeavingContext;)V(ClassLoaderWeavingAdaptor.java:70) at org.aspectj.weaver.loadtime.Aj$WeaverContainer.getWeaver(Ljava/lang/ClassLoader;Lorg/aspectj/weaver/loadtime/IWeavingContext;)Lorg/aspectj/weaver/tools/WeavingAdaptor;(Aj.java:94) at org.aspectj.weaver.loadtime.Aj.preProcess(Ljava/lang/String;[BLjava/lang/ClassLoader;)[B(Aj.java:61) at org.aspectj.weaver.loadtime.JRockitAgent.preProcess(Ljava/lang/ClassLoader;Ljava/lang/String;[B)[B(JRockitAgent.java:74) at jrockit.vm.ClassPreProcessorManager.notifyClassPreProcessor(ILjava/lang/String;[B)[B(Unknown Source) at jrockit.vm.Classes.defineClass0(ILjava/lang/String;[BII)I(Unknown Source) at jrockit.vm.Classes.defineClass(Ljava/lang/ClassLoader;Ljava/lang/String;[BII)Ljava/lang/Class;(Unknown Source) at java.lang.ClassLoader.defineClass(Ljava/lang/String;[BIILjava/security/ProtectionDomain;)Ljava/lang/Class;(Unknown Source) at java.security.SecureClassLoader.defineClass(Ljava/lang/String;[BIILjava/security/CodeSource;)Ljava/lang/Class;(SecureClassLoader.java:123) at java.net.URLClassLoader.defineClass(Ljava/lang/String;Lsun/misc/Resource;)Ljava/lang/Class;(URLClassLoader.java:251) at java.net.URLClassLoader.access$100(Ljava/net/URLClassLoader;Ljava/lang/String;Lsun/misc/Resource;)Ljava/lang/Class;(URLClassLoader.java:55) at java.net.URLClassLoader$1.run()Ljava/lang/Object;(URLClassLoader.java:194) at jrockit.vm.AccessController.do_privileged_exc(Ljava/security/PrivilegedExceptionAction;Ljava/security/AccessControlContext;I)Ljava/lang/Object;(Unknown Source) at jrockit.vm.AccessController.doPrivileged(Ljava/security/PrivilegedExceptionAction;Ljava/security/AccessControlContext;)Ljava/lang/Object;(Unknown Source) at java.net.URLClassLoader.findClass(Ljava/lang/String;)Ljava/lang/Class;(URLClassLoader.java:187) at java.lang.ClassLoader.loadClass(Ljava/lang/String;Z)Ljava/lang/Class;(Unknown Source) at sun.misc.Launcher$AppClassLoader.loadClass(Ljava/lang/String;Z)Ljava/lang/Class;(Launcher.java:274) at java.lang.ClassLoader.loadClass(Ljava/lang/String;)Ljava/lang/Class;(Unknown Source) at java.lang.ClassLoader.loadClassFromNative(II)Ljava/lang/Class;(Unknown Source) at jrockit.vm.RNI.getRunnableCode(I)I(Unknown Source) at jrockit.vm.RNI.trampoline()V(Unknown Source) at org.aspectj.bridge.MessageUtil.info(Ljava/lang/String;)Lorg/aspectj/bridge/IMessage;(MessageUtil.java:???) at org.aspectj.bridge.MessageUtil.info(Lorg/aspectj/bridge/IMessageHandler;Ljava/lang/String;)Z(MessageUtil.java:98) at org.aspectj.weaver.tools.WeavingAdaptor.info(Ljava/lang/String;)Z(WeavingAdaptor.java:343) java.lang.IllegalArgumentException: null kind at org.aspectj.bridge.Message.&lt;init&gt;(Ljava/lang/String;Ljava/lang/String;Lorg/aspectj/bridge/IMessage$Kind;Lorg/aspectj/bridge/ISourceLocation;Ljava/lang/Throwable;[Lorg/aspectj/bridge/ISourceLocation;ZIII)V(Message.java:89) at org.aspectj.bridge.Message.&lt;init&gt;(Ljava/lang/String;Ljava/lang/String;Lorg/aspectj/bridge/IMessage$Kind;Lorg/aspectj/bridge/ISourceLocation;Ljava/lang/Throwable;[Lorg/aspectj/bridge/ISourceLocation;)V(Message.java:67) at org.aspectj.bridge.Message.&lt;init&gt;(Ljava/lang/String;Lorg/aspectj/bridge/IMessage$Kind;Ljava/lang/Throwable;Lorg/aspectj/bridge/ISourceLocation;)V(Message.java:110) at org.aspectj.bridge.MessageUtil.info(Ljava/lang/String;)Lorg/aspectj/bridge/IMessage;(MessageUtil.java:211) at org.aspectj.bridge.MessageUtil.info(Lorg/aspectj/bridge/IMessageHandler;Ljava/lang/String;)Z(MessageUtil.java:98) at org.aspectj.weaver.tools.WeavingAdaptor.info(Ljava/lang/String;)Z(WeavingAdaptor.java:343) at org.aspectj.weaver.tools.WeavingAdaptor.createMessageHandler()V(WeavingAdaptor.java:168) at org.aspectj.weaver.tools.WeavingAdaptor.&lt;init&gt;()V(WeavingAdaptor.java:80) at org.aspectj.weaver.loadtime.ClassLoaderWeavingAdaptor.&lt;init&gt;(Ljava/lang/ClassLoader;Lorg/aspectj/weaver/loadtime/IWeavingContext;)V(ClassLoaderWeavingAdaptor.java:70) at org.aspectj.weaver.loadtime.Aj$WeaverContainer.getWeaver(Ljava/lang/ClassLoader;Lorg/aspectj/weaver/loadtime/IWeavingContext;)Lorg/aspectj/weaver/tools/WeavingAdaptor;(Aj.java:94) at org.aspectj.weaver.loadtime.Aj.preProcess(Ljava/lang/String;[BLjava/lang/ClassLoader;)[B(Aj.java:61) at org.aspectj.weaver.loadtime.JRockitAgent.preProcess(Ljava/lang/ClassLoader;Ljava/lang/String;[B)[B(JRockitAgent.java:74) at jrockit.vm.ClassPreProcessorManager.notifyClassPreProcessor(ILjava/lang/String;[B)[B(Unknown Source) at jrockit.vm.Classes.defineClass0(ILjava/lang/String;[BII)I(Unknown Source) at jrockit.vm.Classes.defineClass(Ljava/lang/ClassLoader;Ljava/lang/String;[BII)Ljava/lang/Class;(Unknown Source) at java.lang.ClassLoader.defineClass(Ljava/lang/String;[BIILjava/security/ProtectionDomain;)Ljava/lang/Class;(Unknown Source) at java.security.SecureClassLoader.defineClass(Ljava/lang/String;[BIILjava/security/CodeSource;)Ljava/lang/Class;(SecureClassLoader.java:123) at java.net.URLClassLoader.defineClass(Ljava/lang/String;Lsun/misc/Resource;)Ljava/lang/Class;(URLClassLoader.java:251) at java.net.URLClassLoader.access$100(Ljava/net/URLClassLoader;Ljava/lang/String;Lsun/misc/Resource;)Ljava/lang/Class;(URLClassLoader.java:55) at java.net.URLClassLoader$1.run()Ljava/lang/Object;(URLClassLoader.java:194) at jrockit.vm.AccessController.do_privileged_exc(Ljava/security/PrivilegedExceptionAction;Ljava/security/AccessControlContext;I)Ljava/lang/Object;(Unknown Source) at jrockit.vm.AccessController.doPrivileged(Ljava/security/PrivilegedExceptionAction;Ljava/security/AccessControlContext;)Ljava/lang/Object;(Unknown Source) at java.net.URLClassLoader.findClass(Ljava/lang/String;)Ljava/lang/Class;(URLClassLoader.java:187) at java.lang.ClassLoader.loadClass(Ljava/lang/String;Z)Ljava/lang/Class;(Unknown Source) at sun.misc.Launcher$AppClassLoader.loadClass(Ljava/lang/String;Z)Ljava/lang/Class;(Launcher.java:274) at java.lang.ClassLoader.loadClass(Ljava/lang/String;)Ljava/lang/Class;(Unknown Source) at java.lang.ClassLoader.loadClassFromNative(II)Ljava/lang/Class;(Unknown Source) at jrockit.vm.RNI.getRunnableCode(I)I(Unknown Source) at jrockit.vm.RNI.trampoline()V(Unknown Source) at org.aspectj.bridge.MessageUtil.info(Lorg/aspectj/bridge/IMessageHandler;Ljava/lang/String;)Z(MessageUtil.java:???) at org.aspectj.weaver.tools.WeavingAdaptor.info(Ljava/lang/String;)Z(WeavingAdaptor.java:343) at org.aspectj.weaver.tools.WeavingAdaptor.createMessageHandler()V(WeavingAdaptor.java:168)
Fix &amp; Bug: Circularity Failure for Verbose Loading on 1.4.2_08 Agent Here is a stack trace I am getting when I try to use AspectJ 1.5.0 final release's load-time weaving with JRockIt 1.4.2_08 using - to load Server 8.1 SP2. I debugged the code in Eclipse and discovered that the weaver was being initialized while loading , so the JRockIt VM simply hasn't run  yet, making  I was able to fix this stack trace by hoisting the check for loading AspectJ code up BEFORE initializing a weaving adaptor i.e., changing line 55 of  to be I then commented out line 251 of WeavingAdaptor to avoid a duplicate check: private boolean //FIXME AV why ? bcel is wrapped in ||*/ // now checked earlier, to avoid circularity issues in initialization //JDK proxies//FIXME AV is that 1.3 proxy  Note that this bug does NOT occur when using a  1.5.0 VM, even with the - command line argument.
******
loadtime/src/org/aspectj/weaver/loadtime/Aj.preProcess(String, byte[], ClassLoader),True
loadtime/src/org/aspectj/weaver/loadtime/JRockitAgent.JRockitAgent(),False,new_method
loadtime/src/org/aspectj/weaver/loadtime/JRockitAgent.preProcess(ClassLoader, String, byte[]),True
loadtime/src/org/aspectj/weaver/loadtime/JRockitAgent.empty(),False,new_method
loadtime/src/org/aspectj/weaver/loadtime/JRockitAgent.JRockitAgent(),True
loadtime/src/org/aspectj/weaver/loadtime/JRockitAgent.peek(),False,new_method
loadtime/src/org/aspectj/weaver/loadtime/JRockitAgent.push (Object),False,new_method
loadtime/src/org/aspectj/weaver/loadtime/JRockitAgent.pop(),False,new_method
initializeValue(),False,new_method
loadtime/testsrc/LoadtimeModuleTests.suite(),False,test_method
loadtime/testsrc/org/aspectj/bea/jvm/ClassLibraryImpl.getClassPreProcessor(),False,new_method|test_method
setClassPreProcessor(ClassPreProcessor),False,new_method|test_method
loadtime/testsrc/org/aspectj/bea/jvm/JVMImpl.getClassLibrary(),False,new_method|test_method
loadtime/testsrc/org/aspectj/weaver/loadtime/JRockitAgentTest.setUp(),False,new_method|test_method
loadtime/testsrc/org/aspectj/weaver/loadtime/JRockitAgentTest.tearDown(),False,new_method|test_method
loadtime/testsrc/org/aspectj/weaver/loadtime/JRockitAgentTest.testJRockitAgent(),False,new_method|test_method
loadtime/testsrc/org/aspectj/weaver/loadtime/JRockitAgentTest.testPreProcess(),False,new_method|test_method
loadtime/testsrc/org/aspectj/weaver/loadtime/JRockitAgentTest.testJrockitRecursionProtection(),False,new_method|test_method
loadtime/testsrc/org/aspectj/weaver/loadtime/JRockitAgentTest.JRockitClassLoader(URLClassLoader),False,new_method|test_method
loadtime/testsrc/org/aspectj/weaver/loadtime/JRockitAgentTest.findClass(String),False,new_method|test_method
loadtime/testsrc/org/aspectj/weaver/loadtime/JRockitAgentTest.defineClass(String, byte[]),False,new_method|test_method
loadtime/testsrc/org/aspectj/weaver/loadtime/JRockitAgentTest.loadClassFromFile(String, File),False,new_method|test_method
loadtime/testsrc/org/aspectj/weaver/loadtime/JRockitAgentTest.loadBytesFromZipEntry(JarFile, ZipEntry),False,new_method|test_method
loadtime/testsrc/org/aspectj/weaver/loadtime/JRockitAgentTest.readBytes(InputStream, byte[]),False,new_method|test_method
#####
AspectJ
132591
319a0d15703c098b74335ecb9672f58166bf3c5b
Duplicate exception with aop.xml file on aspectpath See also bug #57666 which is related (but has to do with manifests): I have a META-INF/aop.xml file in my aspectpath and another one in the source path. That shouldn't even be a duplicate, because the aspectpath resource should NOT be copied to output at all. In AspectJ build: 1.5.1.20060309143651 I am now getting: java.util.zip.ZipException at java.util.zip.ZipOutputStream.putNextEntry(ZipOutputStream.java:163) at java.util.jar.JarOutputStream.putNextEntry(JarOutputStream.java:90) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.writeOutxmlFile(AjBuildManager.java:549) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:320) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:163) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) ZipException thrown: duplicate entry: META-INF/aop.xml
Duplicate exception with aop.xml file on aspectpath See also bug #57666 which is related (but has to do with manifests): I have a META-INF/aop.xml file in my aspectpath and another one in the source path. That shouldn't even be a duplicate, because the aspectpath resource should NOT be copied to output at all. In AspectJ build: 1.5.1.20060309143651 I am now getting: 
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.writeResource(String, byte[], File),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.writeOutxmlFile(),True
ajde/testsrc/org/aspectj/ajde/NullIdeProperties.getSourcePathResources(),False,test_method
ajde/testsrc/org/aspectj/ajde/OutxmlTest.testOutxmlToOutjarWithAop_xml(),False,new_method|test_method
#####
AspectJ
136707
008efca98bdfe5cda6c32ec75575facf7da2c687
iajc should print summary like javac The iajc ant task should produce a summary of what it is doing, like the javac task does: [javac] Compiling 189 source files to C:\project\classes
iajc should print summary like javac The iajc ant task should produce a summary of what it is doing, like the javac task does: [javac] Compiling 189 source files to 
******
taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.reset(),True
taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.setLogCommand(boolean),False,new_method
taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.execute(),True
taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.testDefaultFileComplete(),True
taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.defaultSettings(AjcTask),False,new_method
taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.testLogCommand(),False,new_method
taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.LogListener(int),False,new_method
taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.buildFinished(BuildEvent),False,new_method
taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.buildStarted(BuildEvent),False,new_method
taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.messageLogged(BuildEvent),False,new_method
taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.targetFinished(BuildEvent),False,new_method
taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.targetStarted(BuildEvent),False,new_method
taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.taskFinished(BuildEvent),False,new_method
taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.taskStarted(BuildEvent),False,new_method
taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.getResults(),False,new_method
#####
AspectJ
147701
1468daa88534262ebdd209574d3be360a0c78143
"@DeclareParents does not use FQNs for exceptions declared in throws-clauses, leading to NoClassDefFoundError" This is my code: @Aspect public class TestBeanAdvice { public static class ApplicationContextAwareImpl implements ApplicationContextAware { public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { } } @DeclareParents(value="org.springframework.beans.TestBean", defaultImpl=TestBeanAdvice.ApplicationContextAwareImpl.class) private ApplicationContextAware implementationInterface; } If I use this advice with the load-time weaver I get this exception: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'testBean' defined in class path resource [org/springframework/context/support/testbean-context.xml]: Instantiation of bean failed; nested exception is java.lang.NoClassDefFoundError: BeansException Caused by: java.lang.NoClassDefFoundError: BeansException at java.lang.Class.getDeclaredMethods0(Native Method) at java.lang.Class.privateGetDeclaredMethods(Class.java:2365) at java.lang.Class.getDeclaredMethods(Class.java:1763) at java.beans.Introspector$1.run(Introspector.java:1265) at java.security.AccessController.doPrivileged(Native Method) at java.beans.Introspector.getPublicDeclaredMethods(Introspector.java:1263) at java.beans.Introspector.getTargetMethodInfo(Introspector.java:1129) at java.beans.Introspector.getBeanInfo(Introspector.java:387) at java.beans.Introspector.getBeanInfo(Introspector.java:159) at org.springframework.beans.CachedIntrospectionResults.&lt;init&gt;(CachedIntrospectionResults.java:142) at org.springframework.beans.CachedIntrospectionResults.forClass(CachedIntrospectionResults.java:83) at org.springframework.beans.BeanWrapperImpl.setIntrospectionClass(BeanWrapperImpl.java:238) at org.springframework.beans.BeanWrapperImpl.setWrappedInstance(BeanWrapperImpl.java:196) at org.springframework.beans.BeanWrapperImpl.setWrappedInstance(BeanWrapperImpl.java:179) at org.springframework.beans.BeanWrapperImpl.&lt;init&gt;(BeanWrapperImpl.java:132) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateBean(AbstractAutowireCapableBeanFactory.java:502) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:356) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:256) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:167) at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:253) at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:332) at org.springframework.context.support.AspectJClassLoaderWithGenericApplicationContextTests.testCreateApplicationContextWithBeanFactoryAndAspectJClassLoader(AspectJClassLoaderWithGenericApplicationContextTests.java:63) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at com.intellij.rt.execution.junit2.JUnitStarter.main(JUnitStarter.java:32) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at com.intellij.rt.execution.application.AppMain.main(AppMain.java:90) (wrapped in a Spring exception, I'm using the container) After doing some debugging I found the exception appears when loading the dependencies of the TestBean class, so I guess there's a problem with the way the parent is declared in the bytecode of TestBean. You can find the TestBean class here: http://fisheye1.cenqua.com/browse/~raw,r=1.28/springframework/spring/test/org/springframework/beans/TestBean.java Steven
" does not use FQNs for exceptions declared in throws-clauses, leading to" This is my code: wrapped in a Spring exception, I'm using the container) After doing some debugging I found the exception appears when loading the dependencies of the class, so I guess there's a problem with the way the parent is declared in the bytecode of . You can find the  class here: Steven
******
tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.testPackageIgnoredForException_pr147701_1(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.testPackageIgnoredForException_pr147701_2(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.testPackageIgnoredForException_pr147701_3(),False,new_method|test_method
weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.handleDeclareParentsAnnotation(RuntimeAnnotations, AjAttributeFieldStruct),True
weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.mungeMethodDelegate(BcelClassWeaver, MethodDelegateTypeMunger),False,comments
weaver/src/org/aspectj/weaver/bcel/BcelWorld.makeBcelTypesAsClassNames(UnresolvedType[]),True
#####
AspectJ
147801
13dde4efd453d32bb4f25781a8fa7aafc2cef850
java.lang.ClassFormatError: Repetitive method name/signature I get a ClassFormatError trying to perform runtime-weaving on a DB2 class. The class being woven is COM.ibm.db2.jdbc.app.DB2PreparedStatement. The full message exception is: java.lang.ClassFormatError: Repetitive method name/signature in class file COM/ibm/db2/jdbc/app/DB2PreparedStatement. In examining the post-weave class file, it looks as if Aspectj is defining a duplicate method within the class called getParameterMetaData(). Here are the messages from the weaver: 04:21:13,640 INFO [STDOUT] info weaving 'COM.ibm.db2.jdbc.app.DB2CallableStatement' 04:21:13,640 INFO [STDOUT] info weaver operating in reweavable mode. Need to verify any required types exist. 04:21:13,671 INFO [STDOUT] info weaving 'COM.ibm.db2.jdbc.app.DB2PreparedStatement' 04:21:13,671 INFO [STDOUT] info weaver operating in reweavable mode. Need to verify any required types exist. 04:21:13,703 INFO [STDOUT] weaveinfo Join point 'method-execution(java.sql.ResultSet COM.ibm.db2.jdbc.app.DB2PreparedStatement.executeQuery())' in Type 'COM.ibm.db2.jdbc.app.DB2PreparedStatement' (DB2PreparedStatement.java:1679) advised by before advice from 'com.ibm.tivoli.itcam.toolkit.ai.aspectj.captureJDBC.CaptureSQLStatement' (CaptureSQLStatement.aj:747) [with runtime test] 04:21:13,703 INFO [STDOUT] weaveinfo Join point 'method-execution(java.sql.ResultSet COM.ibm.db2.jdbc.app.DB2PreparedStatement.executeQuery())' in Type 'COM.ibm.db2.jdbc.app.DB2PreparedStatement' (DB2PreparedStatement.java:1679) advised by afterReturning advice from 'com.ibm.tivoli.itcam.toolkit.ai.aspectj.captureJDBC.CaptureSQLStatement' (CaptureSQLStatement.aj:946) [with runtime test] 04:21:13,718 INFO [STDOUT] weaveinfo Join point 'method-execution(java.sql.ResultSet COM.ibm.db2.jdbc.app.DB2PreparedStatement.executeQuery())' in Type 'COM.ibm.db2.jdbc.app.DB2PreparedStatement' (DB2PreparedStatement.java:1679) advised by afterThrowing advice from 'com.ibm.tivoli.itcam.toolkit.ai.aspectj.captureJDBC.CaptureSQLStatement' (CaptureSQLStatement.aj:971) [with runtime test] 04:21:13,718 INFO [STDOUT] weaveinfo Join point 'method-execution(boolean COM.ibm.db2.jdbc.app.DB2PreparedStatement.execute())' in Type 'COM.ibm.db2.jdbc.app.DB2PreparedStatement' (DB2PreparedStatement.java:3971) advised by before advice from 'com.ibm.tivoli.itcam.toolkit.ai.aspectj.captureJDBC.CaptureSQLStatement' (CaptureSQLStatement.aj:833) [with runtime test] 04:21:13,718 INFO [STDOUT] weaveinfo Join point 'method-execution(boolean COM.ibm.db2.jdbc.app.DB2PreparedStatement.execute())' in Type 'COM.ibm.db2.jdbc.app.DB2PreparedStatement' (DB2PreparedStatement.java:3971) advised by afterReturning advice from 'com.ibm.tivoli.itcam.toolkit.ai.aspectj.captureJDBC.CaptureSQLStatement' (CaptureSQLStatement.aj:946) [with runtime test]
Repetitive method name/signature I get a trying to perform runtime-weaving on a class. The class being woven is The full message exception is: : Repetitive method name/signature in class file . In examining the post-weave class file, it looks as if Aspectj is defining a duplicate method within the class called . Here are the messages from the weaver: 
******
tests/bugs152/pr147801/Foo.main(String),False,new_method|test_method
tests/bugs152/pr147801/Foo.getParameterMetaData(),False,new_method|test_method
tests/bugs152/pr147801/PreparedStatement.getParameterMetaData(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.testDuplicateBridgeMethods_pr147801_1(),False,new_method|test_method
weaver/src/org/aspectj/weaver/World.ensureAdvancedConfigurationProcessed(),True
weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.createBridgeMethod(BcelWorld, LazyMethodGen, LazyClassGen, ResolvedMember),True
weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.isOverriding(ResolvedType, ResolvedMember, String, String, int, boolean, UnresolvedType[]),True
weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.checkForOverride(ResolvedType, String, String, mrettype, int, String, UnresolvedType[]),True
weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.calculateAnyRequiredBridgeMethods(BcelWorld, LazyClassGen),True
#####
AspectJ
148545
be2aca6940a820f96cfc4a6deeb7d4be5bba767d
NoSuchMethodError calling generic method of privileged aspect from advice MyEnum.java =========== public enum MyEnum { ONE, TWO, THREE, FOUR, FIVE } --- MyAnnotation.java ================= import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; @Retention(RetentionPolicy.RUNTIME) public @interface MyAnnotation { MyEnum[] value(); } --- MyClass.java ============ public class MyClass { public MyEnum getValue() { return MyEnum.ONE; } @MyAnnotation({ MyEnum.ONE, MyEnum.TWO }) public void test() { } public static void main(String[] args) { new MyClass().test(); } } --- MyAspect.aj =========== import java.util.Arrays; privileged public aspect MyAspect { Object around(MyClass o, MyAnnotation a) : execution(@MyAnnotation * *(..)) &amp;&amp; target(o) &amp;&amp; @annotation(a) { if (!isOneOf(o.getValue(), a.value())) throw new IllegalStateException( o.getValue() + " is not one of " + Arrays.toString(a.value())); return proceed(o, a); } private static final &lt;T&gt; boolean isOneOf(T obj, T[] arr) { for (T el : arr) if (obj == el) return true; return false; } } --- Executing the main method of MyClass produces: Exception in thread "main" java.lang.NoSuchMethodError: MyAspect.isOneOf(LMyEnum;[LMyEnum;)Z at MyAspect.ajc$privMethod$MyAspect$MyAspect$isOneOf(MyAspect.aj:1) at MyClass.test_aroundBody1$advice(MyClass.java:109) at MyClass.test(MyClass.java:1) at MyClass.main(MyClass.java:12) --- What's interesting is that if you remove the "privileged" modifier from the aspect definition, then it works fine.
calling generic method of privileged aspect from advice  --- Executing the main method of produces: --- What's interesting is that if you remove the "privileged" modifier from the aspect definition, then it works fine.
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/PrivilegedHandler.getPrivilegedAccessMethod(MethodBinding, ASTNode), True
#####
AspectJ
148536
ec9b7f9c79f7f1e5c2ae616b3fd290448a6ee8b5
NullPointerException when declaring inter-type annotation public aspect Bug { declare @type : Object+ : @SomeAnnotation; } If SomeAnnotation cannot be found, this aspect produces an internal compiler error: java.lang.NullPointerException at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.doDeclareAnnotations(AjLookupEnvironment.java:806) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:592) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveIntertypes(AjLookupEnvironment.java:363) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:214) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:862) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:242) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:161) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) NullPointerException thrown: null
when declaring inter-type annotation If cannot be found, this aspect produces an internal compiler error
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.doDeclareAnnotations(DeclareAnnotation, SourceTypeBinding, boolean),True
#####
AspectJ
148786
792d1dfd50e8b9ca5df70ea84c0b35de9cfba0f3
new array construction join point can fail for freaky array constructors Took me a while to discover how to recreate this problem, but this class: public class A { public static void main(String []argv) { byte[][] bytes = new byte[][]{{0},{1}}; } } causes this bytecode: 0: iconst_2 1: anewarray #18; //class "[B" and this causes the newarray joinpoint code to go bang. (eg. before(): call(*[].new(..)) {}) java.lang.NullPointerException at org.aspectj.weaver.bcel.BcelWorld.fromBcel(BcelWorld.java:236) at org.aspectj.weaver.bcel.BcelWorld.makeJoinPointSignatureForArrayConstruction(BcelWorld.java:483) at org.aspectj.weaver.bcel.BcelShadow.makeArrayConstructorCall(BcelShadow.java:801) at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2510) at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2325) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:490) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:115) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1574) at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1525) at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1305) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1127)
new array construction join point can fail for freaky array constructors Took me a while to discover how to recreate this problem, but this class: causes this bytecode:  and this causes the code to go bang. 
******
tests/bugs152/pr148786/A.main(String),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.testFreakyNewArrayJoinpoint_pr148786(),False,new_method|test_method
weaver/src/org/aspectj/weaver/bcel/BcelWorld.makeJoinPointSignatureForArrayConstruction(LazyClassGen, InstructionHandle),True
#####
AspectJ
148388
99d1c184fdbaafc772ae290d7af3b3430e33d33b
LTW weaver produces a debug message at the begining Using the code in bug #148381 (with any of the working options), LT weaver produces what seems a debug message: "? WeavingClassFileProvider.acceptResult() test.Main-&gt;test.Main$AjcClosure1" &gt; java -javaagent:%ASPECTJ_LIB_HOME%\aspectjweaver.jar test.Main ? WeavingClassFileProvider.acceptResult() test.Main-&gt;test.Main$AjcClosure1 Method Main.foo() took longer than expected Max expected = 1000, actual = 65371
LTW weaver produces a debug message at the begining Using the code in bug #148381 (with any of the working options), LT weaver produces what seems a debug message: "? took longer than expected Max expected = 1000, actual = 65371
******
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.acceptResult(UnwovenClassFile),True
#####
AspectJ
148727
21e06a69892469bab688d2315e7e034047431082
Can't call synthetic aspectOf method on aspect in library jar Separate compilation of the following program breaks on 1.5.2rc1 because of the recent change to marking aspect methods as synthetic: public aspect Asp { } public class Client { public static void main(String argz[]) { System.out.println("Can call aspectOf? "+Asp.aspectOf()); } } C:\devel\scratch\synthetic&gt;ajc -classpath asp.jar;%CLASSPATH% Client.java C:\devel\scratch\synthetic\Client.java:3 [error] The method aspectOf() is undefi ned for the type Asp System.out.println("Can call aspectOf? "+Asp.aspectOf()); 1 error C:\devel\scratch\synthetic&gt;javac -classpath asp.jar;%CLASSPATH% Client.java Client.java:3: cannot find symbol symbol : method aspectOf() location: class Asp System.out.println("Can call aspectOf? "+Asp.aspectOf()); ^ 1 error Clearly it's vital that external users of a library be able to call API methods like aspectOf on library aspects. This works: C:\devel\scratch\synthetic&gt;ajc *.aj Client.java C:\devel\scratch\synthetic&gt;java Client Can call aspectOf? Asp@b89838 Patch with test integrated into CVS tree to follow...
Can't call synthetic method on aspect in library jar Separate compilation of the following program breaks on 1.5.2rc1 because of the recent change to marking aspect methods as synthetic: The method is undefi ned for the type Asp cannot find symbol symbol : method location: class error Clearly it's vital that external users of a library be able to call API methods like  on library aspects. This works Client Can call ? Patch with test integrated into CVS tree to follow...
******
tests/bugs152/pr148727/Client.main(String),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.testSeparateCallAspectOf_pr148727(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.testIntegratedCallAspectOf_pr148727(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.testIncorrectOverridesEvaluation14(),False,new_method|test_method
weaver/src/org/aspectj/weaver/NameMangler.isSyntheticMethod(String, boolean),True
#####
AspectJ
148693
82f217fa97084beaa1c4c88ec2e96e4cf83e8aad
woven class does not pass org.apache.bcel.verifier.statics.Pass2Verifier 'Number of LocalVariableTable attributes of Code attribute '&lt;CODE&gt;' (method 'public static mypackage.MyAspect aspectOf() [(Unknown attribute org.aspectj.weaver.AjSynthetic)]') exceeds number of local variable slots '0' ('There may be no more than one LocalVariableTable attribute per local variable in the Code attribute.').'. ================================================= package mypackage; public aspect MyAspect { pointcut executeMethod(): within(TestClass) &amp;&amp; execution(* *(..)); before(): executeMethod() { System.out.println("Enter "+thisJoinPointStaticPart); } after(): executeMethod() { System.out.println("Leave "+thisJoinPointStaticPart); } } class TestClass { public static void main(String[] args) { } } ================================================ JustIce by Enver Haase, (C) 2001-2002. &lt;http://bcel.sourceforge.net&gt; &lt;http://jakarta.apache.org/bcel&gt; Now verifying: mypackage.TestClass Pass 1: VERIFIED_OK Passed verification. Pass 2: VERIFIED_OK Passed verification. Pass 3a, method number 0 ['public void &lt;init&gt;()']: VERIFIED_OK Passed verification. Pass 3b, method number 0 ['public void &lt;init&gt;()']: VERIFIED_OK Passed verification. Pass 3a, method number 1 ['public static void main(String[] args) [(Unknown attribute org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 00 00 00 46)]']: VERIFIED_REJECTED Instruction invokestatic[184](3) 28 constraint violated: Return type class/interface could not be verified successfully: 'Number of LocalVariableTable attributes of Code attribute '&lt;CODE&gt;' (method 'public static mypackage.MyAspect aspectOf() [(Unknown attribute org.aspectj.weaver.AjSynthetic)]') exceeds number of local variable slots '0' ('There may be no more than one LocalVariableTable attribute per local variable in the Code attribute.').'. Pass 3b, method number 1 ['public static void main(String[] args) [(Unknown attribute org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 00 00 00 46)]']: VERIFIED_NOTYET Not yet verified. Pass 3a, method number 2 ['static void &lt;clinit&gt;()']: VERIFIED_OK Passed verification. Pass 3b, method number 2 ['static void &lt;clinit&gt;()']: VERIFIED_OK Passed verification. Warnings: Pass 2: Attribute '(Unknown attribute org.aspectj.weaver.WeaverVersion: 00 03 00 00 00 00 00 00 00 00... (truncated))' as an attribute of the ClassFile structure 'public class mypackage.TestClass extends java.lang.Object filename mypackage.TestClass compiled from TestClass.java compiler version 46.0 access flags 33 constant pool 69 entries ACC_SUPER flag true Attribute(s): SourceFile(TestClass.java) (Unknown attribute org.aspectj.weaver.WeaverVersion: 00 03 00 00 00 00 00 00 00 00... (truncated)) (Unknown attribute org.aspectj.weaver.WeaverState: 53 00 00 00 01 00 12 6d 79 70... (truncated)) 1 fields: private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_0 3 methods: public void &lt;init&gt;() public static void main(String[] args) [(Unknown attribute org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 00 00 00 46)] static void &lt;clinit&gt;() ' is unknown and will therefore be ignored. Pass 2: Attribute '(Unknown attribute org.aspectj.weaver.WeaverState: 53 00 00 00 01 00 12 6d 79 70... (truncated))' as an attribute of the ClassFile structure 'public class mypackage.TestClass extends java.lang.Object filename mypackage.TestClass compiled from TestClass.java compiler version 46.0 access flags 33 constant pool 69 entries ACC_SUPER flag true Attribute(s): SourceFile(TestClass.java) (Unknown attribute org.aspectj.weaver.WeaverVersion: 00 03 00 00 00 00 00 00 00 00... (truncated)) (Unknown attribute org.aspectj.weaver.WeaverState: 53 00 00 00 01 00 12 6d 79 70... (truncated)) 1 fields: private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_0 3 methods: public void &lt;init&gt;() public static void main(String[] args) [(Unknown attribute org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 00 00 00 46)] static void &lt;clinit&gt;() ' is unknown and will therefore be ignored. Pass 2: Attribute '&lt;LocalVariableTable: LocalVariable(start_pc = 0, length = 5, index = 0:mypackage.TestClass this)&gt;' as an attribute of Code attribute '&lt;CODE&gt;' (method 'public void &lt;init&gt;()') will effectively be ignored and is only useful for debuggers and such. Pass 2: Attribute '&lt;LineNumberTable: LineNumber(0, 3)&gt;' as an attribute of Code attribute '&lt;CODE&gt;' (method 'public void &lt;init&gt;()') will effectively be ignored and is only useful for debuggers and such. Pass 2: Attribute '(Unknown attribute org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 00 00 00 46)' as an attribute of Method 'public static void main(String[] args) [(Unknown attribute org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 00 00 00 46)]' is unknown and will therefore be ignored. Pass 2: Attribute '(Unknown attribute org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 00 00 00 46)' as an attribute of Method 'public static void main(String[] args) [(Unknown attribute org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 00 00 00 46)]' is neither Code nor Exceptions and is therefore only of use for debuggers and such. Pass 2: Unknown attribute '(Unknown attribute org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 00 00 00 46)'. This attribute is not known in any context! Pass 2: Attribute '&lt;LocalVariableTable: LocalVariable(start_pc = 9, length = 0, index = 0:String[] args)&gt;' as an attribute of Code attribute '&lt;CODE&gt;' (method 'public static void main(String[] args) [(Unknown attribute org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 00 00 00 46)]') will effectively be ignored and is only useful for debuggers and such. Pass 2: Attribute '&lt;LineNumberTable: LineNumber(9, 6)&gt;' as an attribute of Code attribute '&lt;CODE&gt;' (method 'public static void main(String[] args) [(Unknown attribute org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 00 00 00 46)]') will effectively be ignored and is only useful for debuggers and such. Pass 2: Class or interface initialization method 'static void &lt;clinit&gt;()' has superfluous access modifier(s) set: everything but ACC_STRICT is ignored. Pass 2: Attribute '&lt;LineNumberTable: LineNumber(0, 1)&gt;' as an attribute of Code attribute '&lt;CODE&gt;' (method 'static void &lt;clinit&gt;()') will effectively be ignored and is only useful for debuggers and such. Pass 2: Unknown attribute '(Unknown attribute org.aspectj.weaver.WeaverVersion: 00 03 00 00 00 00 00 00 00 00... (truncated))'. This attribute is not known in any context! Pass 2: Unknown attribute '(Unknown attribute org.aspectj.weaver.WeaverState: 53 00 00 00 01 00 12 6d 79 70... (truncated))'. This attribute is not known in any context!
woven class does not pass org.apache.bcel.verifier.statics.Pass2Verifier 'Number of LocalVariableTable attributes of Code attribute '&lt;CODE&gt;' (method 'public static mypackage.MyAspect aspectOf() [(Unknown attribute org.aspectj.weaver.AjSynthetic)]') exceeds number of local variable slots '0' ('There may be no more than one LocalVariableTable attribute per local variable in the Code attribute.').'. ================================================= package mypackage; public aspect MyAspect { pointcut executeMethod(): within(TestClass) &amp;&amp; execution(* *(..)); before(): executeMethod() { System.out.println("Enter "+thisJoinPointStaticPart); } after(): executeMethod() { System.out.println("Leave "+thisJoinPointStaticPart); } } class TestClass { public static void main(String[] args) { } } ================================================ JustIce by Enver Haase, (C) 2001-2002. &lt;http://bcel.sourceforge.net&gt; &lt;http://jakarta.apache.org/bcel&gt; Now verifying: mypackage.TestClass Pass 1: VERIFIED_OK Passed verification. Pass 2: VERIFIED_OK Passed verification. Pass 3a, method number 0 ['public void &lt;init&gt;()']: VERIFIED_OK Passed verification. Pass 3b, method number 0 ['public void &lt;init&gt;()']: VERIFIED_OK Passed verification. Pass 3a, method number 1 ['public static void main(String[] args) [(Unknown attribute org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 00 00 00 46)]']: VERIFIED_REJECTED Instruction invokestatic[184](3) 28 constraint violated: Return type class/interface could not be verified successfully: 'Number of LocalVariableTable attributes of Code attribute '&lt;CODE&gt;' (method 'public static mypackage.MyAspect aspectOf() [(Unknown attribute org.aspectj.weaver.AjSynthetic)]') exceeds number of local variable slots '0' ('There may be no more than one LocalVariableTable attribute per local variable in the Code attribute.').'. Pass 3b, method number 1 ['public static void main(String[] args) [(Unknown attribute org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 00 00 00 46)]']: VERIFIED_NOTYET Not yet verified. Pass 3a, method number 2 ['static void &lt;clinit&gt;()']: VERIFIED_OK Passed verification. Pass 3b, method number 2 ['static void &lt;clinit&gt;()']: VERIFIED_OK Passed verification. Warnings: Pass 2: Attribute '(Unknown attribute org.aspectj.weaver.WeaverVersion: 00 03 00 00 00 00 00 00 00 00... (truncated))' as an attribute of the ClassFile structure 'public class mypackage.TestClass extends java.lang.Object filename mypackage.TestClass compiled from TestClass.java compiler version 46.0 access flags 33 constant pool 69 entries ACC_SUPER flag true Attribute(s): SourceFile(TestClass.java) (Unknown attribute org.aspectj.weaver.WeaverVersion: 00 03 00 00 00 00 00 00 00 00... (truncated)) (Unknown attribute org.aspectj.weaver.WeaverState: 53 00 00 00 01 00 12 6d 79 70... (truncated)) 1 fields: private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_0 3 methods: public void &lt;init&gt;() public static void main(String[] args) [(Unknown attribute org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 00 00 00 46)] static void &lt;clinit&gt;() ' is unknown and will therefore be ignored. Pass 2: Attribute '(Unknown attribute org.aspectj.weaver.WeaverState: 53 00 00 00 01 00 12 6d 79 70... (truncated))' as an attribute of the ClassFile structure 'public class mypackage.TestClass extends java.lang.Object filename mypackage.TestClass compiled from TestClass.java compiler version 46.0 access flags 33 constant pool 69 entries ACC_SUPER flag true Attribute(s): SourceFile(TestClass.java) (Unknown attribute org.aspectj.weaver.WeaverVersion: 00 03 00 00 00 00 00 00 00 00... (truncated)) (Unknown attribute org.aspectj.weaver.WeaverState: 53 00 00 00 01 00 12 6d 79 70... (truncated)) 1 fields: private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_0 3 methods: public void &lt;init&gt;() public static void main(String[] args) [(Unknown attribute org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 00 00 00 46)] static void &lt;clinit&gt;() ' is unknown and will therefore be ignored. Pass 2: Attribute '&lt;LocalVariableTable: LocalVariable(start_pc = 0, length = 5, index = 0:mypackage.TestClass this)&gt;' as an attribute of Code attribute '&lt;CODE&gt;' (method 'public void &lt;init&gt;()') will effectively be ignored and is only useful for debuggers and such. Pass 2: Attribute '&lt;LineNumberTable: LineNumber(0, 3)&gt;' as an attribute of Code attribute '&lt;CODE&gt;' (method 'public void &lt;init&gt;()') will effectively be ignored and is only useful for debuggers and such. Pass 2: Attribute '(Unknown attribute org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 00 00 00 46)' as an attribute of Method 'public static void main(String[] args) [(Unknown attribute org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 00 00 00 46)]' is unknown and will therefore be ignored. Pass 2: Attribute '(Unknown attribute org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 00 00 00 46)' as an attribute of Method 'public static void main(String[] args) [(Unknown attribute org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 00 00 00 46)]' is neither Code nor Exceptions and is therefore only of use for debuggers and such. Pass 2: Unknown attribute '(Unknown attribute org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 00 00 00 46)'. This attribute is not known in any context! Pass 2: Attribute '&lt;LocalVariableTable: LocalVariable(start_pc = 9, length = 0, index = 0:String[] args)&gt;' as an attribute of Code attribute '&lt;CODE&gt;' (method 'public static void main(String[] args) [(Unknown attribute org.aspectj.weaver.MethodDeclarationLineNumber: 00 00 00 05 00 00 00 46)]') will effectively be ignored and is only useful for debuggers and such. Pass 2: Attribute will effectively be ignored and is only useful for debuggers and such. Pass 2: Class or interface initialization method' has superfluous access modifier(s) set: everything but ACC_STRICT is ignored. Pass 2: Attribute as an attribute of Code attribute ' will effectively be ignored and is only useful for debuggers and such. Pass 2:  This attribute is not known in any context!
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.generateMethod(ClassFile, MethodBinding, List, BodyGenerator),True
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testVerificationFailureForAspectOf_pr148693(),False,test_method
verifyClass(String),False,test_method
getClassFrom(String frompath,String),False,test_method
tests/src/org/aspectj/testing/Utils.verifyClass(Ajc, String),False,new_method|test_method
getClassFrom(String frompath,String),False,new_method|test_method
createRepos(String),False,new_method|test_method
#####
AspectJ
148537
7b526ecf23dc03453f8f8adb3a25c67b0a7018b8
ClassCastException on private nested annotation with @Retention meta-annotation given an array-type value MyClass.java ============ public class MyClass { @Retention({RententionPolicy.RUNTIME}) private @interface MyAnnotation { } } --- MyAspect.aj =========== privileged public aspect MyAspect { declare @type : MyClass+ : @MyClass.MyAnnotation; } --- Internal Compiler Error: java.lang.ClassCastException at org.aspectj.org.eclipse.jdt.internal.compiler.ast.Annotation.detectStandardAnnotation(Annotation.java:99) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.Annotation.resolveType(Annotation.java:280) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:436) at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.getAnnotationTagBits(SourceTypeBinding.java:743) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.Annotation.resolveType(Annotation.java:331) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:436) at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.MethodBinding.getAnnotationTagBits(MethodBinding.java:450) at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.resolveTypesFor(SourceTypeBinding.java:1268) at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.methods(SourceTypeBinding.java:1081) at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.checkSpec(AspectDeclaration.java:131) at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTypeAndPerClause(AspectDeclaration.java:1070) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildInterTypeAndPerClause(AjLookupEnvironment.java:463) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.collectAllITDsAndDeclares(AjLookupEnvironment.java:332) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:173) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:862) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:242) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:161) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) ClassCastException thrown: org.aspectj.org.eclipse.jdt.internal.compiler.ast.ArrayInitializer
on private nested annotation with meta-annotation given an array-type value
******
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testIncorrectAnnotationValue_pr148537(),False,test_method
#####
AspectJ
148972
2f2f5683643a0f1e0856ac43fa590c4b39f1be26
problems with binary weaving declare parents in mixed environment. These have been reported to me on a large system doing some intricate weaving where some classes are 1.2, some 1.4, some 1.5 and the VM is 1.5. Binary weaving declare parents sometimes refuses to allow the modification of the hierarchy because it sees a clash between two methods when there is none. The two cases I'm fixing are: 1. sometimes the signatures of the return types differ with the '.' or '/' problem (fix == be consistent) 2. sometimes the syntheticness of the methods in the relationship isn't determined correctly
problems with binary weaving declare parents in mixed environment. These have been reported to me on a large system doing some intricate weaving where some classes are 1.2, some 1.4, some 1.5 and the VM is 1.5. Binary weaving declare parents sometimes refuses to allow the modification of the hierarchy because it sees a clash between two methods when there is none. The two cases I'm fixing are: 1. sometimes the signatures of the return types differ with the '.' or '/' 2. sometimes the syntheticness of the methods in the relationship isn't determined correctly
******
tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.testCovarianceAndDecp_pr128443_1(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.testSuperITDExplosion_pr134425(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.testMisbehavingDeclareAnnotation_pr135865_2(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.testCovarianceAndDecp_pr128443_1(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.testSuperITDExplosion_pr134425(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.testMisbehavingDeclareAnnotation_pr135865(),False,new_method|test_method
weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.mungeNewParent(BcelClassWeaver, NewParentTypeMunger),True
weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.enforceDecpRule4_compatibleReturnTypes(BcelClassWeaver, ResolvedMember, LazyMethodGen),True
#####
AspectJ
148737
f6834c7692082a20e94f7d88841e6c7c3f96c26a
IllegalStateException for non-generic type I believe this is similar to 112880. The message and stack trace I am getting are -- (IllegalStateException) Can't ask to parameterize a member of non-generic type: com...object kind(raw) Can't ask to parameterize a member of non-generic type: com...object kind(raw) java.lang.IllegalStateException: Can't ask to parameterize a member of non-generic type: com....object kind(raw) at org.aspectj.weaver.ResolvedMemberImpl.parameterizedWith(ResolvedMemberImpl.java:612) at org.aspectj.weaver.ResolvedMemberImpl.parameterizedWith(ResolvedMemberImpl.java:597) at org.aspectj.weaver.ReferenceType.getDeclaredMethods(ReferenceType.java:508) at org.aspectj.weaver.ResolvedType$4.get(ResolvedType.java:225) at org.aspectj.weaver.Iterators$3$1.hasNext(Iterators.java:118) at org.aspectj.weaver.Iterators$5.hasNext(Iterators.java:171) at org.aspectj.weaver.Iterators$3.hasNext(Iterators.java:128) at org.aspectj.weaver.ResolvedType.lookupMember(ResolvedType.java:345) at org.aspectj.weaver.ResolvedType.lookupMethod(ResolvedType.java:326) . . . The same code was able to be weaved under 1.5.0. The reason why this is a major issue is 1.5.0 suffers from a StackOverflowException
for non-generic type I believe this is similar to 112880. The message and stack trace I am getting are -- () Can't ask to parameterize a member of non-generic type: com...object kind(raw) Can't ask to parameterize a member of . . . The same code was able to be weaved under 1.5.0. The reason why this is a major issue is 1.5.0 suffers from a
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.parseOption(String, LinkedList),True
tests/bugs153/pr148737/A.A(),False,new_method|test_method
tests/bugs153/pr148737/A.setUniqueID(Object),False,new_method|test_method
tests/bugs153/pr148737/A.B(),False,new_method|test_method
tests/bugs153/pr148737/A.method(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testIllegalStateException_pr148737(),False,new_method|test_method
#####
AspectJ
148409
369de870280d4ae4f1e984a7bd8a76affb4ed0a2
[generics] ClassCastException in UnresolvedType.java:348 I am using AspectJ load time weaving with Spring 2.0 RC1 to inject my entities, and I am getting the following exception: java.lang.ClassCastException: org.aspectj.apache.bcel.classfile.Signature$TypeVariableSignature at org.aspectj.weaver.UnresolvedType.forGenericTypeSignature(UnresolvedType.java:348) at org.aspectj.weaver.bcel.BcelWorld.addSourceObjectType(BcelWorld.java:385) at org.aspectj.weaver.loadtime.ClassLoaderWeavingAdaptor.accept(ClassLoaderWeavingAdaptor.java:492) at org.aspectj.weaver.tools.WeavingAdaptor.shouldWeave(WeavingAdaptor.java:230) at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass(WeavingAdaptor.java:210) at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:65) at org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform(ClassPreProcessorAgentAdapter.java:55) at sun.instrument.TransformerManager.transform(TransformerManager.java:122) at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:155) at java.lang.ClassLoader.defineClass1(Native Method) . . . Having examined the call stack under the debugger, this seems to happening when the weaver is attempting to determine whether a particular class should be weaved. The exception is thrown in the following method, at the cast highlighted below. public static UnresolvedType forGenericTypeSignature(String sig,String declaredGenericSig) { UnresolvedType ret = UnresolvedType.forSignature(sig); ret.typeKind=TypeKind.GENERIC; ClassSignature csig = new GenericSignatureParser().parseAsClassSignature(declaredGenericSig); Signature.FormalTypeParameter[] ftps = csig.formalTypeParameters; ret.typeVariables = new TypeVariable[ftps.length]; for (int i = 0; i &lt; ftps.length; i++) { Signature.FormalTypeParameter parameter = ftps[i]; Signature.ClassTypeSignature cts = (Signature.ClassTypeSignature)parameter.classBound; // EXCEPTION HERE! ret.typeVariables[i]=new TypeVariable(ftps[i].identifier,UnresolvedType.forSignature(cts.outerType.identifier+";")); } ret.signatureErasure = sig; ret.signature = ret.signatureErasure; return ret; } The class in question (which is not one that requires weaving), has the following signature: public class HibernateEntityDAO&lt;interfaceT extends SecurityEntity, concreteT extends interfaceT&gt; extends HibernateDaoSupport implements EntityDAO&lt;interfaceT&gt; The exception is happening because the parameter.classBound member is not of type Signature.ClassTypeSignature, but an instance of Signature.TypeVariableSignature. The loop variable i is 1, and parameter.identifier is ?concreteT?, so it looks like it's the signature of the second type parameter (concreteT) that is tripping up the weaver.
[generics] I am using AspectJ load time weaving with Spring 2.0 RC1 to inject my entities, and I am getting the following exception: . . . Having examined the call stack under the debugger, this seems to happening when the weaver is attempting to determine whether a particular class should be weaved. The exception is thrown in the following method, at the cast highlighted below. The class in question (which is not one that requires weaving), has the following signature:  implements The exception is happening because the  member is not of type , but an instance of . The loop variable i is 1, and is ?concreteT?, so it looks like it's the signature of the second type parameter (concreteT) that is tripping up the weaver.
******
tests/bugs153/pr148409/Blurgh.m(B),False,new_method|test_method
main(String),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testVisibilityProblem_pr149071(),False,test_method
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testAdviceNotWovenAspectPath_pr147841(),False,test_method
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testGenericSignatures_pr148409(),False,new_method|test_method    
weaver/src/org/aspectj/weaver/UnresolvedType.forGenericTypeSignature(String , String),True
#####
AspectJ
149305
a6b36f2034e7af068ac368526a0ce042d4a1621c
[@AspectJ] Source file ordering dependency in @AspectJ aspects inheritance Compiling following code placed in different packages causes unexpected error. ====================================================== package com.codesrc.ozonator; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Pointcut; import com.codesrc.ozonator.identity.User; @Aspect public abstract class AbstractOzonator { @Pointcut("") protected abstract void readMethodExecution(); @Pointcut("readMethodExecution() &amp;&amp; this(ozonated)") private void ozonatedReadExecution(Object ozonated){}; @Around("ozonatedReadExecution(ozonated)") public Object aroundGetterCallNoRecurse( ProceedingJoinPoint thisJoinPoint, Object ozonated) throws Throwable { System.out.println("thisJoinPoint="+thisJoinPoint+", ozonated="+ozonated); return thisJoinPoint.proceed(); } } ------------------------------------------------------------- package com.codesrc.ozonator.identity; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Pointcut; import com.codesrc.ozonator.AbstractOzonator; @Aspect public class IdentityOzonator extends AbstractOzonator { @Pointcut("execution(public * com.codesrc.ozonator.identity.User+.get*(..)) ") protected void readMethodExecution() {} } ======================================================================== /home/kei/tmp/0/t3/src/com/codesrc/ozonator/identity/IdentityOzonator.java:1 [error] the parameter thisJoinPoint is not bound in [all branches of] pointcut (no source information available) If I place all code into one package, then the code is being compiled successfuly. This bag looks like Bug 125699, but I use aspectj-1.5.2.rc1.
Source file ordering dependency in aspects inheritance Compiling following code placed in different packages causes unexpected error. ======================================================================== [error] the parameter is not bound in [all branches of] pointcut (no source information available) If I place all code into one package, then the code is being compiled successfuly. This bag looks like Bug 125699, but I use
******
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testCFlowXMLAspectLTW_pr149096(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testAtajInheritance_pr149305_1(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testAtajInheritance_pr149305_2(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testAtajInheritance_pr149305_3(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testVerificationFailureForAspectOf_pr148693(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.verifyClass(String),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.getClassFrom(String, String),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.createRepos(String),False,new_method|test_method
weaver/src/org/aspectj/weaver/CrosscuttingMembers.replaceWith(CrosscuttingMembers, boolean),True
#####
AspectJ
150671
357bbe9eeb34748f7c8c2ff85049230db2adbbf2
declare error on set of volatile field does not work When an aspect has a declare error statement involving a pointcut that captures the setting of a volatile field, a compilation error is not produced. This bug can be reproduced as follows. Consider the following class: class A { private volatile int state; public void foo() { state = 0; } } Now consider this aspect: aspect FSM { declare error: set(* A.state): "Changing state"; } The setting of the state field in method foo() does not result in a compilation error as expected. I originally noticed this bug when using AJDT 1.4 with Eclipse 3.2. However this has been reproduced and confirmed with the aspectj 1.5.2 compiler.
declare error on set of volatile field does not work When an aspect has a declare error statement involving a pointcut that captures the setting of a volatile field, a compilation error is not produced. This bug can be reproduced as follows. Consider the following class: The setting of the state field in method does not result in a compilation error as expected. I originally noticed this bug when using AJDT 1.4 with Eclipse 3.2. However this has been reproduced and confirmed with the aspectj 1.5.2 compiler.
******
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testMatchVolatileField_pr150671(),False,new_method|test_method
weaver/src/org/aspectj/weaver/ResolvedMemberImpl.isBridgeMethod(),True
#####
AspectJ
151673
e4ab0ae5762be7d9869e0eee350677ac79749150
Incorrect weaving of after returning when 'input' bytecode is of a strange form We have had a user report a problem where after advice being woven into a particular method is producing code that does not verify. The problem occurs if the bytecode being input to the weaving process includes a subroutine that contains the return from the method. Here is the problematic snippet produced by some unknown compiler: 200: invokespecial #17; //Method com/MyException."&lt;init&gt;":(Ljava/lang/String;)V 203: athrow 204: aload_3 205: astore 6 207: jsr 234 210: aload 6 212: areturn 213: astore 4 215: aload 4 217: invokevirtual #79; //Method java/lang/Throwable.printStackTrace:()V 220: jsr 234 223: goto 238 226: astore 7 228: jsr 234 231: aload 7 233: athrow 234: astore 8 236: aload_3 237: areturn 238: return Exception table: from to target type 2 213 213 Class javax/ejb/FinderException 2 226 226 any see the jsr's jump to 234, but before the subroutine return at 238 there is an areturn out of the method (this method returns a String). After weaving we get something like this: 200: invokespecial #17; //Method com/MyException."&lt;init&gt;":(Ljava/lang/String;)V 203: athrow 204: aload_3 205: astore 6 207: jsr 238 210: aload 6 212: astore 9 214: goto 248 217: astore 4 219: aload 4 221: invokevirtual #79; //Method java/lang/Throwable.printStackTrace:()V 224: jsr 238 227: goto 246 230: astore 7 232: jsr 238 235: aload 7 237: athrow 238: astore 8 240: aload_3 241: astore 9 243: goto 248 246: astore 9 248: invokestatic #299; //Method After.aspectOf:()LAfter; 251: invokevirtual #302; //Method After.ajc$afterReturning$After$1$26d6d4a7:()V 254: aload 9 256: return see how the areturn has been lost - this code will blow up with a verify error (the string is on the stack, we just ignore it and 'return' normally)
Incorrect weaving of after returning when 'input' bytecode is of a strange form We have had a user report a problem where after advice being woven into a particular method is producing code that does not verify. The problem occurs if the bytecode being input to the weaving process includes a subroutine that contains the return from the method. Here is the problematic snippet produced by some unknown compiler: 200: invokespecial #17; //Method any see the jsr's jump to 234, but before the subroutine return at 238 there is an a return out of the method (this method returns a String). After weaving we get something like this: return see how the areturn has been lost - this code will blow up with a verify error (the string is on the stack, we just ignore it and 'return' normally)
******
weaver/src/org/aspectj/weaver/bcel/BcelShadow.generateReturnInstructions(List, InstructionList),True
#####
AspectJ
151845
54f7bb4f25792e717eadf21421c81ae1dc8e0718
NPE while building Building of a large project fails while weaving. NPE in EclipseSourceContext.removeUnnecessaryProblems(..) The project was just migrated to Eclipse 3.2 Eclipse newly installed with Eclipse SDK and via Update manager with AJDT, CDT, Web/J2EE tools, SubClipse, SpringIDE. Same Project workes in Eclipse 3.1. Simple Test AspectJ-Project workes OK Building with Ant/AspectJ compiler (as external Tools Launch in Eclipse) works. I tried the following, but got the error anyway: - Checked out as a new AspectJ Project - upgraded to the developement Version of AJDT
NPE while building Building of a large project fails while weaving. NPE in The project was just migrated to Eclipse 3.2 Eclipse newly installed with Eclipse SDK and via Update manager with AJDT, CDT, Web/J2EE tools, SubClipse, SpringIDE. Same Project workes in Eclipse 3.1. Simple Test AspectJ-Project workes OK Building with Ant/AspectJ compiler (as external Tools Launch in Eclipse) works. I tried the following, but got the error anyway: - Checked out as a new AspectJ Project - upgraded to the developement Version of AJDT
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseSourceContext.removeUnnecessaryProblems(Member, int),True
#####
AspectJ
152257
a3f3ae406d01081897b68c1344b4f23cbabaeed8
Incremental compiler doesn't handle exception declaration correctly Incrementally compiling code with advice throwing an excpetion gives errors stating that the exception can't be thrown. Full compilation compiles the code successfully. AJDT Version: 1.4.1 Build id: 20060727081607 AspectJ version: 1.5.3.20060726092219 Here is the minimum code the reproduce the behavior. // Main.java package test; import java.io.IOException; public class Main { public void testMethod() throws IOException { methodThatThrows(); } public static void methodThatThrows() throws IOException { System.out.println("Inside method that may throw an IOException"); } } // IOExceptionInjector.aj package test; import java.io.IOException; public aspect IOExceptionInjector { pointcut faultInjection() : call(void methodThatThrows() throws IOException); void around() throws IOException : faultInjection() { throw new IOException("Exception injected by aspect."); } } 1. Modify something in Main.java (add and delete a space, for example). 2. Save to compile incremetally. An error is issued for the call to methodThatThrows() stating "Severity and Description Path Resource Location Creation Time Id can't throw checked exception 'java.io.IOException' at this join point 'method-call(void test.Main.methodThatThrows())' IncrementalCompilerHandlingException/src/test Main.java line 7 1154196826350 7956 " Do a full rebuild and the error goes away.
Incremental compiler doesn't handle exception declaration correctly Incrementally compiling code with advice throwing an excpetion gives errors stating that the exception can't be thrown. Full compilation compiles the code successfully. AJDT Version: 1.4.1 Build id: 20060727081607 AspectJ version: 1.5.3.20060726092219 Here is the minimum code the reproduce the behavior. Modify something in(add and delete a space, for example). 2. Save to compile incremetally. An error is issued for the call to stating "Severity and Description Path Resource Location Creation Time Id can't throw checked exception '' at this join point 'line 7 1154196826350 7956 " Do a full rebuild and the error goes away.
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.afterCompiling(CompilationUnitDeclaration[]),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjPipeliningCompilerAdapter.afterCompiling(CompilationUnitDeclaration[]),True
tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.testPr152257(),False,test_method
weaver/src/org/aspectj/weaver/World.flush(),False,comments
#####
AspectJ
151938
bebb3640698bf2c465b64d9565123ec699dac45d
Handle Duplicate -javaagent entries more gracefully If you start a java 5 VM with AspectJ's load-time weaver specified more than once using the -javaagent flag, if there is an aop.xml file defined, it chokes badly: it tries to reweave the woven AspectJ code and emits massive amounts of bytecode. It would be better if AspectJ detected that it was specified more than once and gave a warning then disabled all but one of the agents. Failing that, it would be better to fail and give an error message than emit the bytecode. This issue came up for our automated installer, which adds a -javaagent flag to VM startup commands. If the script is wrapped twice, it can generate a duplicate. We are making our scripts more intelligent to avoid this issue, but we are probably not the only people who will hit this issue (e.g., if someone manually edits both setclasspath.bat and catalina.bat to add the flag for a Tomcat instance...)
Handle Duplicate entries more gracefully If you start a java 5 VM with AspectJ's weaver specified more than once using the  flag, if there is an file defined, it chokes badly: it tries to reweave the woven AspectJ code and emits massive amounts of bytecode. It would be better if AspectJ detected that it was specified more than once and gave a warning then disabled all but one of the agents. Failing that, it would be better to fail and give an error message than emit the bytecode. This issue came up for our automated installer, which adds a - flag to VM startup commands. If the script is wrapped twice, it can generate a duplicate. We are making our scripts more intelligent to avoid this issue, but we are probably not the only people who will hit this issue (e.g., if someone manually edits both and to add the flag for a Tomcat instance...)
******
loadtime5/java5-src/org/aspectj/weaver/loadtime/Agent.premain(String, Instrumentation),True
tests/java5/ataspectj/HelloWorld.main(String[]),False,new_method|test_method
tests/java5/ataspectj/MessageHandler.handleMessage(IMessage),False,new_method|test_method
tests/java5/ataspectj/MessageHandler.isIgnoring(IMessage.Kind),False,new_method|test_method
tests/java5/ataspectj/MessageHandler.dontIgnore(IMessage.Kind),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testDuplicateJVMTIAgents_pr151938(),False,new_method|test_method
#####
AspectJ
152388
a38edd39a8e998a22b41a0cf1928493aa0755e65
NPE in MessageUtil.addExtraSourceLocations I get this message from an error in a recent dev build of AspectJ with load-time weaving. I don't know how there is a null source location associated with this message, but either it shouldn't be there or MessageUtil line 806 should use this patch: Index: src/org/aspectj/bridge/MessageUtil.java =================================================================== RCS file: /home/technology/bridge/src/org/aspectj/bridge/MessageUtil.java,v retrieving revision 1.11 diff -u -r1.11 MessageUtil.java --- src/org/aspectj/bridge/MessageUtil.java 1 Jun 2006 09:36:37 -0000 1.11 +++ src/org/aspectj/bridge/MessageUtil.java 31 Jul 2006 22:32:16 -0000 @@ -803,7 +803,7 @@ writer.println(baseMessage); for (Iterator iter = message.getExtraSourceLocations().iterator(); iter.hasNext();) { ISourceLocation element = (ISourceLocation) iter.next(); - writer.print("\tsee also: " + element.toString()); + writer.print("\tsee also: " + element); if (iter.hasNext()) { writer.println(); } NPE follows: java.lang.NullPointerException at org.aspectj.bridge.MessageUtil.addExtraSourceLocations(MessageUtil.java:806) at org.aspectj.bridge.MessageUtil.renderMessage(MessageUtil.java:793) at org.aspectj.bridge.Message.toString(Message.java:177) at org.aspectj.bridge.MessageWriter.render(MessageWriter.java:73) at org.aspectj.weaver.tools.WeavingAdaptor$WeavingAdaptorMessageHandler.render(WeavingAdaptor.java:471) at org.aspectj.bridge.MessageWriter.handleMessage(MessageWriter.java:41) at org.aspectj.weaver.tools.WeavingAdaptor$WeavingAdaptorMessageHandler.handleMessage(WeavingAdaptor.java:425) at org.aspectj.weaver.bcel.BcelTypeMunger.error(BcelTypeMunger.java:378) at org.aspectj.weaver.bcel.BcelTypeMunger.enforceDecpRule1_abstractMethodsImplemented(BcelTypeMunger.java:273) at org.aspectj.weaver.bcel.BcelTypeMunger.mungeNewParent(BcelTypeMunger.java:194) at org.aspectj.weaver.bcel.BcelTypeMunger.munge(BcelTypeMunger.java:106) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:450) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:115) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1613) at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1564) at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1341) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1163) at org.aspectj.weaver.tools.WeavingAdaptor.getWovenBytes(WeavingAdaptor.java:288) at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass(WeavingAdaptor.java:214) at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:76) at org.aspectj.ext.ltw13.ClassPreProcessorAdapter.preProcess(ClassPreProcessorAdapter.java:65) at org.codehaus.aspectwerkz.hook.impl.ClassPreProcessorHelper.defineClass0Pre(ClassPreProcessorHelper.java:107) at java.lang.ClassLoader.defineClass(ClassLoader.java:539) ... NOTE: I'm using Alex Vasseur's adaptor to invoke AspectJ LTW from a 1.4 VM, but with recursion protection added. I don't think that should change the expected behavior of Aj.
NPE in I get this message from an error in a recent dev build of AspectJ with load-time weaving. I don't know how there is a null source location associated with this message, but either it shouldn't be there or line 806 should use this patch: NOTE: I'm using Alex Vasseur's adaptor to invoke AspectJ LTW from a 1.4 VM, but with recursion protection added. I don't think that should change the expected behavior of Aj.
******
bridge/src/org/aspectj/bridge/MessageUtil.addExtraSourceLocations(IMessage, String),True
#####
AspectJ
152631
ff2377a7f3b3d2148d107a7c411cf8308d254136
Problem with decp on an aspect using cflow This occurs in the AspectJ build in AJDT from August 1 but not from July 31: java.lang.NullPointerException at org.aspectj.weaver.bcel.BcelTypeMunger.enforceDecpRule1_abstractMethodsImplemented(BcelTypeMunger.java:250) at org.aspectj.weaver.bcel.BcelTypeMunger.mungeNewParent(BcelTypeMunger.java:194) at org.aspectj.weaver.bcel.BcelTypeMunger.munge(BcelTypeMunger.java:106) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:454) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:119) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1597) at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1548) at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1328) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1124) at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.weaveQueuedEntries(AjPipeliningCompilerAdapter.java:451) at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.queueForWeaving(AjPipeliningCompilerAdapter.java:389) at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.afterProcessing(AjPipeliningCompilerAdapter.java:377) at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$after$org_aspectj_ajdt_internal_compiler_CompilerAdapter$5$6b855184(CompilerAdapter.aj:98) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:533) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:891) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:246) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:165) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) trouble in:public class glassbox.agent.ErrorContainmentTest$ErrorMockAspect extends java.lang.Object implements glassbox.agent.api.NotSerializable: private static Throwable ajc$initFailureCause [Synthetic] public static final glassbox.agent.ErrorContainmentTest$ErrorMockAspect ajc$perSingletonInstance [Synthetic] static void &lt;clinit&gt;(): catch java.lang.Throwable -&gt; E0 | INVOKESTATIC glassbox.agent.ErrorContainmentTest$ErrorMockAspect.ajc$postClinit ()V (line 60) catch java.lang.Throwable -&gt; E0 GOTO L0 E0: ASTORE_0 ALOAD_0 PUTSTATIC glassbox.agent.ErrorContainmentTest$ErrorMockAspect.ajc$initFailureCause Ljava/lang/Throwable; L0: RETURN end static void &lt;clinit&gt;() void &lt;init&gt;(): ALOAD_0 // Lglassbox/agent/ErrorContainmentTest$ErrorMockAspect; this (line 60) INVOKESPECIAL java.lang.Object.&lt;init&gt; ()V RETURN end void &lt;init&gt;() public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$1$9589fc() AdviceAttribute(before, (scope() &amp;&amp; call(* hook1())), 0, 1670) : NEW java.lang.RuntimeException (line 64) DUP LDC "rte" INVOKESPECIAL java.lang.RuntimeException.&lt;init&gt; (Ljava/lang/String;)V ATHROW end public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$1$9589fc() public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$2$f75db3e2() AdviceAttribute(before, execution(* glassbox.agent.ErrorContainmentTest.hook5()), 0, 1764) : NEW java.lang.RuntimeException (line 67) DUP LDC "rte" INVOKESPECIAL java.lang.RuntimeException.&lt;init&gt; (Ljava/lang/String;)V ATHROW end public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$2$f75db3e2() public void ajc$around$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$3$a3a17d(org.aspectj.runtime.internal.AroundClosure) AdviceAttribute(around, (scope() &amp;&amp; call(* hook2())), 1, 1913) : NEW java.lang.Error (line 71) DUP LDC "foo" INVOKESPECIAL java.lang.Error.&lt;init&gt; (Ljava/lang/String;)V ATHROW end public void ajc$around$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$3$a3a17d(org.aspectj.runtime.internal.AroundClosure) static void ajc$around$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$3$a3a17dproceed(org.aspectj.runtime.internal.AroundClosure) throws java.lang.Throwable org.aspectj.weaver.AjAttribute$AjSynthetic@19a01f9 : ALOAD_0 // Lglassbox/agent/ErrorContainmentTest$ErrorMockAspect; this (line 1) ICONST_0 ANEWARRAY java.lang.Object INVOKEVIRTUAL org.aspectj.runtime.internal.AroundClosure.run ([Ljava/lang/Object;)Ljava/lang/Object; INVOKESTATIC org.aspectj.runtime.internal.Conversions.voidValue (Ljava/lang/Object;)Ljava/lang/Object; RETURN end static void ajc$around$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$3$a3a17dproceed(org.aspectj.runtime.internal.AroundClosure) throws java.lang.Throwable public void ajc$after$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$4$bfd07f() AdviceAttribute(after, (scope() &amp;&amp; call(* hook4())), 0, 1991) : NEW org.aspectj.lang.SoftException (line 74) DUP ACONST_NULL INVOKESPECIAL org.aspectj.lang.SoftException.&lt;init&gt; (Ljava/lang/Throwable;)V ATHROW end public void ajc$after$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$4$bfd07f() public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$5$e5bddfdc() AdviceAttribute(before, logErrorInTest(), 0, 2446) : GETSTATIC glassbox.agent.ErrorContainmentTest.logCount I (line 84) ICONST_1 IADD PUTSTATIC glassbox.agent.ErrorContainmentTest.logCount I RETURN (line 85) end public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$5$e5bddfdc() public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$6$16ecfe62() AdviceAttribute(before, (adviceexecution(* *) &amp;&amp; (within(glassbox.util.logging.api.LogManagement) &amp;&amp; (cflow(logError()) &amp;&amp; cflow((execution(* testLoggingError(..)) &amp;&amp; within(glassbox.agent.ErrorContainmentTest)))))), 0, 2506) : GETSTATIC java.lang.System.err Ljava/io/PrintStream; (line 87) LDC "match" INVOKEVIRTUAL java.io.PrintStream.println (Ljava/lang/String;)V RETURN (line 88) end public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$6$16ecfe62() public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$7$e9ae8482() AdviceAttribute(before, (adviceexecution(* *) &amp;&amp; (within(glassbox.util.logging.api.LogManagement) &amp;&amp; cflow((execution(* testLoggingError(..)) &amp;&amp; within(glassbox.agent.ErrorContainmentTest))))), 0, 2721) : GETSTATIC java.lang.System.err Ljava/io/PrintStream; (line 90) LDC "match in test" INVOKEVIRTUAL java.io.PrintStream.println (Ljava/lang/String;)V RETURN (line 91) end public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$7$e9ae8482() public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$8$c6ac5351() AdviceAttribute(before, (adviceexecution(* *) &amp;&amp; (within(glassbox.util.logging.api.LogManagement) &amp;&amp; cflow(logError()))), 0, 2923) : GETSTATIC java.lang.System.err Ljava/io/PrintStream; (line 93) LDC "match in log" INVOKEVIRTUAL java.io.PrintStream.println (Ljava/lang/String;)V RETURN (line 94) end public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$8$c6ac5351() public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$9$16ecfe62() AdviceAttribute(before, (adviceexecution(* *) &amp;&amp; (within(glassbox.util.logging.api.LogManagement) &amp;&amp; (cflow(logError()) &amp;&amp; cflow((execution(* testLoggingError(..)) &amp;&amp; within(glassbox.agent.ErrorContainmentTest)))))), 0, 3069) : GETSTATIC glassbox.agent.ErrorContainmentTest.recursiveThrows I (line 96) ICONST_1 IADD PUTSTATIC glassbox.agent.ErrorContainmentTest.recursiveThrows I GETSTATIC glassbox.agent.ErrorContainmentTest.recursiveThrows I (line 97) ICONST_2 IF_ICMPGE L0 NEW java.lang.RuntimeException (line 98) DUP LDC "recursive logging failure" INVOKESPECIAL java.lang.RuntimeException.&lt;init&gt; (Ljava/lang/String;)V ATHROW L0: RETURN (line 100) end public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$9$16ecfe62() public static glassbox.agent.ErrorContainmentTest$ErrorMockAspect aspectOf() org.aspectj.weaver.AjAttribute$AjSynthetic@3cd8fe : GETSTATIC glassbox.agent.ErrorContainmentTest$ErrorMockAspect.ajc$perSingletonInstance Lglassbox/agent/ErrorContainmentTest$ErrorMockAspect; (line 1) IFNONNULL L0 NEW org.aspectj.lang.NoAspectBoundException DUP LDC "glassbox_agent_ErrorContainmentTest$ErrorMockAspect" GETSTATIC glassbox.agent.ErrorContainmentTest$ErrorMockAspect.ajc$initFailureCause Ljava/lang/Throwable; INVOKESPECIAL org.aspectj.lang.NoAspectBoundException.&lt;init&gt; (Ljava/lang/String;Ljava/lang/Throwable;)V ATHROW L0: GETSTATIC glassbox.agent.ErrorContainmentTest$ErrorMockAspect.ajc$perSingletonInstance Lglassbox/agent/ErrorContainmentTest$ErrorMockAspect; ARETURN end public static glassbox.agent.ErrorContainmentTest$ErrorMockAspect aspectOf() public static boolean hasAspect() org.aspectj.weaver.AjAttribute$AjSynthetic@1bd4f6 : GETSTATIC glassbox.agent.ErrorContainmentTest$ErrorMockAspect.ajc$perSingletonInstance Lglassbox/agent/ErrorContainmentTest$ErrorMockAspect; (line 1) IFNULL L0 ICONST_1 IRETURN L0: ICONST_0 IRETURN end public static boolean hasAspect() private static void ajc$postClinit() org.aspectj.weaver.AjAttribute$AjSynthetic@1febf91 : NEW glassbox.agent.ErrorContainmentTest$ErrorMockAspect (line 1) DUP INVOKESPECIAL glassbox.agent.ErrorContainmentTest$ErrorMockAspect.&lt;init&gt; ()V PUTSTATIC glassbox.agent.ErrorContainmentTest$ErrorMockAspect.ajc$perSingletonInstance Lglassbox/agent/ErrorContainmentTest$ErrorMockAspect; RETURN end private static void ajc$postClinit() end public class glassbox.agent.ErrorContainmentTest$ErrorMockAspect when type munging with (BcelTypeMunger ResolvedTypeMunger(Parent, null)) when weaving aspects when weaving when batch building BuildConfig[C:\devel\glassbox\.metadata\.plugins\org.eclipse.ajdt.core\glassboxMonitor.generated.lst] #Files=107 The source is: public class ErrorContainmentTest extends TestCase { ... static aspect ErrorMockAspect implements NotSerializable { ... I will try to narrow this down if the problem isn't obvious.
Problem with decp on an aspect using cflow This occurs in the AspectJ build in AJDT from August 1 but not from July 31 I will try to narrow this down if the problem isn't obvious.
******
tests/bugs153/pr152631/EMA.m(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testDecpAndCflowadderMungerClash_pr152631(),False,new_method|test_method
weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.enforceDecpRule1_abstractMethodsImplemented(BcelClassWeaver, ISourceLocation,LazyClassGen, ResolvedType),True
#####
AspectJ
152871
c779c96eff482f8b99fe5d7f85505f1792780281
Parse bytecode at most once when weaving: 10% CPU time reduction I'm analyzing a profile of cpu times spent weaving into Weblogic 9.2 with LTW. Of a total of 22 seconds of CPU, 2.6 seconds are spent in ClassParser.parse() with the exact same amount spent underneath WeavingAdaptor.shouldWeave and WeavingAdaptor.shouldWeaveAnnotationStyleAspect WeavingAdaptor.shouldWeave is calling CLWA.accept which calls Utility.makeJavaClass which calls ClassParser.parse. Then the exact same expensive operation is getting called again in shouldWeaveAnnotationStyleAspect via BcelWorld.isAnnotationStyleAspect. Proposed Simple fix: allow shouldWeave to also return a BcelObjectType by setting a field in the adapter (which would be cleared to be null on start). The in shouldWeaveAnnotationStyleAspect, check the field. I'd be glad to write and test a patch to do this if the committers agree with the proposal. We wouldn't want to always parse the bytecode, because it would we should be aiming to avoid that expense as often as possible. In our case, we're using exclusion type patterns that currently require accept to make a Java class. In cases where that's not necessary, it also seems odd that shouldWeaveAnnotationStyleAspect runs at all: I will post a separate enhancement request for limiting the cases where it runs.
Parse bytecode at most once when weaving: 10% CPU time reduction I'm analyzing a profile of cpu times spent weaving into Weblogic 9.2 with LTW. Of a total of 22 seconds of CPU, 2.6 seconds are spent in with the exact same amount spent underneath which calls. Then the exact same expensive operation is getting called again in via . Proposed Simple fix: allow to also return a by setting a field in the adapter (which would be cleared to be null on start). The in , check the field. I'd be glad to write and test a patch to do this if the committers agree with the proposal. We wouldn't want to always parse the bytecode, because it would we should be aiming to avoid that expense as often as possible. In our case, we're using exclusion type patterns that currently require accept to make a Java class. In cases where that's not necessary, it also seems odd that runs at all: I will post a separate enhancement request for limiting the cases where it runs.
******
loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.acceptAspect(String),False,comments
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testParsingBytecodeLess_pr152871(),False,new_method|test_method
weaver/src/org/aspectj/weaver/bcel/UnwovenClassFile.UnwovenClassFile(String, String, byte[]),False,new_method
weaver/src/org/aspectj/weaver/bcel/Utility.makeJavaClass(String, byte[]),True
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.weaveClass(String, byte[]),True
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.shouldWeaveName(String),True
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.shouldWeaveAnnotationStyleAspect(String, byte[]),True
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.ensureDelegateInitialized(String, byte[]),False,new_method|test_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.WeavingClassFileProvider(String, byte[]),True
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.weaveCompleted(),True
#####
AspectJ
152873
f239f2a2ac6a887fd46e6d95e8fb4ec93e2e159d
Optimize shouldWeaveAnnotationStyleAspect with Patch The current implementation of shouldWeaveAnnotationStyleAspect is surprising because it weaves annotation aspects without regard as to whether they are registered in an aop.xml file. If an annotation-style aspect is loaded, it is always woven, even if it doesn't match the for what classes should be woven in the aop.xml file, and even if not registered therein. This is both unexpected and it imposes significant overhead on configurations where they aren't used and simple fast match exclusions prevent weaving (see bug #152871). Is there really a need to weave annotation style aspects like this? Why can't it be done by using the aop.xml configuration mechanism that all other aspects use? In a large system, the CPU overhead of parsing and creating BCEL objects for all loaded classes should be avoided where possible.
Optimize with Patch The current implementation of is surprising because it weaves annotation aspects without regard as to whether they are registered in an file. If an annotation-style aspect is loaded, it is always woven, even if it doesn't match the for what classes should be woven in the file, and even if not registered therein. This is both unexpected and it imposes significant overhead on configurations where they aren't used and simple fast match exclusions prevent weaving (see bug #152871). Is there really a need to weave annotation style aspects like this? Why can't it be done by using the configuration mechanism that all other aspects use? In a large system, the CPU overhead of parsing and creating BCEL objects for all loaded classes should be avoided where possible.
******
testing/newsrc/org/aspectj/testing/AntSpec,False,test
tests/java5/ataspectj/ataspectj/bugs/NotAspect.main(String),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.testAspectOfWhenAspectExcluded_pr152873(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.testAspectOfWhenNonAspectExcluded_pr152873(),False,new_method|test_method
weaver/src/org/aspectj/weaver/World.isASMAround(),True
weaver/src/org/aspectj/weaver/tools/IsAtAspectAnnotationVisitor.visitAnnotation(String, boolean),False,new_method
weaver/src/org/aspectj/weaver/tools/IsAtAspectAnnotationVisitor.visitField(int, String, String, String, Object),False,new_method
weaver/src/org/aspectj/weaver/tools/IsAtAspectAnnotationVisitor.visitMethod(int, String, String, String, String[]),False,new_method
weaver/src/org/aspectj/weaver/tools/IsAtAspectAnnotationVisitor.isAspect(),False,new_method
weaver/src/org/aspectj/weaver/tools/IsAtAspectAnnotationVisitor.visit(int, int, String, String, String, String[]),False,new_method
weaver/src/org/aspectj/weaver/tools/IsAtAspectAnnotationVisitor.visitSource(String, String),False,new_method
weaver/src/org/aspectj/weaver/tools/IsAtAspectAnnotationVisitor.visitOuterClass(String, String, String),False,new_method
weaver/src/org/aspectj/weaver/tools/IsAtAspectAnnotationVisitor.visitAttribute(Attribute),False,new_method
weaver/src/org/aspectj/weaver/tools/IsAtAspectAnnotationVisitor.visitInnerClass(String, String, String, int)),False,new_method
weaver/src/org/aspectj/weaver/tools/IsAtAspectAnnotationVisitor.visitEnd(),False,new_method
weaver/src/org/aspectj/weaver/tools/IsAtAspectAnnotationVisitor.AnnotationVisitor visitAnnotationDefault(),False,new_method
weaver/src/org/aspectj/weaver/tools/IsAtAspectAnnotationVisitor.visitParameterAnnotation(int, String, boolean),False,new_method
weaver/src/org/aspectj/weaver/tools/IsAtAspectAnnotationVisitor.visitCode()),False,new_method
weaver/src/org/aspectj/weaver/tools/IsAtAspectAnnotationVisitor.visitInsn(int),False,new_method
weaver/src/org/aspectj/weaver/tools/IsAtAspectAnnotationVisitor.visitIntInsn(int, int),False,new_method
weaver/src/org/aspectj/weaver/tools/IsAtAspectAnnotationVisitor.visitVarInsn(int, int),False,new_method
weaver/src/org/aspectj/weaver/tools/IsAtAspectAnnotationVisitor.visitTypeInsn(int, String),False,new_method
weaver/src/org/aspectj/weaver/tools/IsAtAspectAnnotationVisitor.visitFieldInsn(int, String, String, String),False,new_method
weaver/src/org/aspectj/weaver/tools/IsAtAspectAnnotationVisitor.visitMethodInsn(int, String, String, String),False,new_method
weaver/src/org/aspectj/weaver/tools/IsAtAspectAnnotationVisitor.visitJumpInsn(int, Label),False,new_method
weaver/src/org/aspectj/weaver/tools/IsAtAspectAnnotationVisitor.visitLabel(Label),False,new_method
weaver/src/org/aspectj/weaver/tools/IsAtAspectAnnotationVisitor.visitLdcInsn(Object),False,new_method
weaver/src/org/aspectj/weaver/tools/IsAtAspectAnnotationVisitor.visitIincInsn(int, int),False,new_method
weaver/src/org/aspectj/weaver/tools/IsAtAspectAnnotationVisitor.visitTableSwitchInsn(int, int, Label, Label),False,new_method
weaver/src/org/aspectj/weaver/tools/IsAtAspectAnnotationVisitor.visitLookupSwitchInsn(Label, int, Label),False,new_method
weaver/src/org/aspectj/weaver/tools/IsAtAspectAnnotationVisitor.visitMultiANewArrayInsn(String, int),False,new_method
weaver/src/org/aspectj/weaver/tools/IsAtAspectAnnotationVisitor.visitTryCatchBlock(Label, Label, Label, String),False,new_method
weaver/src/org/aspectj/weaver/tools/IsAtAspectAnnotationVisitor.visitLocalVariable(String, String, String, Label, Label, int),False,new_method
weaver/src/org/aspectj/weaver/tools/IsAtAspectAnnotationVisitor.visitLineNumber(int, Label),False,new_method
weaver/src/org/aspectj/weaver/tools/IsAtAspectAnnotationVisitor.visitMaxs(int, int),False,new_method
weaver/src/org/aspectj/weaver/tools/IsAtAspectAnnotationVisitor.visit(String, Object),False,new_method
weaver/src/org/aspectj/weaver/tools/IsAtAspectAnnotationVisitor.visitEnum(String, String desc, String),False,new_method
weaver/src/org/aspectj/weaver/tools/IsAtAspectAnnotationVisitor.visitAnnotation(String, String),False,new_method
weaver/src/org/aspectj/weaver/tools/IsAtAspectAnnotationVisitor.visitArray(String),False,new_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.weaveClass (String name, byte[]),True
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.shouldWeave(String name, byte[]),True
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.couldWeave(String name, byte[]),False,new_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.shouldWeaveAnnotationStyleAspect(String name, byte[]),True
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.asmCheckAnnotationStyleAspect(byte[]),False,new_method
#####
AspectJ
152589
9664058bcdaeb4934a01969f4e5f651bc6e8cd71
[pipeline] adding a whitespace results in adviceDidNotMatch warning< Given the following ------------------------------------------------------------ public aspect A { after () throwing (Throwable th) : execution(* *(..)) { System.err.println(thisEnclosingJoinPointStaticPart); } } class C1 { public void anotherMethod() { } } -------------------------------------------------- adding a whitespace before the aspect declaration results in an adviceDidNotMatch warning even though weaving took place and the advice clearly matches. Output from the AJDT event trace shows: 14:38:23 =========================================================================================== 14:38:23 Build kind = AUTOBUILD 14:38:23 Project=bug92895, kind of build requested=Incremental AspectJ compilation 14:38:23 build: Examined delta - source file changes in required project bug92895 14:38:23 Classpath=/home/hawkinsh/eclipse/workspace32/runtime-New_configuration/bug92895/bin:/home/hawkinsh/javas/jdk1.5.0_05/jre/lib/rt.jar:/home/hawkinsh/javas/jdk1.5.0_05/jre/lib/jsse.jar:/home/hawkinsh/javas/jdk1.5.0_05/jre/lib/jce.jar:/home/hawkinsh/javas/jdk1.5.0_05/jre/lib/charsets.jar:/home/hawkinsh/javas/jdk1.5.0_05/jre/lib/ext/sunjce_provider.jar:/home/hawkinsh/javas/jdk1.5.0_05/jre/lib/ext/sunpkcs11.jar:/home/hawkinsh/javas/jdk1.5.0_05/jre/lib/ext/dnsns.jar:/home/hawkinsh/javas/jdk1.5.0_05/jre/lib/ext/localedata.jar:/home/hawkinsh/eclipse/eclipse32/plugins/org.aspectj.runtime_1.5.3.20060801095103/aspectjrt.jar: 14:38:23 Preparing for build: planning to be an incremental build 14:38:23 Starting incremental compilation loop 1 of possibly 5 14:38:23 AJC: compiling source files 14:38:23 Timer event: 215ms: Time to first compiled message 14:38:23 AJC: compiled: /home/hawkinsh/eclipse/workspace32/runtime-New_configuration/bug92895/src/pack/A.aj 14:38:23 addSourcelineTask message=advice defined in pack.A has not been applied [Xlint:adviceDidNotMatch] file=/home/hawkinsh/eclipse/workspace32/runtime-New_configuration/bug92895/src/pack/A.aj line=4 14:38:23 Dropping back to full build 14:38:23 Preparing for build: not going to be incremental because no successful previous full build 14:38:23 AJC: compiling source files 14:38:23 AJC: compiled: /home/hawkinsh/eclipse/workspace32/runtime-New_configuration/bug92895/src/pack/A.aj 14:38:23 AJC: processing reweavable state 14:38:23 AJC: adding type mungers 14:38:23 Timer event: 452ms: Time to first woven message 14:38:23 AJC: woven aspect pack.A (from /home/hawkinsh/eclipse/workspace32/runtime-New_configuration/bug92895/src/pack/A.aj) 14:38:23 AJC: woven class pack.C1 (from /home/hawkinsh/eclipse/workspace32/runtime-New_configuration/bug92895/src/pack/A.aj) 14:38:23 AspectJ reports build successful, build was: FULL 14:38:23 AJDE Callback: finish. Was full build: true 14:38:23 Timer event: 517ms: Total time spent in AJDE 14:38:23 Timer event: 6ms: Create element map (2 rels in project: bug92895) 14:38:23 Types affected during build = 1 14:38:23 Timer event: 3ms: Add markers (2 markers) 14:38:24 Timer event: 1274ms: Total time spent in AJBuilder.build() namely, the adviceDidNotMatch warning was added and then we fell back to a full build and the warning wasn't cleared. Performing a "clean" build fixes the problem. This is since the pipelining changes.
[pipeline] adding a whitespace results in warning< Given the following ------------------------------------------------------------ -------------------------------------------------- adding a whitespace before the aspect declaration results in an warning even though weaving took place and the advice clearly matches. Output from the AJDT event trace shows:, kind of build requested=Incremental AspectJ compilation 14:38:23 build: Examined delta - source file changes in required project Preparing for build: planning to be an incremental build Starting incremental compilation loop 1 of possibly 5 compiling source files  Timer event: Time to first compiled message e defined in has not been applied Dropping back to full build 14:38:23 Preparing for build: not going to be incremental because no successful previous full build 14:38:23 AJC: compiling source files 14:38:23 AJC: compiled: 14:38:23 AJC: processing reweavable state 14:38:23 AJC: adding type mungers 14:38:23 Timer event: 452ms: Time to first woven message 14:38:23 AJC: woven aspect 14:38:23 AspectJ reports build successful, build was: FULL 14:38:23 AJDE Callback: finish. Was full build: true 14:38:23 Timer event: 517ms: Total time spent in AJDE 14:38:23 Timer event: 6ms: Create element map (2 rels in project: bug92895) 14:38:23 Types affected during build = 1 14:38:23 Timer event: 3ms: Add markers (2 markers) 14:38:24 Timer event: 1274ms: Total time spent in namely, the  warning was added and then we fell back to a full build and the warning wasn't cleared. Performing a "clean" build fixes the problem. This is since the pipelining changes.
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjPipeliningCompilerAdapter.beforeCompiling(ICompilationUnit[]),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjPipeliningCompilerAdapter.afterCompiling(CompilationUnitDeclaration[]),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjPipeliningCompilerAdapter.queueForWeaving(InterimCompilationResult ),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjPipeliningCompilerAdapter.weaveQueuedEntries(),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjPipeliningCompilerAdapter.postWeave(),True
tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.testAdviceDidNotMatch_pr152589(),False,new_method|test_method
#####
AspectJ
130300
b2259116b8731725743d255a85c894d6f998afb1
"Remove, hide or obfuscate -XnoWeave" This option is redundant apart from use in AspectJ development and maintenance. It is confusing to users and is a source new problems for LTW.
"Remove, hide or obfuscate -XnoWeave" This option is redundant apart from use in AspectJ development and maintenance. It is confusing to users and is a source new problems for LTW.
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/core/AspectJCore,True
ajde/testsrc/org/aspectj/ajde/BuildConfigurationTests.testNonStandardOptions(),False,test_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.parseOption(String arg, LinkedList),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.AjCompilerAdapter(Compiler, boolean, BcelWorld, BcelWeaver, EclipseFactory, IIntermediateResultsRequestor, IProgressListener, IOutputClassFileNameProvider, IBinarySourceProvider, Map, boolean, boolean, boolean, AjState),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.afterCompiling(CompilationUnitDeclaration[]),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.afterProcessing(CompilationUnitDeclaration, int),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.installGlobals(AjBuildConfig),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.isNoWeave(),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.isTerminateAfterCompilation(),False,new_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.setNoWeave(boolean),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.setTerminateAfterCompilation(boolean),False,new_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.getAdapter(org.aspectj.org.eclipse.jdt.internal.compiler.Compiler),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.getMap(),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.set(Map),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.toString(),True
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.makeJar1a(),True
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjCompilerOptionsTest.testDefaultValues(),False,test_method
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjCompilerOptionsTest.testDirectSet(),False,test_method
taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.setXNoweave(boolean noweave),True
taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.setXTerminateAfterCompilation(boolean),False,new_method
taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.setNoWeave(boolean),False,new_method
taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.readArguments(String[]),True
taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.testDefaultFileComplete(),False,test_method
testing/src/org/aspectj/testing/harness/bridge/CompilerRun.CRSOptions(),False,test_method
tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.testIllegalAccessErrorWithAroundAdviceTerminateAfterCompilationLTW_pr119657(),False,test_method|new_method
tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.testIllegalAccessErrorWithAroundAdviceNoWeaveLTW_pr119657(),False,test_method
tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.testAjcLTWPerClauseTest_XnoWeave(),False,test_method
tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.testAjcLTWPerClauseTest_XterminateAfterCompilation(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.testAjcLTWAroundInlineMungerTest_XnoWeave(),False,test_method
tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.testAjcLTWAroundInlineMungerTest_XterminateAfterCompilation(),False,new_method|test_method
tests/src/org/aspectj/systemtest/inpath/InPathTests.test004(),False,test_method
#####
AspectJ
154332
59123b0efba484e81625d403ca36768e149bd451
[annotations] Incorrect handling of java.lang annotations when matching As raised by Mr Bodkin on the list: Can anyone tell me why this compiling this program produces warnings for marker but not for deprecated (in a recent dev build of AJDT)? Is this just a bug? Both have runtime retention, so I would expect equivalent behavior. @Deprecated @Marker public aspect Annot { pointcut test() : within(@Marker *);// *); declare warning: staticinitialization(@Deprecated *): "deprecated"; declare warning: staticinitialization(@Marker *): "marker"; public static void main(String argz[]) { new Baz().foo(); } } @Deprecated @Marker class Baz { public void foo() {} } @Retention(RetentionPolicy.RUNTIME) public @interface Marker { }
[annotations] Incorrect handling of annotations when matching As raised by Mr Bodkin on the list: Can anyone tell me why this compiling this program produces warnings for marker but not for deprecated (in a recent dev build of AJDT)? Is this just a bug? Both have runtime retention, so I would expect equivalent behavior. 
******
tests/bugs153/pr154332/Annot.main(String),False,new_method|test_method
tests/bugs153/pr154332/Annot.foo(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testIncorrectDeprecatedAnnotationProcessing_pr154332(),False,new_method|test_method
weaver/src/org/aspectj/weaver/bcel/BcelObjectType.ensureAnnotationsUnpacked(),True
#####
AspectJ
153535
82e3e13c66720ed17399821d478c31151b2d2234
Bug in reflection delegate signature for array of object type The following problem is interesting because the advice weaves correctly with Java 1.5 LTW and also using Java 1.4 with build-time weaving. However, the following call pointcut isn't matching the expected call site in Java 1.4 load-time weaving (*). Pointcut: private pointcut inExecQuery() : (within(uk.ltd.getahead.dwr.impl.ExecuteQuery) || within(uk.ltd.getahead.dwr.ExecuteQuery)); public pointcut dwrQuery(Method method, Object receiver, Object[] params) : inExecQuery() &amp;&amp; withincode(* execute(..)) &amp;&amp; call(* Method.invoke(..)) &amp;&amp; args(receiver, params) &amp;&amp; target(method); protected pointcut monitorEnd() : dwrQuery(*, *, *); Matching call site: Object reply = method.invoke(object, params); I've tracked it down to failing to find the method in ResolvedType.matches. On line 405: "m1.getSignature()"= "(Ljava/lang/Object;[Ljava.lang.Object;)Ljava/lang/Object;" "m2.getSignature()"= "(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;" Note the difference between . and / ^ ^ It looks to me like the signature for array types in the reflection delegate is erroneously using . instead of /. I have attached a patch to the ReflectionBasedReferenceTypeDelegateTest that isolates this unexpected signature return. Hopefully you agree that this is not correct. If not, some more information follows. Here's the stack trace where the match fails: ResolvedType.matches(Member, Member) line: 405 ReferenceType(ResolvedType).lookupMember(Member, Iterator) line: 347 ReferenceType(ResolvedType).lookupMethod(Member) line: 326 LTWWorld(World).resolve(Member) line: 504 MemberImpl.resolve(World) line: 93 JoinPointSignatureIterator.addSignaturesUpToFirstDefiningMember() line: 109 JoinPointSignatureIterator.&lt;init&gt;(Member, World) line: 51 MemberImpl.getJoinPointSignatures(World) line: 943 SignaturePattern.matches(Member, World, boolean) line: 286 KindedPointcut.matchInternal(Shadow) line: 106 KindedPointcut(Pointcut).match(Shadow) line: 146 AndPointcut.matchInternal(Shadow) line: 53 AndPointcut(Pointcut).match(Shadow) line: 146 AndPointcut.matchInternal(Shadow) line: 51 AndPointcut(Pointcut).match(Shadow) line: 146 AndPointcut.matchInternal(Shadow) line: 51 AndPointcut(Pointcut).match(Shadow) line: 146 AndPointcut.matchInternal(Shadow) line: 51 AndPointcut(Pointcut).match(Shadow) line: 146 OrPointcut.matchInternal(Shadow) line: 50 OrPointcut(Pointcut).match(Shadow) line: 146 BcelAdvice(ShadowMunger).match(Shadow, World) line: 71 BcelAdvice(Advice).match(Shadow, World) line: 112 BcelAdvice.match(Shadow, World) line: 107 BcelClassWeaver.match(BcelShadow, List) line: 2806 BcelClassWeaver.matchInvokeInstruction(LazyMethodGen, InstructionHandle, InvokeInstruction, BcelShadow, List) line: 2768 BcelClassWeaver.match(LazyMethodGen, InstructionHandle, BcelShadow, List) line: 2506 BcelClassWeaver.match(LazyMethodGen) line: 2332 BcelClassWeaver.weave() line: 494 BcelClassWeaver.weave(BcelWorld, LazyClassGen, List, List, List) line: 119 BcelWeaver.weave(UnwovenClassFile, BcelObjectType, boolean) line: 1613 BcelWeaver.weaveWithoutDump(UnwovenClassFile, BcelObjectType) line: 1564 BcelWeaver.weaveAndNotify(UnwovenClassFile, BcelObjectType, IWeaveRequestor) line: 1341 BcelWeaver.weave(IClassFileProvider) line: 1163 ClassLoaderWeavingAdaptor(WeavingAdaptor).getWovenBytes(String, byte[]) line: 319 ClassLoaderWeavingAdaptor(WeavingAdaptor).weaveClass(String, byte[]) line: 225 Aj.preProcess(String, byte[], ClassLoader) line: 77 ClassPreProcessorAdapter.preProcess(String, byte[], ClassLoader) line: 67 ClassPreProcessorHelper.defineClass0Pre(ClassLoader, String, byte[], int, int, ProtectionDomain) line: 107 WebappClassLoader(ClassLoader).defineClass(String, byte[], int, int, ProtectionDomain) line: 539 WebappClassLoader(SecureClassLoader).defineClass(String, byte[], int, int, CodeSource) line: 123 WebappClassLoader.findClassInternal(String) line: 1786 WebappClassLoader.findClass(String) line: 1048 WebappClassLoader.loadClass(String, boolean) line: 1506 WebappClassLoader.loadClass(String) line: 1385 WebappClassLoader(ClassLoader).loadClassInternal(String) line: 302 Class.forName0(String, boolean, ClassLoader) line: not available [native method] Class.forName(String) line: 141 InitializeLog.setWarnLogging(String) line: 121 InitializeLog.initializeLogging() line: 96 ContextLoaderServlet.init() line: 13 ContextLoaderServlet(GenericServlet).init(ServletConfig) line: 212 StandardWrapper.loadServlet() line: 879 StandardWrapper.load() line: 767 StandardContext.loadOnStartup(Container[]) line: 3483 StandardContext.start() line: 3709 StandardHost(ContainerBase).addChildInternal(Container) line: 776 StandardHost(ContainerBase).addChild(Container) line: 759 StandardHost.addChild(Container) line: 537 StandardHostDeployer.install(String, URL) line: 260 StandardHost.install(String, URL) line: 730 HostConfig.deployWARs(File, String[]) line: 558 HostConfig.deployApps() line: 373 HostConfig.start() line: 784 HostConfig.lifecycleEvent(LifecycleEvent) line: 330 LifecycleSupport.fireLifecycleEvent(String, Object) line: 119 StandardHost(ContainerBase).start() line: 1155 StandardHost.start() line: 696 StandardEngine(ContainerBase).start() line: 1147 StandardEngine.start() line: 310 StandardService.start() line: 449 StandardServer.start() line: 2212 Catalina.start() line: 458 Catalina.execute() line: 345 Catalina.process(String[]) line: 129 NativeMethodAccessorImpl.invoke0(Method, Object, Object[]) line: not available [native method] NativeMethodAccessorImpl.invoke(Object, Object[]) line: 39 DelegatingMethodAccessorImpl.invoke(Object, Object[]) line: 25 Method.invoke(Object, Object[]) line: 324 Bootstrap.main(String[]) line: 150 I'm using a modified version of Alex Vasseur's LTW plugin for a Java 1.4 VM although I haven't tested on the JRockIt plugin for a 1.4 VM: my guess is that this would fail there too.
Bug in reflection delegate signature for array of object type The following problem is interesting because the advice weaves correctly with Java 1.5 LTW and also using Java 1.4 with build-time weaving. However, the following call pointcut isn't matching the expected call site in Java 1.4 load-time weaving (*). line: 150 I'm using a modified version of Alex Vasseur's LTW plugin for a Java 1.4 VM although I haven't tested on the JRockIt plugin for a 1.4 VM: my guess is that this would fail there too.
******
weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.resolve(World world, Class),True
weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.testArrayArgsSig(),False,new_method|test_method
weaver5/java5-testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.testArrayArgsSig(),False,new_method|test_method
#####
AspectJ
129525
04fa1dcce12934cc5cfe1e5e8b66523c10e93672
Don't Dump Bytecodes to Syserr in LTW The load-time weaving system can produce truly massive quantities of output when there's a weaving error, since the system dumps the bytecode to syserr. It would be much better to produce an ajcore file and just point to it, or use some other log.
Don't Dump Bytecodes to Syserr in LTW The load-time weaving system can produce truly massive quantities of output when there's a weaving error, since the system dumps the bytecode to syserr. It would be much better to produce an ajcore file and just point to it, or use some other log.
******
loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.registerAspects(BcelWeaver, ClassLoader, List),True
loadtime/src/org/aspectj/weaver/loadtime/WeavingURLClassLoader.WeavingURLClassLoader(URL[], ClassLoader),True
loadtime/src/org/aspectj/weaver/loadtime/WeavingURLClassLoader.defineClass(String, byte[], CodeSource),True
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testReweavableAspectNotRegistered_pr129525(),False,new_method|test_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.init(List, List),True
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.disable(),True
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.handleMessage(IMessage),True
#####
AspectJ
155148
6be70973a704548a42e396e996c9d49915b92a64
jdk14 trace deadlock in oc4j I turned on tracing for the Aj class inside of Oracle's OC4J server. In one test (not always) it deadlocked. It looks like the threads are each trying to lock each other's loader. Notice that one of the threads is in the toString method of the Oracle ClassLoader (perhaps another reason to prefer tracing argument class names and system identity hashcodes). Here's a thread dump from Ctrl+BREAK: Found one Java-level deadlock: ============================= "WorkExecutorWorkerThread-1": waiting to lock monitor 0x003384ec (object 0x05239e48, a oracle.classloader.Po licyClassLoader), which is held by "OC4J Launcher" "OC4J Launcher": waiting to lock monitor 0x0033848c (object 0x0554f0e8, a oracle.classloader.Po licyClassLoader), which is held by "WorkExecutorWorkerThread-1" Java stack information for the threads listed above: =================================================== "WorkExecutorWorkerThread-1": at oracle.classloader.SearchPolicy.loadClass(SearchPolicy.java:641) - waiting to lock &lt;0x05239e48&gt; (a oracle.classloader.PolicyClassLoader) at oracle.classloader.PolicyClassLoader.askParentForClass(PolicyClassLoa der.java:1284) at oracle.classloader.SearchPolicy$AskParent.getClass(SearchPolicy.java: 69) at oracle.classloader.SearchSequence.getClass(SearchSequence.java:119) at oracle.classloader.SearchPolicy.loadClass(SearchPolicy.java:642) - locked &lt;0x0554f0e8&gt; (a oracle.classloader.PolicyClassLoader) at oracle.classloader.PolicyClassLoader.askParentForClass(PolicyClassLoa der.java:1284) at oracle.classloader.SearchPolicy$AskParent.getClass(SearchPolicy.java: 69) at oracle.classloader.SearchSequence.getClass(SearchSequence.java:119) at oracle.classloader.PolicyClassLoader.internalLoadClass(PolicyClassLoa der.java:1660) - locked &lt;0x056a9ed0&gt; (a oracle.classloader.PolicyClassLoader) at oracle.classloader.PolicyClassLoader.loadClass(PolicyClassLoader.java :1621) at oracle.classloader.PolicyClassLoader.loadClass(PolicyClassLoader.java :1606) at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:319) - locked &lt;0x056a9ed0&gt; (a oracle.classloader.PolicyClassLoader) at oracle.j2ee.ra.jms.generic.WorkConsumer.doReceive(WorkConsumer.java:9 87) at oracle.j2ee.ra.jms.generic.WorkConsumer.run(WorkConsumer.java:215) - locked &lt;0x05de2718&gt; (a oracle.j2ee.ra.jms.generic.WorkConsumer) at oracle.j2ee.connector.work.WorkWrapper.runTargetWork(WorkWrapper.java :242) at oracle.j2ee.connector.work.WorkWrapper.doWork(WorkWrapper.java:215) at oracle.j2ee.connector.work.WorkWrapper.run(WorkWrapper.java:190) at EDU.oswego.cs.dl.util.concurrent.PooledExecutor$Worker.run(PooledExec utor.java:814) at java.lang.Thread.run(Thread.java:595) "OC4J Launcher": at oracle.classloader.PolicyClassLoader.toString(PolicyClassLoader.java: 1846) - waiting to lock &lt;0x0554f0e8&gt; (a oracle.classloader.PolicyClassLoader) at java.text.MessageFormat.subformat(MessageFormat.java:1237) at java.text.MessageFormat.format(MessageFormat.java:828) at java.text.Format.format(Format.java:133) at java.text.MessageFormat.format(MessageFormat.java:804) at java.util.logging.Formatter.formatMessage(Formatter.java:130) - locked &lt;0x0514e920&gt; (a java.util.logging.SimpleFormatter) at java.util.logging.SimpleFormatter.format(SimpleFormatter.java:63) - locked &lt;0x0514e920&gt; (a java.util.logging.SimpleFormatter) at java.util.logging.StreamHandler.publish(StreamHandler.java:179) - locked &lt;0x0514a0a8&gt; (a java.util.logging.FileHandler) at java.util.logging.FileHandler.publish(FileHandler.java:555) - locked &lt;0x0514a0a8&gt; (a java.util.logging.FileHandler) at java.util.logging.Logger.log(Logger.java:428) at java.util.logging.Logger.doLog(Logger.java:450) at java.util.logging.Logger.logp(Logger.java:619) at java.util.logging.Logger.entering(Logger.java:870) at org.aspectj.weaver.tools.Jdk14Trace.enter(Jdk14Trace.java:32) at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:67) at org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform(C lassPreProcessorAgentAdapter.java:55) at sun.instrument.TransformerManager.transform(TransformerManager.java:1 22) at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java :155) at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClass(ClassLoader.java:620) at oracle.classloader.PolicyClassLoader.defineClass(PolicyClassLoader.ja va:2224) at oracle.classloader.PolicyClassLoader.findLocalClass(PolicyClassLoader .java:1457) at oracle.classloader.SearchPolicy$FindLocal.getClass(SearchPolicy.java: 167) at oracle.classloader.SearchSequence.getClass(SearchSequence.java:119) at oracle.classloader.PolicyClassLoader.internalLoadClass(PolicyClassLoa der.java:1660) - locked &lt;0x05239e48&gt; (a oracle.classloader.PolicyClassLoader) at oracle.classloader.PolicyClassLoader.loadClass(PolicyClassLoader.java :1621) at oracle.classloader.PolicyClassLoader.loadClass(PolicyClassLoader.java :1606) at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:319) - locked &lt;0x05239e48&gt; (a oracle.classloader.PolicyClassLoader) at com.evermind.server.http.HttpRequestHandler.&lt;init&gt;(HttpRequestHandler .java:97) at com.evermind.server.http.HttpConnectionListener$HttpNIOAcceptHandler. getReadHandler(HttpConnectionListener.java:116) at oracle.oc4j.network.ReadHandlerPool.getContextFromBackend(ReadHandler Pool.java:63) at com.evermind.util.BBPool.startPool(BBPool.java:42) at oracle.oc4j.network.ReadHandlerPool.register(ReadHandlerPool.java:25) - locked &lt;0x05ec9290&gt; (a java.util.ArrayList) at oracle.oc4j.network.ServerSocketAcceptHandler.setPoolOptions(ServerSo cketAcceptHandler.java:140) at com.evermind.server.http.HttpConnectionListener.setRequestHandlerPool (HttpConnectionListener.java:232) at com.evermind.server.http.HttpConnectionListener.initHandlers(HttpConn ectionListener.java:226) at com.evermind.server.http.HttpConnectionListener.&lt;init&gt;(HttpConnection Listener.java:174) at com.evermind.server.http.HttpServer.getListener(HttpServer.java:481) - locked &lt;0x05ec4f88&gt; (a com.evermind.server.http.HttpServer) at com.evermind.server.http.HttpServer.setSites(HttpServer.java:267) - locked &lt;0x05ec4f88&gt; (a com.evermind.server.http.HttpServer) at com.evermind.server.http.HttpServer.setConfig(HttpServer.java:180) at com.evermind.server.ApplicationServer.initializeHttp(ApplicationServe r.java:2296) at com.evermind.server.ApplicationServer.setConfig(ApplicationServer.jav a:944) at com.evermind.server.ApplicationServerLauncher.run(ApplicationServerLa uncher.java:113) - locked &lt;0x0530eb20&gt; (a java.lang.Object) at java.lang.Thread.run(Thread.java:595) Found 1 deadlock.
jdk14 trace deadlock in oc4j I turned on tracing for the class inside of Oracle's OC4J server. In one test (not always) it deadlocked. It looks like the threads are each trying to lock each other's loader. Notice that one of the threads is in the method of the Oracle (perhaps another reason to prefer tracing argument class names and system identity). Here's a thread dump from Ctrl+BREAK: Found one Java-level deadlock: waiting to lock monitor which is held by  waiting to lock monitor which is held by Java stack information for the threads listed above: =================================================== 
******
loadtime/src/org/aspectj/weaver/loadtime/DefaultWeavingContext.getClassLoaderName(),True
weaver/src/org/aspectj/weaver/tools/AbstractTrace.formatObj(Object),True
weaver/src/org/aspectj/weaver/tools/AbstractTrace.formatObjects(Object[]),False,new_method
weaver/testsrc/org/aspectj/weaver/AbstractTraceTest.testEnterWithThisAndArray(),False,test_method
weaver/testsrc/org/aspectj/weaver/AbstractTraceTest.testEnterWithThisAndCollection(),False,test_method
weaver/testsrc/org/aspectj/weaver/AbstractTraceTest.testEnterWithThisAndTraceable(),False,test_method
weaver/testsrc/org/aspectj/weaver/AbstractTraceTest.toTraceString(),False,test_method
weaver/testsrc/org/aspectj/weaver/AbstractTraceTest.testEnterWithThisAndToStringException(),False,new_method|test_method
weaver/testsrc/org/aspectj/weaver/AbstractTraceTest.toString(),False,new_method|test_method
weaver/testsrc/org/aspectj/weaver/AbstractTraceTest.testEnterWithThisAndHashCodeException (),False,new_method|test_method
weaver/testsrc/org/aspectj/weaver/AbstractTraceTest.testEnterWithThisAndClassLoader(),False,new_method|test_method
weaver5/java5-src/org/aspectj/weaver/tools/Jdk14Trace.enter(String, Object, Object[]),True
weaver5/java5-src/org/aspectj/weaver/tools/Jdk14Trace.exit(String, Object),True
weaver5/java5-src/org/aspectj/weaver/tools/Jdk14Trace.event(String, Object, Object[]),True
#####
AspectJ
155238
14e8b7d8f0c94d316665036c3968821f8874678e
"Trace should use System.identityHashCode, not hashCode" The tracing module uses obj.hashCode() to identify untrusted objects when formatting. I think it would be a little safer and more accurate to use System.identityHashCode(obj). This way the tracing code wouldn't call any application-defined code, and would give a value that can't change if the loader state changes.
"Trace should use, not " The tracing module uses to identify untrusted objects when formatting. I think it would be a little safer and more accurate to use. This way the tracing code wouldn't call any application-defined code, and would give a value that can't change if the loader state changes.
******
loadtime/src/org/aspectj/weaver/loadtime/DefaultWeavingContext.getClassLoaderName(),True
weaver/src/org/aspectj/weaver/tools/AbstractTrace.formatObj(Object),True
#####
AspectJ
155972
090de7e4c5c9618f965259f93de6d490050543da
NullPointerException in ConstructorSignature.getConstructor() AspectJ version: 1.5.3.200608290814 When advising a constructor, we can do the following to obtain the constructor as a java.lang.reflect.Member: Member cons = ((ConstructorSignature) thisJoinPointStaticPart .getSignature()).getConstructor(); however that sometimes fails, and returns null.
version: 1.5.3.200608290814 When advising a constructor, we can do the following to obtain the constructor as a however that sometimes fails, and returns null.
******
runtime/src/org/aspectj/runtime/reflect/ConstructorSignatureImpl.getConstructor(),True
runtime/src/org/aspectj/runtime/reflect/FieldSignatureImpl.getField(),True
runtime/src/org/aspectj/runtime/reflect/InitializerSignatureImpl.getInitializer(),True
tests/bugs153/pr155972/ConstructorTest.main(String[]),False,new_method|test_method
tests/bugs153/pr155972/FieldTest.main(String[]),False,new_method|test_method
tests/bugs153/pr155972/InitializerTest.main(String[]),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testNPEinConstructorSignatureImpl_pr155972 (),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testNPEinFieldSignatureImpl_pr155972(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testNPEinInitializerSignatureImpl_pr155972(),False,new_method|test_method
#####
AspectJ
151182
397a19d441eaf7fdc67e841232b410358b48ba11
NPE in BcelWeaver using LTW Hi, I created a logging aspect for our application some time ago using 1.5.0 of AspectJ. I enabled this from time to time using Load Time Weaving. I have recently recompiled the aspect using 1.5.2 and tried to run it also using the 1.5.2 weaver jar, but it fails with a NullPointerException. This is part of one of the many stacktraces: 20 jul 2006 07:42:49,046 - java.lang.NullPointerException 20 jul 2006 07:42:49,062 - at org.aspectj.weaver.bcel.BcelWeaver.weaveParentTypeMungers(BcelWeaver.java:1367) 20 jul 2006 07:42:49,062 - at org.aspectj.weaver.bcel.BcelWeaver.weaveParentsFor(BcelWeaver.java:1237) 20 jul 2006 07:42:49,062 - at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1072) 20 jul 2006 07:42:49,062 - at org.aspectj.weaver.tools.WeavingAdaptor.getWovenBytes(WeavingAdaptor.java:284) 20 jul 2006 07:42:49,062 - at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass(WeavingAdaptor.java:212) 20 jul 2006 07:42:49,062 - at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:65) 20 jul 2006 07:42:49,062 - at org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform(ClassPreProcessorAgentAdapter.java:55) 20 jul 2006 07:42:49,062 - at sun.instrument.TransformerManager.transform(Unknown Source) 20 jul 2006 07:42:49,062 - at sun.instrument.InstrumentationImpl.transform(Unknown Source) 20 jul 2006 07:42:49,062 - at java.lang.ClassLoader.defineClass1(Native Method) 20 jul 2006 07:42:49,062 - at java.lang.ClassLoader.defineClass(Unknown Source) I then tried with the 1.5.0 weaver jar (although the aspect was compiled using 1.5.2) and this ran without problems.
NPE in using LTW Hi, I created a logging aspect for our application some time ago using 1.5.0 of AspectJ. I enabled this from time to time using Load Time Weaving. I have recently recompiled the aspect using 1.5.2 and tried to run it also using the 1.5.2 weaver jar, but it fails with a I then tried with the 1.5.0 weaver jar (although the aspect was compiled using 1.5.2) and this ran without problems.
******
loadtime/src/org/aspectj/weaver/loadtime/Aj.preProcess(String, byte[], ClassLoader),True
#####
AspectJ
156962
7a4256df61f2d23aefb855ffb0ad6c6bfb2d36d6
[annotations] Problems with @Deprecated in member signatures The latest dev builds still have cases where they don't match properly on @Deprecated. See attached for two failing test cases for execution and hasMethod.
[annotations] Problems with in member signatures The latest dev builds still have cases where they don't match properly on . See attached for two failing test cases for execution and .
******
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testAnnotMethod_pr156962(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testAnnotMethodHasMember_pr156962(),False,new_method|test_method
weaver/src/org/aspectj/weaver/bcel/BcelField.ensureAnnotationTypesRetrieved(),True
weaver/src/org/aspectj/weaver/bcel/BcelMethod.ensureAnnotationTypesRetrieved(),True
weaver/src/org/aspectj/weaver/patterns/HasMemberTypePattern.hasField(ResolvedType),True
weaver/src/org/aspectj/weaver/patterns/HasMemberTypePattern.hasMethod(ResolvedType),True
#####
AspectJ
153845
70ae0f8df6ec8b77ea2940b222e11d6d411ec5d2
[generics] Problem with signature for generic type public aspect OuterAspect { private pointcut isSetter() : execution(void set*(..)); public static aspect InnerAspect pertarget(isSetter()) { } } java.lang.IllegalStateException at org.aspectj.apache.bcel.classfile.GenericSignatureParser.parseFieldTypeSignature(GenericSignatureParser.java:163) at org.aspectj.apache.bcel.classfile.GenericSignatureParser.parseTypeArgument(GenericSignatureParser.java:253) at org.aspectj.apache.bcel.classfile.GenericSignatureParser.maybeParseTypeArguments(GenericSignatureParser.java:261) at org.aspectj.apache.bcel.classfile.GenericSignatureParser.parseClassTypeSignature(GenericSignatureParser.java:208) at org.aspectj.apache.bcel.classfile.GenericSignatureParser.parseAsClassSignature(GenericSignatureParser.java:56) at org.aspectj.apache.bcel.classfile.Signature.asClassSignature(Signature.java:315) at org.aspectj.apache.bcel.classfile.JavaClass.getGenericClassTypeSignature(JavaClass.java:973) at org.aspectj.weaver.bcel.BcelObjectType.initializeFromJavaclass(BcelObjectType.java:164) at org.aspectj.weaver.bcel.BcelObjectType.&lt;init&gt;(BcelObjectType.java:131) at org.aspectj.weaver.bcel.BcelWorld.buildBcelDelegate(BcelWorld.java:337) at org.aspectj.weaver.bcel.BcelWorld.addSourceObjectType(BcelWorld.java:395) at org.aspectj.weaver.bcel.BcelWeaver.addIfAspect(BcelWeaver.java:263) at org.aspectj.weaver.bcel.BcelWeaver.addAspectsFromDirectory(BcelWeaver.java:255) at org.aspectj.weaver.bcel.BcelWeaver.addLibraryJarFile(BcelWeaver.java:205) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.initBcelWorld(AjBuildManager.java:698) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:223) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:199) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:170) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) IllegalStateException thrown: Expecting [,L, or T, but found Pjava while unpacking Ljava/util/AbstractSet&lt;Pjava/util/Map$Entry&lt;TK;TV;&gt;;&gt;;
[generics] Problem with signature for generic type public aspect
******
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testNoIllegalStateExceptionWithGenericInnerAspect_pr156058(),False,formatting|test_method
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testIllegalStateExceptionGenerics_pr153845(),False,new_method|test_method
weaver/src/org/aspectj/weaver/ReferenceType.makeDeclaredSignature(ResolvedType, UnresolvedType[]),True
#####
AspectJ
153490
b49e8cae5b2473c7285c29f3ff33a621513ebbd5
IllegalStateException thrown: How come we're in AsmObjectType resolving an inner type of something that is NOT a AsmObjectType?? I try out Contract4J 0.5 with AspectJ 1.5.2 (Build 20060629124300) and Eclipse 3.2 (Build M20060629-1905) under Windows XP SP2 and Java 1.5.0_06. So I became following exception. (You will find my testcode below the exception.) I am not sure if this bug related to Contract4J or to AspectJ!? ==== The Exception ==== java.lang.IllegalStateException at org.aspectj.weaver.asm.AsmDelegate.getFormalTypeParametersFromOuterClass(AsmDelegate.java:465) at org.aspectj.weaver.asm.AsmDelegate.ensureSignatureUnpacked(AsmDelegate.java:395) at org.aspectj.weaver.asm.AsmDelegate.getDeclaredInterfaces(AsmDelegate.java:538) at org.aspectj.weaver.ReferenceType.getDeclaredInterfaces(ReferenceType.java:426) at org.aspectj.weaver.ResolvedType.getDirectSupertypes(ResolvedType.java:64) at org.aspectj.weaver.ResolvedType.collectInterTypeMungers(ResolvedType.java:1155) at org.aspectj.weaver.ResolvedType.getInterTypeMungersIncludingSupers(ResolvedType.java:1134) at org.aspectj.weaver.ResolvedType.checkInterTypeMungers(ResolvedType.java:1201) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:643) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:519) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.createBinaryTypeFrom(AjLookupEnvironment.java:1058) at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:480) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:190) at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:111) at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:43) at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:53) at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.getMemberType(BinaryTypeBinding.java:618) at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.Scope.findMemberType(Scope.java:928) at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.BlockScope.getBinding(BlockScope.java:449) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference.resolveType(QualifiedNameReference.java:903) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:326) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:829) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:422) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:178) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:400) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1088) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1137) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:305) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:519) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:887) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:271) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:170) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) IllegalStateException thrown: How come we're in AsmObjectType resolving an inner type of something that is NOT a AsmObjectType?? ==== My TestCode ==== import org.contract4j5.Contract; import org.contract4j5.Post; import org.contract4j5.Pre; import org.contract4j5.aspects.Contract4J; // this is a dummy code!! @Contract public class Foo { private String fooField = null; @Pre("nr != null") public void setFooField(String f) { fooField = f; } @Post("$return != null") public String getFooField() { return fooField; } public static void main(String[] args) { Contract4J.setEnabled(Contract4J.TestType.Pre, true); //1 Contract4J.setEnabled(Contract4J.TestType.Post, true); //2 Contract4J.setEnabled(Contract4J.TestType.Invar, true); //3 Foo foo = new Foo(); foo.setFooField(null); System.out.println(foo.getFooField()); } }
IllegalStateException thrown: How come we're in resolving an inner type of something that is NOT a ?? I try out Contract4J 0.5 with AspectJ 1.5.2 (Build 20060629124300) and Eclipse 3.2 (Build M20060629-1905) under Windows XP SP2 and Java 1.5.0_06. So I became following exception. (You will find my testcode below the exception.) I am not sure if this bug related to Contract4J or to AspectJ!? ==== The Exception ====
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.getOuterClass(),False,new_method
weaver/src/org/aspectj/weaver/AbstractReferenceTypeDelegate.getGenericClassTypeSignature(),False,new_method
getFormalTypeParametersFromOuterClass(),False,new_method
weaver/src/org/aspectj/weaver/BoundedReferenceType.getOuterClass(),False,new_method
weaver/src/org/aspectj/weaver/ReferenceType.isAnonymous(),True
weaver/src/org/aspectj/weaver/ReferenceType.isNested(),True
weaver/src/org/aspectj/weaver/ReferenceType.getOuterClass(),False,new_method
weaver/src/org/aspectj/weaver/ReferenceTypeDelegate.getOuterClass(),False,new_method
weaver/src/org/aspectj/weaver/asm/AsmDelegate.getOuterClass(),False,changed_Access_Level
weaver/src/org/aspectj/weaver/asm/AsmDelegate.getFormalTypeParametersFromOuterClass(),True
weaver/src/org/aspectj/weaver/bcel/BcelObjectType.initializeFromJavaclass(),True
weaver/src/org/aspectj/weaver/bcel/BcelObjectType.getTypeVariables(),True
weaver/src/org/aspectj/weaver/bcel/BcelObjectType.getGenericClassTypeSignature(),True
weaver/src/org/aspectj/weaver/bcel/BcelObjectType.isNestedClass(),True
weaver/src/org/aspectj/weaver/bcel/BcelObjectType.getOuterClass(),True
weaver/src/org/aspectj/weaver/bcel/BcelObjectType.getFormalTypeParametersFromOuterClass(),True
weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegate.getOuterClass(),False,new_method
#####
AspectJ
152848
fd3d29f4c44252e3ca9cba35ea43b1847971da50
IllegalStateException thrown: Expecting raw type I get the exception below when I enable AspectJ on my Java project: java.lang.IllegalStateException at org.aspectj.weaver.TypeFactory.createParameterizedType(TypeFactory.java:42) at org.aspectj.weaver.bcel.BcelGenericSignatureToTypeXConverter.classTypeSignature2TypeX(BcelGenericSignatureToTypeXConverter.java:82) at org.aspectj.weaver.bcel.BcelGenericSignatureToTypeXConverter.classTypeSignature2TypeX(BcelGenericSignatureToTypeXConverter.java:42) at org.aspectj.weaver.asm.AsmDelegate.ensureSignatureUnpacked(AsmDelegate.java:410) at org.aspectj.weaver.asm.AsmDelegate.getDeclaredInterfaces(AsmDelegate.java:538) at org.aspectj.weaver.ReferenceType.getDeclaredInterfaces(ReferenceType.java:426) at org.aspectj.weaver.ResolvedType.getDirectSupertypes(ResolvedType.java:64) at org.aspectj.weaver.ResolvedType.collectInterTypeMungers(ResolvedType.java:1155) at org.aspectj.weaver.ResolvedType.getInterTypeMungersIncludingSupers(ResolvedType.java:1134) at org.aspectj.weaver.ResolvedType.checkInterTypeMungers(ResolvedType.java:1201) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:643) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:519) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.createBinaryTypeFrom(AjLookupEnvironment.java:1058) at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:480) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:190) at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:111) at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:43) at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:53) at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:167) at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.findImport(CompilationUnitScope.java:413) at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.findSingleImport(CompilationUnitScope.java:466) at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.faultInImports(CompilationUnitScope.java:331) at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.faultInTypes(CompilationUnitScope.java:400) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:512) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:887) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:244) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:163) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) IllegalStateException thrown: Expecting raw type
thrown: Expecting raw type I get the exception below when I enable AspectJ on my Java project
******
weaver/src/org/aspectj/weaver/TypeFactory.createParameterizedType(ResolvedType, UnresolvedType[], World),True
weaver/src/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.classTypeSignature2TypeX(Signature.ClassTypeSignature, Signature.FormalTypeParameter[], World, Map),True
#####
AspectJ
158573
cd9fd1147b63c7a0df0c93307feae4dce7b19d4d
changing value of variable in aspect results in adviceDidNotMatch warningGiven the following: public aspect A { public static int i = 0; before() : execution(* *.*(..)) {} } public class C { public void m() {} } Changing the value of i to be something else and then saving results in an incremental build and an "adviceDidNotMatch" warning. A full build clears the warning. This is since the JDTLikeHandleProvider (bug 141730) was made the default in AJDT and is down to the call on line 90 of CrosscuttingMembersSet which is the fix for bug 134541). The reason we now hit this is that the JDTLikeHandleProvider doesn't depend on location.
changing value of variable in aspect results in the following: Changing the value of i to be something else and then saving results in an incremental build and an "" warning. A full build clears the warning. This is since the (bug 141730) was made the default in AJDT and is down to the call on line 90 of which is the fix for bug 134541). The reason we now hit this is that the doesn't depend on location.
******
tests/multiIncremental/PR158573/base/C.m(),False,new_method|test_method
tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.testPR158573(),False,new_method|test_method
weaver/src/org/aspectj/weaver/CrosscuttingMembers.replaceWith(CrosscuttingMembers, boolean),True
weaver/src/org/aspectj/weaver/bcel/BcelAdvice.setHasMatchedSomething(boolean),False,new_method
#####
AspectJ
156904
782ade25e6d68caf361f51a1e040edbd6855842b
Incorrect warning when advising a private method of a private inner class The Eclipse AJDT give an incorrect warning when you want to advise a private method of a private inner class. When I want to advise a private method in a private inner class, like this public class Outer { private class Inner { private void myMethod() } } Using the following poincut: poincut innerpointcut():execution( * Outer.Inner.myMethod() ); and advice: before():innerpointcut() { System.out.println( "executing!" ); } I get a warning "invalidAbsoluteTypeName" next to my pointcut, but next to the advice, there is a marker that points to the private method.
Incorrect warning when advising a private method of a private inner class The Eclipse AJDT give an incorrect warning when you want to advise a private method of a private inner class. When I want to advise a private method in a private inner class, like this I get a warning "" next to my pointcut, but next to the advice, there is a marker that points to the private method.
******
tests/bugs153/pr156904/inDiffPkgAndImport/Outer.myMethod(),False,new_method|test_method
tests/bugs153/pr156904/inDiffPkgWithoutImport/Outer.myMethod(),False,new_method|test_method
tests/bugs153/pr156904/inSamePkg/Outer.myMethod(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testNoInvalidAbsoluteTypeNameWarning_pr156904_1(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testNoInvalidAbsoluteTypeNameWarning_pr156904_2(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testNoInvalidAbsoluteTypeNameWarning_pr156904_3(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testNoInvalidAbsoluteTypeNameWarning_pr156904_4(),False,new_method|test_method
weaver/src/org/aspectj/weaver/patterns/WildTypePattern.esolveBindingsFromFullyQualifiedTypeName(String, IScope, Bindings, boolean, boolean),True
weaver/src/org/aspectj/weaver/patterns/WildTypePattern.lookupTypeInWorldIncludingPrefixes(World, String, String[]),False,new_method
#####
AspectJ
149071
a67ec0d3c573b37b0d1bbc8b2400da430dfb2faa
[itds] Improper visibility of ITD in nested inner type This code fails, but should work: public aspect AspectItd { //private interface Holder {} private int Holder.x; static aspect Inner { int doIt(Holder h) { return h.x++; } } } interface Holder{} C:\devel\scratch\inner&gt;ajc AspectItd.java C:\devel\scratch\inner\AspectItd.java:6 [error] The field Holder.x is not visibl e return h.x++; 1 error This appears to be incorrectly applying the visibility rules based on the declared type (i.e., a private defined on Holder shouldn't be visible in Inner), whereas of course it should be using the aspect's visibility rule: the field is visible to AspectItd, hence to Inner. If you make the interface an inner type, then it works properly (i.e., comment out interface Holder and uncomment the line above). By analogy, this Java code also works: public class Java { private int x; static class Inner { int doIt(Java j) { return j.x++; } } }
[itds] Improper visibility of in nested inner type This code fails, but should work: 1 error This appears to be incorrectly applying the visibility rules based on the declared type (i.e., a private defined on Holder shouldn't be visible in Inner), whereas of course it should be using the aspect's visibility rule: the field is visible to, hence to Inner. If you make the interface an inner type, then it works properly (i.e., comment out interface Holder and uncomment the line above). By analogy, this Java code also works
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeFieldBinding.canBeSeenBy(TypeBinding, InvocationSite, Scope),True
tests/bugs153/pr149071/AspectItd.main(String),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testVisibilityProblem_pr149071(),False,test_method
#####
AspectJ
152366
7b831ff7356725b9872a9635d1e0eeb035f2790b
LTW Within Patterns Should Accept AND For Consistency The load-time weaving definition system accepts AND in addition to &amp;amp;&amp;amp; for pointcuts, but it silently accepts and then fails to work with type patterns that use AND. Such type patterns are important when creating exceptions (e.g., excluding weblogic..* &amp;amp;&amp;amp; !weblogic.jdbc..*) and using AND is also helpful here. I've attached a patch to support this and tests to show it's working.
LTW Within Patterns Should Accept AND For Consistency The weaving definition system accepts AND in addition to &amp;amp;&amp;amp; for pointcuts, but it silently accepts and then fails to work with type patterns that use AND. Such type patterns are important when creating exceptions (e.g., excluding .*) and using AND is also helpful here. I've attached a patch to support this and tests to show it's working.
******
loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.startElement(String, String, String, Attributes),True
loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.getWithinAttribute(Attributes),True
tests/src/org/aspectj/systemtest/ajc150/ltw/LTWTests.testInclusionAndPattern(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/ltw/LTWTests.testExclusionAndPattern(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/ltw/LTWTests.testAndPatternsAspects(),False,new_method|test_method
#####
AspectJ
159896
d532892d89865511ea39286e4ebd34fc20b96a5d
advice from injars do not have unique handles with the JDTLikeHandleProvider Advice of the same kind contained in the same aspect currently do not have unique handles if the aspect is on the aspectpath.
advice from injars do not have unique handles with the Advice of the same kind contained in the same aspect currently do not have unique handles if the aspect is on the aspectpath.
******
tests/features153/jdtlikehandleprovider/ClassForAspectpath.foo(),False,new_method|test_method
tests/features153/jdtlikehandleprovider/ClassForAspectpath.bar(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc153/JDTLikeHandleProviderTests.testTwoPiecesOfBeforeAdviceInInjarAspectHaveUniqueHandles_pr159896(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc153/JDTLikeHandleProviderTests.testTwoDeclareWarningsInInjarAspectHaveUniqueHandles_pr159896(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc153/JDTLikeHandleProviderTests.testOnlyIncrementSameDeclareTypeFromInjar_pr159896(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc153/JDTLikeHandleProviderTests.testOnlyIncrementSameAdviceKindFromInjar_pr159896(),False,new_method|test_method
weaver/src/org/aspectj/weaver/ShadowMunger.addChildNodes(IProgramElement, Collection),True
weaver/src/org/aspectj/weaver/ShadowMunger.createDeclareErrorOrWarningChild(DeclareErrorOrWarning, int),False,new_method
weaver/src/org/aspectj/weaver/ShadowMunger.createAdviceChild(BcelAdvice, int),False,new_method
weaver/src/org/aspectj/weaver/patterns/DeclareErrorOrWarning.toString(),False,comments
weaver/src/org/aspectj/weaver/patterns/DeclareErrorOrWarning.getName(),False,new_method
#####
AspectJ
158624
ea4ff8adad2347557c25d6e10e114132b7491870
Compiler Error: generics and arrays OK, not sure what to report here or what info you need, but here's the set up, message, and erroreous class. I don't understand the errors from the compiler enough to parse down the erroneous file to something that contains only the bug, but I could if direction were given. Here's my set up: Eclipse SDK Version: 3.2.0 Build id: M20060629-1905 With AJDT: Eclipse AspectJ Development Tools Version: 1.4.1.200608141223 AspectJ version: 1.5.3.200608210848 Here's the bug dump from the compiler inside Eclipse: java.lang.UnsupportedOperationException at org.aspectj.weaver.UnresolvedType.parameterize(UnresolvedType.java:221) at org.aspectj.weaver.ResolvedMemberImpl.parameterize(ResolvedMemberImpl.java:680) at org.aspectj.weaver.ResolvedMemberImpl.parameterize(ResolvedMemberImpl.java:690) at org.aspectj.weaver.ResolvedMemberImpl.parameterizedWith(ResolvedMemberImpl.java:643) at org.aspectj.weaver.ResolvedMemberImpl.parameterizedWith(ResolvedMemberImpl.java:597) at org.aspectj.weaver.ReferenceType.getDeclaredMethods(ReferenceType.java:508) at org.aspectj.weaver.ResolvedType$4.get(ResolvedType.java:226) at org.aspectj.weaver.Iterators$3$1.hasNext(Iterators.java:118) at org.aspectj.weaver.Iterators$5.hasNext(Iterators.java:171) at org.aspectj.weaver.Iterators$3.hasNext(Iterators.java:128) at org.aspectj.weaver.ResolvedType.lookupMember(ResolvedType.java:346) at org.aspectj.weaver.ResolvedType.lookupMethod(ResolvedType.java:327) at org.aspectj.weaver.World.resolve(World.java:523) at org.aspectj.weaver.MemberImpl.resolve(MemberImpl.java:93) at org.aspectj.weaver.JoinPointSignatureIterator.addSignaturesUpToFirstDefiningMember(JoinPointSignatureIterator.java:109) at org.aspectj.weaver.JoinPointSignatureIterator.&lt;init&gt;(JoinPointSignatureIterator.java:51) at org.aspectj.weaver.MemberImpl.getJoinPointSignatures(MemberImpl.java:943) at org.aspectj.weaver.patterns.SignaturePattern.matches(SignaturePattern.java:286) at org.aspectj.weaver.patterns.KindedPointcut.matchInternal(KindedPointcut.java:106) at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:146) at org.aspectj.weaver.patterns.AndPointcut.matchInternal(AndPointcut.java:51) at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:146) at org.aspectj.weaver.ShadowMunger.match(ShadowMunger.java:75) at org.aspectj.weaver.Advice.match(Advice.java:112) at org.aspectj.weaver.bcel.BcelAdvice.match(BcelAdvice.java:117) at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2806) at org.aspectj.weaver.bcel.BcelClassWeaver.matchInvokeInstruction(BcelClassWeaver.java:2768) at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2506) at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2332) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:494) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:119) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1606) at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1557) at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1335) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1155) at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.weaveQueuedEntries(AjPipeliningCompilerAdapter.java:455) at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.queueForWeaving(AjPipeliningCompilerAdapter.java:392) at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.afterProcessing(AjPipeliningCompilerAdapter.java:380) at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$after$org_aspectj_ajdt_internal_compiler_CompilerAdapter$5$6b855184(CompilerAdapter.aj:98) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:533) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:892) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:246) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:165) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) trouble in: public class com.wec.lib.util.test.SyncValueTest extends junit.framework.TestCase: private com.wec.lib.util.test.SyncValueTest$SyncInteger a private com.wec.lib.util.test.SyncValueTest$SyncInteger b private com.wec.lib.util.test.SyncValueTest$SyncInteger c private com.wec.lib.util.test.SyncValueTest$SyncInteger d private com.wec.lib.util.test.SyncValueTest$SyncInteger e public void &lt;init&gt;(): ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 17) INVOKESPECIAL junit.framework.TestCase.&lt;init&gt; ()V constructor-execution(void com.wec.lib.util.test.SyncValueTest.&lt;init&gt;()) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 27) | NEW com.wec.lib.util.test.SyncValueTest$SyncInteger | DUP | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | ICONST_1 | INVOKESPECIAL com.wec.lib.util.test.SyncValueTest$SyncInteger.&lt;init&gt; (Lcom/wec/lib/util/test/SyncValueTest;I)V | PUTFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 28) | NEW com.wec.lib.util.test.SyncValueTest$SyncInteger | DUP | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | ICONST_2 | INVOKESPECIAL com.wec.lib.util.test.SyncValueTest$SyncInteger.&lt;init&gt; (Lcom/wec/lib/util/test/SyncValueTest;I)V | PUTFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 29) | NEW com.wec.lib.util.test.SyncValueTest$SyncInteger | DUP | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | ICONST_3 | INVOKESPECIAL com.wec.lib.util.test.SyncValueTest$SyncInteger.&lt;init&gt; (Lcom/wec/lib/util/test/SyncValueTest;I)V | PUTFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 30) | NEW com.wec.lib.util.test.SyncValueTest$SyncInteger | DUP | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | ICONST_4 | INVOKESPECIAL com.wec.lib.util.test.SyncValueTest$SyncInteger.&lt;init&gt; (Lcom/wec/lib/util/test/SyncValueTest;I)V | PUTFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 31) | NEW com.wec.lib.util.test.SyncValueTest$SyncInteger | DUP | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | ICONST_5 | INVOKESPECIAL com.wec.lib.util.test.SyncValueTest$SyncInteger.&lt;init&gt; (Lcom/wec/lib/util/test/SyncValueTest;I)V | PUTFIELD com.wec.lib.util.test.SyncValueTest.e Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | RETURN (line 17) constructor-execution(void com.wec.lib.util.test.SyncValueTest.&lt;init&gt;()) end public void &lt;init&gt;() public void testSyncValueGroup() org.aspectj.weaver.MethodDeclarationLineNumber: 39:1035 : method-execution(void com.wec.lib.util.test.SyncValueTest.testSyncValueGroup()) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 42) | GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | ICONST_1 | ANEWARRAY com.wec.lib.util.SyncValueGroup | DUP | ICONST_0 | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | AASTORE | method-call(void com.wec.lib.util.test.SyncValueTest$SyncInteger.link(com.wec.lib.util.SyncValueGroup[])) | | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.link ([Lcom/wec/lib/util/SyncValueGroup;)V | method-call(void com.wec.lib.util.test.SyncValueTest$SyncInteger.link(com.wec.lib.util.SyncValueGroup[])) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 43) | GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | IF_ACMPNE L0 | ICONST_1 | GOTO L1 | L0: ICONST_0 | L1: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ICONST_1 (line 44) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L2 | ICONST_1 | GOTO L3 | L2: ICONST_0 | L3: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 45) | GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | ICONST_2 | INVOKESTATIC java.lang.Integer.valueOf (I)Ljava/lang/Integer; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.setValue (Ljava/lang/Object;)V | ICONST_2 (line 46) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L4 | ICONST_1 | GOTO L5 | L4: ICONST_0 | L5: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 47) | GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | ICONST_1 | ANEWARRAY com.wec.lib.util.SyncValueGroup | DUP | ICONST_0 | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | AASTORE | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.link ([Lcom/wec/lib/util/SyncValueGroup;)V | ICONST_2 (line 48) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L6 | ICONST_1 | GOTO L7 | L6: ICONST_0 | L7: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 49) | GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | ICONST_3 | INVOKESTATIC java.lang.Integer.valueOf (I)Ljava/lang/Integer; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.setValue (Ljava/lang/Object;)V | ICONST_3 (line 50) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L8 | ICONST_1 | GOTO L9 | L8: ICONST_0 | L9: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ICONST_3 (line 51) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L10 | ICONST_1 | GOTO L11 | L10: ICONST_0 | L11: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 52) | GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | ICONST_4 | INVOKESTATIC java.lang.Integer.valueOf (I)Ljava/lang/Integer; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.setValue (Ljava/lang/Object;)V | ICONST_4 (line 53) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L12 | ICONST_1 | GOTO L13 | L12: ICONST_0 | L13: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ICONST_4 (line 54) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L14 | ICONST_1 | GOTO L15 | L14: ICONST_0 | L15: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 55) | GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | ICONST_1 | INVOKESTATIC java.lang.Integer.valueOf (I)Ljava/lang/Integer; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.setValue (Ljava/lang/Object;)V | ICONST_1 (line 56) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L16 | ICONST_1 | GOTO L17 | L16: ICONST_0 | L17: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ICONST_1 (line 57) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L18 | ICONST_1 | GOTO L19 | L18: ICONST_0 | L19: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 59) | GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | ICONST_1 | ANEWARRAY com.wec.lib.util.SyncValueGroup | DUP | ICONST_0 | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.e Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | AASTORE | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.link ([Lcom/wec/lib/util/SyncValueGroup;)V | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 60) | GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.e Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | IF_ACMPNE L20 | ICONST_1 | GOTO L21 | L20: ICONST_0 | L21: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 63) | GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | ICONST_1 | ANEWARRAY com.wec.lib.util.SyncValueGroup | DUP | ICONST_0 | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | AASTORE | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.link ([Lcom/wec/lib/util/SyncValueGroup;)V | ICONST_1 (line 64) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L22 | ICONST_1 | GOTO L23 | L22: ICONST_0 | L23: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ICONST_1 (line 65) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.e Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L24 | ICONST_1 | GOTO L25 | L24: ICONST_0 | L25: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 66) | GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | BIPUSH 8 | INVOKESTATIC java.lang.Integer.valueOf (I)Ljava/lang/Integer; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.setValue (Ljava/lang/Object;)V | BIPUSH 8 (line 67) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L26 | ICONST_1 | GOTO L27 | L26: ICONST_0 | L27: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | BIPUSH 8 (line 68) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L28 | ICONST_1 | GOTO L29 | L28: ICONST_0 | L29: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | BIPUSH 8 (line 69) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L30 | ICONST_1 | GOTO L31 | L30: ICONST_0 | L31: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | BIPUSH 8 (line 70) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L32 | ICONST_1 | GOTO L33 | L32: ICONST_0 | L33: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | BIPUSH 8 (line 71) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.e Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L34 | ICONST_1 | GOTO L35 | L34: ICONST_0 | L35: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 74) | GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.unlink ()V | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 75) | GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | ICONST_3 | INVOKESTATIC java.lang.Integer.valueOf (I)Ljava/lang/Integer; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.setValue (Ljava/lang/Object;)V | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 76) | GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | ICONST_2 | INVOKESTATIC java.lang.Integer.valueOf (I)Ljava/lang/Integer; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.setValue (Ljava/lang/Object;)V | ICONST_2 (line 77) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L36 | ICONST_1 | GOTO L37 | L36: ICONST_0 | L37: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ICONST_2 (line 78) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L38 | ICONST_1 | GOTO L39 | L38: ICONST_0 | L39: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ICONST_3 (line 79) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L40 | ICONST_1 | GOTO L41 | L40: ICONST_0 | L41: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ICONST_2 (line 80) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L42 | ICONST_1 | GOTO L43 | L42: ICONST_0 | L43: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ICONST_2 (line 81) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.e Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L44 | ICONST_1 | GOTO L45 | L44: ICONST_0 | L45: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 82) | GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.unlink ()V | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 83) | GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | ICONST_1 | ANEWARRAY com.wec.lib.util.SyncValueGroup | DUP | ICONST_0 | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | AASTORE | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.link ([Lcom/wec/lib/util/SyncValueGroup;)V | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 84) | GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | ICONST_1 | INVOKESTATIC java.lang.Integer.valueOf (I)Ljava/lang/Integer; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.setValue (Ljava/lang/Object;)V | ICONST_1 (line 85) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L46 | ICONST_1 | GOTO L47 | L46: ICONST_0 | L47: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ICONST_1 (line 86) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L48 | ICONST_1 | GOTO L49 | L48: ICONST_0 | L49: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ICONST_3 (line 87) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L50 | ICONST_1 | GOTO L51 | L50: ICONST_0 | L51: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ICONST_3 (line 88) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L52 | ICONST_1 | GOTO L53 | L52: ICONST_0 | L53: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ICONST_1 (line 89) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.e Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L54 | ICONST_1 | GOTO L55 | L54: ICONST_0 | L55: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | RETURN (line 90) method-execution(void com.wec.lib.util.test.SyncValueTest.testSyncValueGroup()) end public void testSyncValueGroup() end public class com.wec.lib.util.test.SyncValueTest when weaving classes when weaving when batch building BuildConfig[D:\workspace\.metadata\.plugins\org.eclipse.ajdt.core\ANSER2.generated.lst] #Files=365 Here's the class: package com.wec.lib.util.test; import static com.wec.ide.Constants.UNCHECKED; import junit.framework.TestCase; import org.junit.Test; import com.wec.lib.util.SyncValueGroup; import com.wec.scrum.Tests; /** * This class tests the SyncValueGroup utility class. */ @Tests(classes = { SyncValueGroup.class }) @SuppressWarnings("nls") public class SyncValueTest extends TestCase { class SyncInteger extends SyncValueGroup&lt;Integer&gt; { public SyncInteger(int val) { super(new Integer(val)); } public void valueChanged() { } } private SyncInteger a = new SyncInteger(1); private SyncInteger b = new SyncInteger(2); private SyncInteger c = new SyncInteger(3); private SyncInteger d = new SyncInteger(4); private SyncInteger e = new SyncInteger(5); /** * Ensures that SyncValueGroup replicates values and * calls valueChange. */ @SuppressWarnings(UNCHECKED) @Test public void testSyncValueGroup() { // Link tests a.link(b); assertTrue(a.getValue() == b.getValue()); assertTrue(1 == b.getValue()); b.setValue(2); assertTrue(2 == a.getValue()); b.link(c); assertTrue(2 == c.getValue()); c.setValue(3); assertTrue(3 == a.getValue()); assertTrue(3 == b.getValue()); a.setValue(4); assertTrue(4 == c.getValue()); assertTrue(4 == b.getValue()); b.setValue(1); assertTrue(1 == c.getValue()); assertTrue(1 == a.getValue()); d.link(e); assertTrue(d.getValue() == e.getValue()); // Join loops b.link(d); assertTrue(1 == d.getValue()); assertTrue(1 == e.getValue()); d.setValue(8); assertTrue(8 == a.getValue()); assertTrue(8 == b.getValue()); assertTrue(8 == c.getValue()); assertTrue(8 == d.getValue()); assertTrue(8 == e.getValue()); // Unlink tests c.unlink(); c.setValue(3); b.setValue(2); assertTrue(2 == a.getValue()); assertTrue(2 == b.getValue()); assertTrue(3 == c.getValue()); assertTrue(2 == d.getValue()); assertTrue(2 == e.getValue()); d.unlink(); c.link(d); a.setValue(1); assertTrue(1 == a.getValue()); assertTrue(1 == b.getValue()); assertTrue(3 == c.getValue()); assertTrue(3 == d.getValue()); assertTrue(1 == e.getValue()); } }
Compiler Error: generics and arrays OK, not sure what to report here or what info you need, but here's the set up, message, and erroreous class. I don't understand the errors from the compiler enough to parse down the erroneous file to something that contains only the bug, but I could if direction were given. Here's my set up: Eclipse SDK Version: 3.2.0 Build id: M20060629-1905 With AJDT: Eclipse AspectJ Development Tools Version: 1.4.1.200608141223 AspectJ version: 1.5.3.200608210848 Here's the bug dump from the compiler inside Eclipse:
******
tests/bugs153/pr158624/ValueChange.SyncValueGroup(T),False,new_method|test_method
tests/bugs153/pr158624/ValueChange.link(SyncValueGroup<T>),False,new_method|test_method
tests/bugs153/pr158624/ValueChange.SyncInteger(int),False,new_method|test_method
tests/bugs153/pr158624/ValueChange.testSyncValueGroup(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testGenericArrays_pr158624(),False,new_method|test_method
weaver/src/org/aspectj/weaver/ResolvedMemberImpl.parameterizedWith(UnresolvedType[], ResolvedType, boolean, List),True
#####
AspectJ
123423
db68044fe8ea0f43a5e090a67b9410f4c334bff6
RFE: Expose withinType for pertypewithin aspects Per type within aspects have a generated field ajc$withinType. Almost any time I ever use one of them, I'd like to access this field. Sometimes, e.g., for deferred initialization, I have to create a duplicate field that initializes this as such: private Class managedClass; after() returning: staticinitialization(*) { managedClass = thisJoinPointStaticPart.getSignature().getDeclaringType(); ... It would be nice if there were a method with the signature Class getWithinType() defined on any pertypewithin aspect.
RFE: Expose for aspects Per type within aspects have a generated field . Almost any time I ever use one of them, I'd like to access this field. Sometimes, e.g., for deferred initialization, I have to create a duplicate field that initializes this as such: ... It would be nice if there were a method with the signature Class defined on any aspect.
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.generatePerSupportMembers(ClassFile),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.generatePerTypeWithinGetWithinTypeNameMethod(ClassFile),False,new_method
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.buildPerClause(ClassScope),True
tests/features153/ptw/CaseFive.main(String),False,new_method|test_method
tests/features153/ptw/CaseFive.run(),False,new_method|test_method
tests/features153/ptw/CaseFour.main(String),False,new_method|test_method
tests/features153/ptw/CaseFour.run(),False,new_method|test_method
tests/features153/ptw/CaseOne.main(String),False,new_method|test_method
tests/features153/ptw/CaseOne.run(),False,new_method|test_method
tests/features153/ptw/CaseThree.main(String),False,new_method|test_method
tests/features153/ptw/CaseThree.run(),False,new_method|test_method
tests/features153/ptw/CaseTwo.main(String),False,new_method|test_method
tests/features153/ptw/CaseTwo.run(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testPTWgetWithinTypeName_pr123423_1(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testPTWgetWithinTypeName_pr123423_2(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testPTWgetWithinTypeName_pr123423_3(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testPTWgetWithinTypeName_pr123423_4(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testPTWgetWithinTypeName_pr123423_5(),False,new_method|test_method
weaver/src/org/aspectj/weaver/AjcMemberMaker.perTypeWithinGetWithinTypeNameMethod(UnresolvedType, boolean),False,new_method
weaver/src/org/aspectj/weaver/bcel/BcelPerClauseAspectAdder.doMunge(LazyClassGen, boolean),True
weaver/src/org/aspectj/weaver/bcel/BcelPerClauseAspectAdder.generatePerClauseMembers(LazyClassGen),True
weaver/src/org/aspectj/weaver/bcel/BcelPerClauseAspectAdder.generatePerTWGetWithinTypeNameMethod(LazyClassGen),False,new_method
#####
AspectJ
148908
fc39df195868a601e071f4fec900ab1854c43549
incorrect source signature for field ipe with qualified allocation expression Ajdoc chokes on interfaces with initializers for final fields (it doesn't preserve the initializer value). See attached AJDT project that fails when you run ajdoc with the default options on it: &gt; Calling ajc... &gt; Building signature files... &gt; Calling javadoc... Loading source file C:\eclipse\3.2\ajdocworkingdir\BadInterface.java... 1 error &gt; Decorating html files... &gt; Removing generated tags (this may take a while)... &gt; Finished. C:\eclipse\3.2\ajdocworkingdir\BadInterface.java:9: = expected static final Comparator MY_COMPARATOR; ^
incorrect source signature for field ipe with qualified allocation expression chokes on interfaces with initializers for final fields (it doesn't preserve the initializer value). See attached AJDT project that fails when you run ajdoc with the default options on it: &gt; Calling ajc... &gt; Building signature files... &gt; Calling javadoc... Loading source file ... 1 error &gt; Decorating html files... &gt; Removing generated tags (this may take a while)... &gt; Finished.
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.genSourceSignature(FieldDeclaration),True
tests/bugs153/pr148908/BadInterface.compare(Object, Object),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testGetSourceSignature_pr148908(),False,new_method|test_method
#####
AspectJ
161217
044542c6d5996806ce29156e83e1725823f5f8fe
NPE in BcelAdvice I've been playing with some aspect deployment models and got into this error during project rebuild from AJDT: java.lang.NullPointerException at org.aspectj.weaver.bcel.BcelAdvice.implementOn(BcelAdvice.java:199) at org.aspectj.weaver.Shadow.implementMungers(Shadow.java:699) at org.aspectj.weaver.Shadow.implement(Shadow.java:471) at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:2832) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:506) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeave ... lasses when weaving when batch building BuildConfig[...] #Files=6 Here is the aspect and classes it is applied to: ----- @Aspect("percflow(execution(* InstrumentedBean.getProperty2()))") public class GetFieldAtAspect { @Around("execution(* ConfigurableBean.getProperty2())") public Object onGet(ProceedingJoinPoint jp) throws Throwable { return jp.proceed(); } } ------ import org.springframework.beans.factory.InitializingBean; public class InstrumentedBean implements InitializingBean, IInstrumentedBean { private ConfigurableBean configurableBean; private String value; private transient String transientValue = "aaa"; public void afterPropertiesSet() throws Exception { this.configurableBean = new ConfigurableBean(); } public String getProperty1() { synchronized(this) { return this.configurableBean.getProperty1(); } } public String getProperty2() { synchronized(this) { return this.configurableBean.getProperty2(); } } public void setValue(String value) { synchronized(this) { this.value = value; } } public Object getValue() { synchronized(this) { return value; } } public Object getTransientValue() { return transientValue; } public void setTransientValue(String transientValue) { this.transientValue = transientValue; } } ------ import java.io.Serializable; import org.springframework.beans.factory.annotation.Configurable; @Configurable public class ConfigurableBean implements Serializable { private static final long serialVersionUID = 1L; private String property1; private String property2; public ConfigurableBean() { } public String getProperty1() { return this.property1; } public String getProperty2() { return this.property2; } public void setProperty1(String property1) { this.property1 = property1; } public void setProperty2(String property2) { this.property2 = property2; } }
NPE in I've been playing with some aspect deployment models and got into this error during project rebuild from AJDT: lasses when weaving when batch building [...] #Files=6 Here is the aspect and classes it is applied to:
******
tests/bugs153/pr161217/AtAspectJAspect.execOfEverything(),False,new_method|test_method
tests/bugs153/pr161217/C.foo(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testNoNPEWithThrownExceptionWarningAndAtAspectj_pr161217(),False,new_method|test_method
weaver/src/org/aspectj/weaver/bcel/BcelAdvice.implementOn(Shadow),True
#####
AspectJ
149289
bdb0b42d7d9264ef9d462adc5d3daf0f5956f188;59fcd7e0381512e59c6eed5c9429962b160ab66f;fa7ca52b5278bd824a43a08e3ecd5f038696bb1a
Support system and user aop.xml configuration files Both AJDT (Bug 71066) and AspectJ (Bug 95516) support the generation of an aop.xml to declare the set of know aspects for LTW. However if the user modifies the file to add options etc then the changes can be over-written. There is a need to allow the user to provide their own configuration in a separate file.
Support system and user aop.xml configuration files Both AJDT (Bug 71066) and AspectJ (Bug 95516) support the generation of an aop.xml to declare the set of know aspects for LTW. However if the user modifies the file to add options etc then the changes can be over-written. There is a need to allow the user to provide their own configuration in a separate file.
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.parseOption(String, LinkedList),True
org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.testOutxml(),True
taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.testOutxml(),False,test_method
tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.findCode(IProgramElement, int),False,test_method
loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor,True
bridge/src/org/aspectj/bridge/Constants,True
#####
AspectJ
138219
b166a7e6163889eb951f82655f0f49bfc26a49f0
Can't use a FQ Reference pointcut in any pointcut expression referenced by a per-clause A pointcut expression for a per-clause fails to resolve if it contains any reference pointcuts referring to pointcut expressions defined in other types. (Even if that is indirectly, through a local named pointcut).
Can't use a FQ Reference in any expression referenced by a per-clause A expression for a per-clause fails to resolve if it contains any reference referring to expressions defined in other types. (Even if that is indirectly, through a local named).
******
tests/bugs152/pr130722/test/Test.foo(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/GenericITDsDesign.getTypeMunger(String),False,test_method
tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.testReferencePCutInPerClause_pr138219(),False,test_method
tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.testReferencePCutInPerClause_pr130722(),False,new_method|test_method
weaver/src/org/aspectj/weaver/CrosscuttingMembers.CrosscuttingMembers(ResolvedType),True
CrosscuttingMembers(ResolvedType, boolean),False,new_method
weaver/src/org/aspectj/weaver/CrosscuttingMembers.getPerClause(),True
weaver/src/org/aspectj/weaver/CrosscuttingMembers.setPerClause(PerClause),True
weaver/src/org/aspectj/weaver/CrosscuttingMembers.replaceWith(CrosscuttingMembers,boolean),True
weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.addOrReplaceAspect(ResolvedType aspectType, boolean),True
weaver/src/org/aspectj/weaver/ResolvedType.addOrReplaceDescendantsOf(ResolvedType aspectType, boolean),True
weaver/src/org/aspectj/weaver/ResolvedType.collectCrosscuttingMembers(boolean),False,new_method
weaver/src/org/aspectj/weaver/ResolvedType.collectCrosscuttingMembers(),True
weaver/testsrc/org/aspectj/weaver/bcel/NonstaticWeaveTestCase.testBeforeCflow(),False,test_method
weaver/testsrc/org/aspectj/weaver/bcel/NonstaticWeaveTestCase.testBeforePerThis(),False,test_method
weaver/testsrc/org/aspectj/weaver/bcel/PointcutResidueTestCase.checkWeave(String, String, String, String[], String[]),False,test_method
weaver/testsrc/org/aspectj/weaver/bcel/WeaveOrderTestCase.testDominates(),False,test_method
weaver/testsrc/org/aspectj/weaver/bcel/WeaveOrderTestCase.testDominatesHarder(),False,test_method
#####
AspectJ
138223
6b2d9ae90158bd4e5cda5ecea5f3787400bab5af
Compiler crash on two binding @xxx pcds in one compound expression junit.framework.AssertionFailedError: test "Double at annotation matching (no binding)" failed test "Double at annotation matching (no binding)" failed Unexpected warning messages: warning at before() : transactionalOperation() { ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /private/tmp/ajcSandbox/ajcTest18924.tmp/DoubleAnnotationMatching.aj:20:0::0 advice defined in DoubleAnnotationMatching has not been applied [Xlint:adviceDidNotMatch] Unexpected fail messages: abort trouble in: class Foo extends java.lang.Object: void &lt;init&gt;(): ALOAD_0 // LFoo; this (line 26) INVOKESPECIAL java.lang.Object.&lt;init&gt; ()V constructor-execution(void Foo.&lt;init&gt;()) | RETURN constructor-execution(void Foo.&lt;init&gt;()) end void &lt;init&gt;() public void foo() org.aspectj.weaver.MethodDeclarationLineNumber: 28:533 : method-execution(void Foo.foo()) | RETURN (line 28) method-execution(void Foo.foo()) end public void foo() public void bar() org.aspectj.weaver.MethodDeclarationLineNumber: 30:563 : method-execution(void Foo.bar()) | RETURN (line 30) method-execution(void Foo.bar()) end public void bar() end class Foo -- (BCException) Impossible! annotation=[Tx] shadow=[method-execution(void Foo.foo()) at /private/tmp/ajcSandbox/ajcTest18924.tmp/DoubleAnnotationMatching.aj:28::533] pointcut is at [/private/tmp/ajcSandbox/ajcTest18924.tmp/DoubleAnnotationMatching.aj:15::316] when implementing on shadow method-execution(void Foo.foo()) when weaving type Foo when weaving classes when weaving when batch building BuildConfig[null] #Files=1 Impossible! annotation=[Tx] shadow=[method-execution(void Foo.foo()) at /private/tmp/ajcSandbox/ajcTest18924.tmp/DoubleAnnotationMatching.aj:28::533] pointcut is at [/private/tmp/ajcSandbox/ajcTest18924.tmp/DoubleAnnotationMatching.aj:15::316] when implementing on shadow method-execution(void Foo.foo()) when weaving type Foo when weaving classes when weaving when batch building BuildConfig[null] #Files=1 org.aspectj.weaver.BCException: Impossible! annotation=[Tx] shadow=[method-execution(void Foo.foo()) at /private/tmp/ajcSandbox/ajcTest18924.tmp/DoubleAnnotationMatching.aj:28::533] pointcut is at [/private/tmp/ajcSandbox/ajcTest18924.tmp/DoubleAnnotationMatching.aj:15::316] when implementing on shadow method-execution(void Foo.foo()) when weaving type Foo when weaving classes when weaving when batch building BuildConfig[null] #Files=1 at org.aspectj.weaver.patterns.AnnotationPointcut.findResidueInternal(AnnotationPointcut.java:201) at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267) at org.aspectj.weaver.patterns.AndPointcut.findResidueInternal(AndPointcut.java:93) at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267) at org.aspectj.weaver.patterns.AndPointcut.findResidueInternal(AndPointcut.java:93) at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267) at org.aspectj.weaver.patterns.IfPointcut.findResidueInternal(IfPointcut.java:173) at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267) at org.aspectj.weaver.patterns.AndPointcut.findResidueInternal(AndPointcut.java:93) at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267) at org.aspectj.weaver.patterns.AndPointcut.findResidueInternal(AndPointcut.java:93) at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267) at org.aspectj.weaver.patterns.OrPointcut.findResidueInternal(OrPointcut.java:96) at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267) at org.aspectj.weaver.bcel.BcelAdvice.specializeOn(BcelAdvice.java:132) at org.aspectj.weaver.bcel.BcelShadow.prepareForMungers(BcelShadow.java:325) at org.aspectj.weaver.Shadow.implement(Shadow.java:455) at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:2236) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:491) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:109) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1560) at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1511) at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1291) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1113) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:311) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:183) at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:862) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:242) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:161) at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:114) at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60) at org.aspectj.tools.ajc.Main.run(Main.java:367) at org.aspectj.tools.ajc.Main.runMain(Main.java:246) at org.aspectj.tools.ajc.Ajc.compile(Ajc.java:199) at org.aspectj.tools.ajc.Ajc.compile(Ajc.java:163) at org.aspectj.tools.ajc.AjcTestCase.ajc(AjcTestCase.java:510) at org.aspectj.testing.CompileSpec.execute(CompileSpec.java:53) at org.aspectj.testing.AjcTest.runTest(AjcTest.java:68) at org.aspectj.testing.XMLBasedAjcTestCase.runTest(XMLBasedAjcTestCase.java:111) at org.aspectj.systemtest.ajc152.Ajc152Tests.testDoubleAnnotationMatching_pr138221(Ajc152Tests.java:37) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult$1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) command was: ajc -classpath /Users/adrian/projects/aspectjdev/lib/test/aspectjrt.jar:../testing-client/bin:../runtime/bin:../aspectj5rt/bin:../lib/junit/junit.jar:../bridge/bin:../loadtime/bin:../weaver/bin:../weaver5/bin:../aj-build/jars/bridge.jar:../aj-build/jars/util.jar:../aj-build/jars/loadtime.jar:../aj-build/jars/weaver.jar:../aj-build/jars/weaver5.jar:../aj-build/jars/asm.jar:../lib/test/testing-client.jar:../lib/test/aspectjrt.jar:/tmp/ajcSandbox/ajcTest18924.tmp -1.5 /tmp/ajcSandbox/ajcTest18924.tmp/DoubleAnnotationMatching.aj -d /tmp/ajcSandbox/ajcTest18924.tmp at junit.framework.Assert.fail(Assert.java:47) at org.aspectj.tools.ajc.AjcTestCase.assertMessages(AjcTestCase.java:452) at org.aspectj.testing.CompileSpec.execute(CompileSpec.java:56) at org.aspectj.testing.AjcTest.runTest(AjcTest.java:68) at org.aspectj.testing.XMLBasedAjcTestCase.runTest(XMLBasedAjcTestCase.java:111) at org.aspectj.systemtest.ajc152.Ajc152Tests.testDoubleAnnotationMatching_pr138221(Ajc152Tests.java:37) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult$1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)
Compiler crash on two binding @xxx pcds in one compound expression : test "Double at annotation matching (no binding)" failed test "Double at annotation matching (no binding)" failed Unexpected warning messages
******
tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.testDoubleAnnotationMatching_pr138223(),False,test_method|formatting
weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.findResidueInternal(Shadow, ExposedState),True
#####
AspectJ
138215
d09fb718207be8b9a920f060b439eb89e1b1b544
Reference pointcut fails inside @DeclareWarning When a pointcut expression used with an @DeclareWarning construct contains a reference pointcut, the warning is correctly produced at matched join points, but the compiler also gives an error saying that the referenced pointcut cannot be found.
Reference pointcut fails inside When a pointcut expression used with an construct contains a reference pointcut, the warning is correctly produced at matched join points, but the compiler also gives an error saying that the referenced pointcut cannot be found.
******
weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.handleDeclareErrorOrWarningAnnotation(RuntimeAnnotations, AjAttributeFieldStruct),True
weaver/src/org/aspectj/weaver/bcel/BcelObjectType.ensureAspectJAttributesUnpacked(),True
weaver/src/org/aspectj/weaver/bcel/BcelObjectType.resolveAnnotationDeclares(List),False,new_method
#####
AspectJ
158412
e56a69a32149724c51daf0b52958607e5cc46eb4
@Pointcut in declare error results in NPE I am trying to use an @AspectJ @Pointcut in a "normal" AspectJ declare error expression. That results in the following exception. java.lang.NullPointerException at org.aspectj.weaver.patterns.ReferencePointcut.concretize1(ReferencePointcut.java:361) at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:233) at org.aspectj.weaver.patterns.NotPointcut.concretize1(NotPointcut.java:100) at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:233) at org.aspectj.weaver.patterns.AndPointcut.concretize1(AndPointcut.java:97) at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:233) at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:220) at org.aspectj.weaver.Checker.concretize(Checker.java:45) at org.aspectj.weaver.CrosscuttingMembers.addShadowMunger(CrosscuttingMembers.java:91) at org.aspectj.weaver.CrosscuttingMembers.addDeclare(CrosscuttingMembers.java:122) at org.aspectj.weaver.CrosscuttingMembers.addDeclares(CrosscuttingMembers.java:113) at org.aspectj.weaver.CrosscuttingMembersSet.addAdviceLikeDeclares(CrosscuttingMembersSet.java:117) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.addAdviceLikeDeclares(AjLookupEnvironment.java:382) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:245) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:887) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:244) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:199) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:170) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) NullPointerException thrown: null
in declare error results in NPE I am trying to use an  in a "normal" AspectJ declare error expression. That results in the following exception.
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.getPointcutStringFromAnnotationStylePointcut(AbstractMethodDeclaration),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.makeResolvedPointcutDefinition(AbstractMethodDeclaration),True
tests/bugs153/pr158412/layering/SystemArchitektur.inDAOLayer(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testAnnotationStylePointcutNPE_pr158412(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testAnnotationStylePointcutNPE_pr158412_2(),False,new_method|test_method
#####
AspectJ
173602
1a370e866856f56916cd7816b41b936f75a3e338;382db453417023bddc42ab14fb5fac4da45b7362;a60967b92a4de61a55569f8b4828ad9575b521f9
InterTypeMethodDeclaration.java:90 The following exception is caused by a duplicate inter-type introduction method declaration in an aspect. Removing the duplicate method solves the problem. java.lang.NullPointerException at org.aspectj.ajdt.internal.compiler.ast.InterTypeMethodDeclaration.resolve(InterTypeMethodDeclaration.java:90) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1088) at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.resolve(AspectDeclaration.java:116) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1137) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:305) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:519) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:887) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:244) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:199) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:170) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) NullPointerException thrown: null
The following exception is caused by a duplicate inter-type introduction method declaration in an aspect. Removing the duplicate method solves the problem. 
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.resolve(ClassScope),True
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.duplicateMethodInType(SourceTypeBinding, AbstractMethodDeclaration),False,new_method
tests/src/org/aspectj/systemtest/ajc160/Ajc160Tests.testDuplicateITDsNPE_pr173602(),False,new_method|test_method
tests/bugs160/pr173602/X.foo(String),False,new_method|test_method
#####
AspectJ
104218
1232fbba13b21df11d0a9c58a04657441c447f98
Aspects woven with -Xreweavable are not rewoven during LTW If I weave a class with Aspect1 using -Xreweavable then load-time weave it with Aspect2 (using org.aspectj.weaver.loadtime.Aj) then Aspect1 is not rewoven. This is confirmed by the lack of weaveinfo messages for Aspect1. This works for post-compile weaving although there are no explicit tests. Attached is a reweavable test for binary weaving. It needs to be adapted to run under org.aspectj.systemtest.ajc150.ataspectj.
Aspects woven with -Xreweavable are not rewoven during LTW If I weave a class with Aspect1 using -Xreweavable then load-time weave it with Aspect2 (using ) then Aspect1 is not rewoven. This is confirmed by the lack of weaveinfo messages for Aspect1. This works for post-compile weaving although there are no explicit tests. Attached is a reweavable test for binary weaving. It needs to be adapted to run under
******
weaver/src/org/aspectj/weaver/WeaverMessages,True
tests/java5/ataspectj/ataspectj/ltwreweavable/AspectReweavableLogging.before(Advisable, JoinPoint),False,new_method|test_method
tests/java5/ataspectj/ataspectj/ltwreweavable/MainReweavableLogging.test1(),False,new_method|test_method
tests/java5/ataspectj/ataspectj/ltwreweavable/MainReweavableLogging.test2(),False,new_method|test_method
tests/java5/ataspectj/ataspectj/ltwreweavable/MainReweavableLogging.addJoinPoint(String),False,new_method|test_method
tests/java5/ataspectj/ataspectj/ltwreweavable/MainReweavableLogging.main(String[]),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.testLTWDecp(),False,test_method
testCompileTimeAspectsDeclaredToLTWWeaver(),False,new_method|test_method
weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.mungeMethodDelegate(BcelClassWeaver, MethodDelegateTypeMunger),True
weaver/src/org/aspectj/weaver/bcel/BcelWeaver.processReweavableStateIfPresent(String, BcelObjectType),True
#####
AspectJ
145693
d16403655828b58d1ffbdb8d9ab4457c097bd746;9249d0c861535733f679f1307dfe334f2769c6f2
Verify Error unless inpath entry also on classpath and with -Xlint ignoring cantFindType See attached failing testCase.
Verify Error unless inpath entry also on classpath and with -Xlint ignoring See attached failing.
******
org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.initBcelWorld(IMessageHandler),True
weaver/src/org/aspectj/weaver/patterns/ConcreteCflowPointcut.matchInternal(Shadow),True
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testIncorrectAnnotationValue_pr148537(),False,test_method
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testVerifyErrNoTypeCflowField_pr145693_1(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testVerifyErrInpathNoTypeCflowField_pr145693_2(),False,new_method|test_method
tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.testCpathNoTypeCflowField_pr145693_3(),False,new_method|test_method
#####
AspectJ
64069
7fd50c75ae779195b87922c5ffd839ac7a6910bf
ITD name clashes with private members When weaving into source, ITDs for constructors and methods override private members of the same signature: it is as if the private member never existed. This is illustrated by the example in Dups.java. The same example, when the classes are compiled separately and using bytecode weaving, gives a ClassFormatError upon execution. The situation for fields is different: the compiler flags an error when an ITD tries to introduce a public x where a private x already existed. The error is however flagged only when x is used in the class. Without any uses, such a clashing field is passed by the compiler, but when the program is run, java throws a ClassFormatError. This behaviour is illustrated in DupField.java The above seems to be a bug: the behaviour should be consistent in all situations. Request: make it always legal to introduce a new member by ITD that has the same name/signature as a private member. Mangle the private member and all its uses. /* --------------------------------------------------------------- Dups.java When weaving into source, ITDs for constructors and methods override private members of the same name. Using bytecode weaving (and separate class files for each of the classes) this example gives a ClassFormatError upon execution. */ aspect Aspect { public A.new() { super(); System.out.println("ITD A()"); } public void A.bar() { System.out.println("ITD bar"); } } class A { void foo() { A a = new A(); bar(); } private A() { super(); System.out.println("private A()"); } private void bar() { System.out.println("private bar"); } } public class Dups { static public void main(String[] args) { new A().foo(); } } /* ------------------------------------------------------------------ DupField.java The compiler flags an error when an ITD tries to introduce a public x where a private x already existed. The error is however flagged only when x is used in the class. Without any uses, such a clashing field is passed by the compiler, but when the program is run, java throws a ClassFormatError. This behaviour is illustrated in DupField.java: to see the ClassFormatError, comment out the assignment "x=0" in foo(). */ aspect Aspect { public int A.x; } class A { private int x; void foo() { // when the line below is commented, we get a runtime error x=0; // error: The field x is ambiguous } } public class DupField { static public void main(String[] args) { new A(); } }
ITD name clashes with private members When weaving into source, ITDs for constructors and methods override private members of the same signature: it is as if the private member never existed. This is illustrated by the example in . The same example, when the classes are compiled separately and using bytecode weaving, gives a upon execution. The situation for fields is different: the compiler flags an error when an ITD tries to introduce a public x where a private x already existed. The error is however flagged only when x is used in the class. Without any uses, such a clashing field is passed by the compiler, but when the program is run, java throws a. This behaviour is illustrated in The above seems to be a bug: the behaviour should be consistent in all situations. Request: make it always legal to introduce a new member by ITD that has the same name/signature as a private member. Mangle the private member and all its uses. /* --------------------------------------------------------------- When weaving into source, ITDs for constructors and methods override private members of the same name. Using bytecode weaving (and separate class files for each of the classes) this example gives a upon execution. The compiler flags an error when an ITD tries to introduce a public x where a private x already existed. The error is however flagged only when x is used in the class. Without any uses, such a clashing field is passed by the compiler, but when the program is run, java throws a. This behaviour is illustrated in : to see the, comment out the assignment
******
tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.test044_ITDnameClashes(),False,new_method|test_method
weaver/src/org/aspectj/weaver/ResolvedTypeX.compareToExistingMembers(ConcreteTypeMunger, Iterator),True
weaver/src/org/aspectj/weaver/ResolvedTypeX.isDuplicateMemberWithinTargetType(ResolvedMember, ResolvedTypeX,ResolvedMember),False,new_method
#####
AspectJ
150271
8549d861b124c20eba114b658e886bfbaf5d231c
Allow multiple levels of LTW information It would be nice if basic information about load-time weaving (what version of AspectJ is being used, what loaders are doing weaving and what configuration is being used) was available without all of the -verbose information listing of all classes woven or not woven. It's also unfortunate that the flags for weaving level are 2 quite different ones: -Daj.weaving.verbose -Dorg.aspectj.weaver.showWeaveInfo Why not something like -Dorg.aspectj.weaver.level=[none|summary|info|verbose] summary: just what configuration is used info: list affected join points etc. (like showWeaveInfo) verbose: all (like verbose now)
Allow multiple levels of LTW information It would be nice if basic information about load-time weaving (what version of AspectJ is being used, what loaders are doing weaving and what configuration is being used) was available without all of the -verbose information listing of all classes woven or not woven. It's also unfortunate that the flags for weaving level are 2 quite different ones: =[none|summary|info|verbose] summary: just what configuration is used info: list affected join points etc. (like ) verbose: all (like verbose now)
******
loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.defineClass(ClassLoader, String, byte[]),True
loadtime/src/org/aspectj/weaver/loadtime/DefaultMessageHandler.isIgnoring(IMessage.Kind),True
loadtime/src/org/aspectj/weaver/loadtime/Options.parse(String, ClassLoader, IMessageHandler),True
tests/java5/ataspectj/ataspectj/TestHelper.handleMessage(IMessage),False,test_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.weaveClass(String, byte[]),True
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.debug(String),False,new_method
weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.WeavingAdaptorMessageWriter(PrintWriter),True
#####